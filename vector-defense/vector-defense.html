<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Defense</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        html, body { margin: 0; padding: 0; background: #09090b; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
const { useState, useEffect, useRef, useCallback } = React;

// --- Inline SVG Icon Components (replacing lucide-react) ---
const SvgIcon = ({ children, size = 24, className = '', style = {}, ...props }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24"
         fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round"
         strokeLinejoin="round" className={className} style={style} {...props}>
        {children}
    </svg>
);

const Play = (props) => <SvgIcon {...props}><polygon points="5 3 19 12 5 21 5 3"/></SvgIcon>;
const RotateCcw = (props) => <SvgIcon {...props}><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></SvgIcon>;
const Shield = (props) => <SvgIcon {...props}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></SvgIcon>;
const DollarSign = (props) => <SvgIcon {...props}><line x1="12" y1="1" x2="12" y2="23"/><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/></SvgIcon>;
const Crosshair = (props) => <SvgIcon {...props}><circle cx="12" cy="12" r="10"/><line x1="22" y1="12" x2="18" y2="12"/><line x1="6" y1="12" x2="2" y2="12"/><line x1="12" y1="6" x2="12" y2="2"/><line x1="12" y1="22" x2="12" y2="18"/></SvgIcon>;
const Trophy = (props) => <SvgIcon {...props}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></SvgIcon>;
const AlertTriangle = (props) => <SvgIcon {...props}><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></SvgIcon>;
const Zap = (props) => <SvgIcon {...props}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></SvgIcon>;
const Target = (props) => <SvgIcon {...props}><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></SvgIcon>;
const Wifi = (props) => <SvgIcon {...props}><path d="M5 12.55a11 11 0 0 1 14.08 0"/><path d="M1.42 9a16 16 0 0 1 21.16 0"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><line x1="12" y1="20" x2="12.01" y2="20"/></SvgIcon>;

// --- Constants ---
const GAME_WIDTH = 800;
const GAME_HEIGHT = 600;
const PLAYER_PROJECTILE_SPEED = 15;
const SAM_SPEED = 7;
const EXPLOSION_GROWTH = 1.5;

// Balance Constants
const FLAK_COST = 800;
const SAM_COST = 1800;
const ARTILLERY_COST = 2800;
const LASER_COST = 4500;
const UPGRADE_BASE_COST = 500;
const FORTIFY_BASE_COST = 800;
const CITY_REPAIR_PENALTY = 300;
const WAVE_COMPLETE_BONUS = 2500;

// Two-tier terrain layout
const CITY_ZONE_TOP = 530;        // Above this = turret zone, below = city zone
const LOWER_TERRAIN_Y = 580;      // City foreground baseline (lowered & flattened)

// Enemy Stats (HP values)
const HP_NORMAL = 10;
const HP_FAST = 15;
const HP_ARMORED = 40;
const HP_BOSS_BASE = 200;

// Turret Stats
const TURRET_TYPES = {
  FLAK: {
    name: 'FLAK',
    desc: 'Suppression',
    color: '#00ff00',
    range: 600,
    fireRate: 12,
    explosionRadius: 8,
    projectileColor: '#0f0',
    damage: 3,
    cost: FLAK_COST,
    icon: Crosshair
  },
  SAM: {
    name: 'SAM',
    desc: 'High Impact',
    color: '#00ffff',
    range: 400,
    fireRate: 45,
    explosionRadius: 20,
    projectileColor: '#0ff',
    damage: 40,
    cost: SAM_COST,
    icon: Target
  },
  ARTILLERY: {
    name: 'ARTILLERY',
    desc: 'Massive Area',
    color: '#ff00ff',
    range: 350,
    fireRate: 70,
    explosionRadius: 100,
    projectileColor: '#f0f',
    damage: 20,
    cost: ARTILLERY_COST,
    icon: Shield
  },
  LASER: {
    name: 'LASER',
    desc: 'Focused Beam',
    color: '#ffff00',
    range: 500,
    fireRate: 8,
    explosionRadius: 10,
    projectileColor: '#ff0',
    damage: 3,
    cost: LASER_COST,
    icon: Zap
  }
};

// --- Helper Functions ---
const distance = (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);

// --- Audio Engine ---
let audioCtx = null;
let masterGain = null;
const initAudio = () => {
    if (audioCtx) return;
    audioCtx = new AudioContext();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.3;
    masterGain.connect(audioCtx.destination);
};

let lastEnemyHitFrame = 0;

const Sound = {
    turretFire(type) {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        if (type === 'FLAK') {
            // Short white noise burst, bandpass ~2kHz
            const bufferSize = audioCtx.sampleRate * 0.08;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
            const src = audioCtx.createBufferSource();
            src.buffer = buffer;
            const bp = audioCtx.createBiquadFilter();
            bp.type = 'bandpass';
            bp.frequency.value = 2000;
            bp.Q.value = 1.5;
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0.4, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
            src.connect(bp).connect(g).connect(masterGain);
            src.start(t);
            src.stop(t + 0.08);
        } else if (type === 'SAM') {
            // Rising sine sweep 200->800Hz
            const osc = audioCtx.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(200, t);
            osc.frequency.exponentialRampToValueAtTime(800, t + 0.12);
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0.3, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
            osc.connect(g).connect(masterGain);
            osc.start(t);
            osc.stop(t + 0.12);
        } else if (type === 'ARTILLERY') {
            // Low boom: sine 80Hz + noise burst
            const osc = audioCtx.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = 80;
            const g1 = audioCtx.createGain();
            g1.gain.setValueAtTime(0.5, t);
            g1.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
            osc.connect(g1).connect(masterGain);
            osc.start(t);
            osc.stop(t + 0.15);
            // noise layer
            const bufferSize = audioCtx.sampleRate * 0.1;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
            const src = audioCtx.createBufferSource();
            src.buffer = buffer;
            const lp = audioCtx.createBiquadFilter();
            lp.type = 'lowpass';
            lp.frequency.value = 600;
            const g2 = audioCtx.createGain();
            g2.gain.setValueAtTime(0.4, t);
            g2.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
            src.connect(lp).connect(g2).connect(masterGain);
            src.start(t);
            src.stop(t + 0.1);
        }
    },

    laserBeam(dwellTime) {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        const dwell = dwellTime || 0;
        const osc = audioCtx.createOscillator();
        osc.type = 'sine';
        // Low base pitch that rises slightly with dwell
        const baseFreq = 180 + Math.min(dwell, 60) * 2;
        osc.frequency.setValueAtTime(baseFreq, t);
        osc.frequency.linearRampToValueAtTime(baseFreq + 40, t + 0.06);
        // Subtle slow vibrato
        const lfo = audioCtx.createOscillator();
        lfo.frequency.value = 8;
        const lfoGain = audioCtx.createGain();
        lfoGain.gain.value = 6;
        lfo.connect(lfoGain).connect(osc.frequency);
        const g = audioCtx.createGain();
        const vol = Math.min(0.06 + dwell / 500, 0.15);
        g.gain.setValueAtTime(vol, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.06);
        osc.connect(g).connect(masterGain);
        osc.start(t);
        lfo.start(t);
        osc.stop(t + 0.06);
        lfo.stop(t + 0.06);
    },

    explosion(maxRadius) {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        const large = maxRadius > 50;
        const dur = large ? 0.4 : 0.2;
        const bufferSize = audioCtx.sampleRate * dur;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        const lp = audioCtx.createBiquadFilter();
        lp.type = 'lowpass';
        lp.frequency.setValueAtTime(large ? 800 : 1200, t);
        lp.frequency.exponentialRampToValueAtTime(100, t + dur);
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(large ? 0.5 : 0.3, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + dur);
        src.connect(lp).connect(g).connect(masterGain);
        src.start(t);
        src.stop(t + dur);
    },

    enemyHit() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        osc.type = 'triangle';
        osc.frequency.value = 600;
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.15, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.03);
        osc.connect(g).connect(masterGain);
        osc.start(t);
        osc.stop(t + 0.03);
    },

    cityDestroyed() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        // Low descending tone + noise
        const osc = audioCtx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, t);
        osc.frequency.exponentialRampToValueAtTime(100, t + 0.5);
        const g1 = audioCtx.createGain();
        g1.gain.setValueAtTime(0.4, t);
        g1.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
        osc.connect(g1).connect(masterGain);
        osc.start(t);
        osc.stop(t + 0.5);
        const bufferSize = audioCtx.sampleRate * 0.3;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        const lp = audioCtx.createBiquadFilter();
        lp.type = 'lowpass';
        lp.frequency.value = 400;
        const g2 = audioCtx.createGain();
        g2.gain.setValueAtTime(0.3, t);
        g2.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        src.connect(lp).connect(g2).connect(masterGain);
        src.start(t);
        src.stop(t + 0.3);
    },

    waveStart() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(300, t);
        osc.frequency.exponentialRampToValueAtTime(600, t + 0.3);
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.2, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        osc.connect(g).connect(masterGain);
        osc.start(t);
        osc.stop(t + 0.3);
    },

    bossWarning() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        // Two alternating low alarm tones
        for (let i = 0; i < 3; i++) {
            const osc = audioCtx.createOscillator();
            osc.type = 'square';
            osc.frequency.value = i % 2 === 0 ? 150 : 120;
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0, t + i * 0.2);
            g.gain.linearRampToValueAtTime(0.3, t + i * 0.2 + 0.02);
            g.gain.setValueAtTime(0.3, t + i * 0.2 + 0.15);
            g.gain.linearRampToValueAtTime(0, t + i * 0.2 + 0.19);
            osc.connect(g).connect(masterGain);
            osc.start(t + i * 0.2);
            osc.stop(t + i * 0.2 + 0.2);
        }
    },

    gameOver() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        // Descending 3-note sequence
        const notes = [440, 330, 220];
        notes.forEach((freq, i) => {
            const osc = audioCtx.createOscillator();
            osc.type = 'square';
            osc.frequency.value = freq;
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0.25, t + i * 0.25);
            g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.25 + 0.22);
            osc.connect(g).connect(masterGain);
            osc.start(t + i * 0.25);
            osc.stop(t + i * 0.25 + 0.25);
        });
    },

    upgrade() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        // Quick ascending 2-note chirp
        const notes = [500, 750];
        notes.forEach((freq, i) => {
            const osc = audioCtx.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = freq;
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0.25, t + i * 0.07);
            g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.07 + 0.06);
            osc.connect(g).connect(masterGain);
            osc.start(t + i * 0.07);
            osc.stop(t + i * 0.07 + 0.07);
        });
    },

    empFire() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        // Descending sweep with electric crackle
        const osc = audioCtx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(1200, t);
        osc.frequency.exponentialRampToValueAtTime(60, t + 0.5);
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.35, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
        osc.connect(g).connect(masterGain);
        osc.start(t);
        osc.stop(t + 0.5);
        // Noise crackle layer
        const bufferSize = audioCtx.sampleRate * 0.3;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        const bp = audioCtx.createBiquadFilter();
        bp.type = 'bandpass';
        bp.frequency.setValueAtTime(800, t);
        bp.frequency.exponentialRampToValueAtTime(200, t + 0.3);
        bp.Q.value = 2;
        const g2 = audioCtx.createGain();
        g2.gain.setValueAtTime(0.3, t);
        g2.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        src.connect(bp).connect(g2).connect(masterGain);
        src.start(t);
        src.stop(t + 0.3);
    },

    pointDefense() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        // Quick zap sound
        const osc = audioCtx.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(2000, t);
        osc.frequency.exponentialRampToValueAtTime(500, t + 0.06);
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.2, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.06);
        osc.connect(g).connect(masterGain);
        osc.start(t);
        osc.stop(t + 0.06);
    },

    placeTurret() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        // Short click + confirmation beep
        const bufferSize = audioCtx.sampleRate * 0.02;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        const g1 = audioCtx.createGain();
        g1.gain.setValueAtTime(0.2, t);
        g1.gain.exponentialRampToValueAtTime(0.001, t + 0.02);
        src.connect(g1).connect(masterGain);
        src.start(t);
        src.stop(t + 0.02);
        // Confirmation beep
        const osc = audioCtx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = 880;
        const g2 = audioCtx.createGain();
        g2.gain.setValueAtTime(0, t + 0.03);
        g2.gain.linearRampToValueAtTime(0.2, t + 0.04);
        g2.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
        osc.connect(g2).connect(masterGain);
        osc.start(t + 0.03);
        osc.stop(t + 0.1);
    }
};

// --- Pre-create scanline overlay canvas ---
const scanlineCanvas = document.createElement('canvas');
scanlineCanvas.width = GAME_WIDTH;
scanlineCanvas.height = GAME_HEIGHT;
const scanlineCtx = scanlineCanvas.getContext('2d');
scanlineCtx.fillStyle = 'rgba(0, 0, 0, 0.12)';
for (let i = 0; i < GAME_HEIGHT; i += 4) {
    scanlineCtx.fillRect(0, i, GAME_WIDTH, 1);
}

// ============================================================
// MODULAR DRAW HELPERS (Phase 1-5)
// ============================================================

const drawBackground = (ctx, mapData, frameCount) => {
    ctx.fillStyle = '#050510';
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    // Stars
    if (mapData.stars) {
        mapData.stars.forEach(s => {
            const twinkle = 0.4 + 0.6 * Math.abs(Math.sin(frameCount * 0.02 + s.twinklePhase));
            ctx.globalAlpha = s.brightness * twinkle;
            ctx.fillStyle = s.color;
            ctx.fillRect(s.x, s.y, s.size, s.size);
        });
        ctx.globalAlpha = 1.0;
    }

    // Scanlines via offscreen canvas
    ctx.drawImage(scanlineCanvas, 0, 0);

    // Grid
    ctx.strokeStyle = '#0a0a0a';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let i = 0; i < GAME_WIDTH; i += 50) { ctx.moveTo(i, 0); ctx.lineTo(i, GAME_HEIGHT); }
    for (let i = 0; i < GAME_HEIGHT; i += 50) { ctx.moveTo(0, i); ctx.lineTo(GAME_WIDTH, i); }
    ctx.stroke();
};

const drawUpperTerrain = (ctx, points, mapData) => {
    if (!points || points.length === 0) return;

    // Background mountains (behind upper terrain)
    if (mapData.bgTerrain && mapData.bgTerrain.length > 0) {
        ctx.beginPath();
        ctx.moveTo(0, GAME_HEIGHT);
        ctx.lineTo(0, mapData.bgTerrain[0].y);
        mapData.bgTerrain.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.lineTo(GAME_WIDTH, mapData.bgTerrain[mapData.bgTerrain.length - 1].y);
        ctx.lineTo(GAME_WIDTH, GAME_HEIGHT);
        ctx.fillStyle = '#000d00';
        ctx.fill();
        ctx.strokeStyle = '#002200';
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    // Upper terrain fill — full depth background layer
    ctx.beginPath();
    ctx.moveTo(0, GAME_HEIGHT);
    ctx.lineTo(0, points[0].y);
    points.forEach(p => ctx.lineTo(p.x, p.y));
    ctx.lineTo(GAME_WIDTH, points[points.length - 1].y);
    ctx.lineTo(GAME_WIDTH, GAME_HEIGHT);
    ctx.fillStyle = '#001a00';
    ctx.fill();

    // Rock face hatching on steep slopes
    for (let i = 0; i < points.length - 1; i++) {
        const p1 = points[i];
        const p2 = points[i + 1];
        const slope = Math.abs(p2.y - p1.y) / (p2.x - p1.x || 1);
        if (slope > 1.2) {
            ctx.strokeStyle = '#002200';
            ctx.lineWidth = 1;
            const steps = 3;
            for (let s = 0; s < steps; s++) {
                const t = (s + 0.5) / steps;
                const hx = p1.x + (p2.x - p1.x) * t;
                const hy = p1.y + (p2.y - p1.y) * t;
                ctx.beginPath();
                ctx.moveTo(hx, hy);
                ctx.lineTo(hx + 4, hy + 6);
                ctx.stroke();
            }
        }
    }

    // Snow caps on highest peaks
    for (let i = 1; i < points.length - 1; i++) {
        const p = points[i];
        if (p.y < 430 && p.y < points[i - 1].y && p.y < points[i + 1].y) {
            ctx.fillStyle = 'rgba(200, 220, 255, 0.15)';
            ctx.beginPath();
            ctx.moveTo(p.x - 6, p.y);
            ctx.lineTo(p.x, p.y - 5);
            ctx.lineTo(p.x + 6, p.y);
            ctx.fill();
        }
    }

    // Upper terrain outline with CRT glow
    ctx.save();
    ctx.shadowColor = '#00ff00';
    ctx.shadowBlur = 6;
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, points[0].y);
    points.forEach(p => ctx.lineTo(p.x, p.y));
    ctx.lineTo(GAME_WIDTH, points[points.length - 1].y);
    ctx.stroke();
    ctx.restore();

    // Vegetation on gentle slopes
    if (mapData.vegetation) {
        mapData.vegetation.forEach(v => {
            ctx.strokeStyle = v.color;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(v.x, v.y);
            ctx.lineTo(v.x, v.y - v.h);
            ctx.stroke();
        });
    }
};

const drawLowerTerrain = (ctx, points) => {
    if (!points || points.length === 0) return;

    // Lower terrain fill
    ctx.beginPath();
    ctx.moveTo(0, GAME_HEIGHT);
    ctx.lineTo(0, points[0].y);
    points.forEach(p => ctx.lineTo(p.x, p.y));
    ctx.lineTo(GAME_WIDTH, points[points.length - 1].y);
    ctx.lineTo(GAME_WIDTH, GAME_HEIGHT);
    ctx.fillStyle = '#0a0a05';
    ctx.fill();

    // Dimmer outline glow (amber tint)
    ctx.save();
    ctx.shadowColor = '#886600';
    ctx.shadowBlur = 4;
    ctx.strokeStyle = '#665500';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(0, points[0].y);
    points.forEach(p => ctx.lineTo(p.x, p.y));
    ctx.lineTo(GAME_WIDTH, points[points.length - 1].y);
    ctx.stroke();
    ctx.restore();

    // Atmospheric haze at bottom
    const hazeGrad = ctx.createLinearGradient(0, GAME_HEIGHT * 0.85, 0, GAME_HEIGHT);
    hazeGrad.addColorStop(0, 'rgba(5, 10, 0, 0)');
    hazeGrad.addColorStop(1, 'rgba(5, 10, 0, 0.3)');
    ctx.fillStyle = hazeGrad;
    ctx.fillRect(0, GAME_HEIGHT * 0.85, GAME_WIDTH, GAME_HEIGHT * 0.15);
};

const TIER_COLORS = [
    { gradTop: '#009999', gradBot: '#004444', outline: '#005555', winLit: '#88dddd', winDark: '#003333', antenna: '#005555' },
    { gradTop: '#00cccc', gradBot: '#005566', outline: '#006677', winLit: '#aaffff', winDark: '#003344', antenna: '#006666' },
    { gradTop: '#00eeff', gradBot: '#006677', outline: '#007788', winLit: '#bbffff', winDark: '#004455', antenna: '#008888' },
    { gradTop: '#aaddff', gradBot: '#2255aa', outline: '#3366bb', winLit: '#ddeeff', winDark: '#113366', antenna: '#4488cc' },
    { gradTop: '#cc88ff', gradBot: '#3322aa', outline: '#5533cc', winLit: '#ddaaff', winDark: '#221166', antenna: '#7744dd' },
    { gradTop: '#ffdd66', gradBot: '#aa6600', outline: '#cc8800', winLit: '#ffeeaa', winDark: '#554400', antenna: '#ddaa44' },
];

const drawCity = (ctx, city, frameCount) => {
    if (!city.active) return;
    const tier = city.tier != null ? city.tier : 1;
    const tc = TIER_COLORS[Math.min(tier, 5)];

    // Light pollution glow — scales with tier
    ctx.save();
    const glowR = 50 + tier * 10;
    const glowA = 0.06 + tier * 0.02;
    const gc = TIER_COLORS[Math.min(tier, 5)];
    const glowGrad = ctx.createRadialGradient(city.x, city.y, 5, city.x, city.y, glowR);
    glowGrad.addColorStop(0, `rgba(${gc.winLit === '#ffeeaa' ? '255,220,100' : gc.winLit === '#ddaaff' ? '180,120,255' : gc.winLit === '#ddeeff' ? '150,200,255' : '0,200,200'}, ${glowA})`);
    glowGrad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = glowGrad;
    ctx.fillRect(city.x - glowR, city.y - glowR, glowR * 2, glowR);
    ctx.restore();

    // Shield shimmer for tier 3+
    if (tier >= 3) {
        ctx.save();
        const shimmerAlpha = 0.04 + 0.03 * Math.sin(frameCount * 0.03);
        const shieldR = 45 + tier * 8;
        ctx.strokeStyle = tier >= 5
            ? `rgba(255, 220, 100, ${shimmerAlpha + 0.06 * Math.sin(frameCount * 0.08)})`
            : tier >= 4
            ? `rgba(180, 120, 255, ${shimmerAlpha})`
            : `rgba(100, 200, 255, ${shimmerAlpha})`;
        ctx.lineWidth = tier >= 5 ? 2 : 1;
        ctx.beginPath();
        ctx.arc(city.x, city.y - 10, shieldR, Math.PI, 0);
        ctx.stroke();
        // Tier 5: pulsing golden ring
        if (tier >= 5) {
            const ringAlpha = 0.08 + 0.06 * Math.sin(frameCount * 0.06);
            ctx.strokeStyle = `rgba(255, 200, 80, ${ringAlpha})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(city.x, city.y - 5, shieldR + 8, Math.PI * 1.1, Math.PI * -0.1);
            ctx.stroke();
        }
        ctx.restore();
    }

    city.buildings.forEach(b => {
        const dmg = b.damage || 0;
        // Deterministic hash from xOffset for consistent damage patch positions
        const hash = Math.abs(b.xOffset * 1000) | 0;

        // Rubble: only draw bottom stump
        if (dmg >= 0.8) {
            const stumpH = b.h * (0.15 + (hash % 10) * 0.01);
            const bx = city.x + b.xOffset - (b.w / 2);
            const by = city.y - stumpH;
            ctx.fillStyle = '#333';
            ctx.fillRect(bx, by, b.w, stumpH);
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            ctx.strokeRect(bx, by, b.w, stumpH);
            // Smoke: light gray pixel drifting up
            const smokeX = bx + b.w * 0.5 + Math.sin(frameCount * 0.05 + hash) * 2;
            const smokeY = by - 2 - Math.abs(Math.sin(frameCount * 0.03 + hash)) * 4;
            ctx.fillStyle = 'rgba(150,150,150,0.4)';
            ctx.fillRect(smokeX, smokeY, 2, 2);
            return;
        }

        // Heavy damage: truncate height
        let visibleH = b.h;
        if (dmg > 0.5) {
            visibleH = b.h * (1 - (dmg - 0.3) * 0.5);
        }

        const bx = city.x + b.xOffset - (b.w / 2);
        const by = city.y - visibleH;

        // Building gradient fill — tier colored
        const bGrad = ctx.createLinearGradient(bx, by, bx, city.y);
        bGrad.addColorStop(0, tc.gradTop);
        bGrad.addColorStop(1, tc.gradBot);
        ctx.fillStyle = bGrad;

        // Building shape
        if (dmg > 0.5) {
            // Heavy damage: jagged flat top, no fancy shapes
            ctx.fillRect(bx, by, b.w, visibleH);
        } else if (b.style === 'pointed') {
            ctx.beginPath();
            ctx.moveTo(bx, city.y);
            ctx.lineTo(bx, by + 4);
            ctx.lineTo(bx + b.w / 2, by);
            ctx.lineTo(bx + b.w, by + 4);
            ctx.lineTo(bx + b.w, city.y);
            ctx.fill();
        } else if (b.style === 'dome') {
            ctx.fillRect(bx, by + 4, b.w, visibleH - 4);
            ctx.beginPath();
            ctx.arc(bx + b.w / 2, by + 4, b.w / 2, Math.PI, 0);
            ctx.fill();
        } else if (b.style === 'stepped') {
            ctx.fillRect(bx + 2, by, b.w - 4, visibleH);
            ctx.fillRect(bx, by + visibleH * 0.3, b.w, visibleH * 0.7);
        } else {
            // flat with parapet lip
            ctx.fillRect(bx, by, b.w, visibleH);
            ctx.fillRect(bx - 1, by, b.w + 2, 2);
        }

        // Building outline
        ctx.strokeStyle = tc.outline;
        ctx.lineWidth = 1;
        ctx.strokeRect(bx, by, b.w, visibleH);

        // Damage patches (dark marks)
        if (dmg > 0.2) {
            const patchCount = dmg > 0.5 ? 2 + (hash % 2) : 1 + (hash % 2);
            ctx.fillStyle = '#111';
            for (let p = 0; p < patchCount; p++) {
                const px = bx + ((hash * (p + 1) * 7) % Math.max(1, Math.floor(b.w - 4))) + 2;
                const py = by + ((hash * (p + 1) * 13) % Math.max(1, Math.floor(visibleH * 0.6))) + visibleH * 0.2;
                const pw = 2 + (hash + p) % 3;
                const ph = 3 + (hash + p * 2) % 4;
                ctx.fillRect(px, py, pw, ph);
            }
        }

        // Fire pixels for heavy damage
        if (dmg > 0.5) {
            const fireCount = 1 + (hash % 2);
            for (let f = 0; f < fireCount; f++) {
                const fx = bx + ((hash * (f + 1) * 11) % Math.max(1, Math.floor(b.w - 2))) + 1;
                const fy = by + ((hash * (f + 1) * 7) % Math.max(1, Math.floor(visibleH * 0.4)));
                // Flickering orange/red
                if ((frameCount + hash + f) % 3 !== 0) {
                    ctx.fillStyle = (frameCount + f) % 2 === 0 ? '#ff6600' : '#ff3300';
                    ctx.fillRect(fx, fy, 2, 2);
                }
                // Smoke above fire
                const smokeY = fy - 3 - Math.abs(Math.sin(frameCount * 0.05 + hash + f)) * 3;
                ctx.fillStyle = 'rgba(150,150,150,0.3)';
                ctx.fillRect(fx, smokeY, 1, 1);
            }
        }

        // Windows (only if not heavily damaged)
        if (dmg < 0.5 && b.windows) {
            b.windows.forEach(win => {
                if (win.oy < visibleH - 2) {
                    const lit = ((frameCount >> 6) + win.phase) % 3 !== 0;
                    ctx.fillStyle = lit ? tc.winLit : tc.winDark;
                    ctx.fillRect(bx + win.ox, by + win.oy, 2, 2);
                }
            });
        }

        // Antenna (only if low damage)
        if (dmg < 0.3 && b.hasAntenna) {
            ctx.strokeStyle = tc.antenna;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(bx + b.w / 2, by);
            ctx.lineTo(bx + b.w / 2, by - 8);
            ctx.stroke();
            if ((frameCount >> 5) % 2 === 0) {
                ctx.fillStyle = tier >= 5 ? '#ffdd00' : tier >= 4 ? '#cc66ff' : '#ff0000';
                ctx.fillRect(bx + b.w / 2 - 1, by - 9, 2, 2);
            }
        }
    });
};

const drawTurret = (ctx, t, isHovered, gameState, frameCount) => {
    const color = isHovered ? '#ffff00' : t.stats.color;

    // Range circle
    if (gameState === 'PLACEMENT' && isHovered) {
        const rangeGrad = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, t.stats.range);
        rangeGrad.addColorStop(0, 'rgba(0, 255, 0, 0.03)');
        rangeGrad.addColorStop(0.8, 'rgba(0, 255, 0, 0.02)');
        rangeGrad.addColorStop(1, 'rgba(0, 255, 0, 0)');
        ctx.fillStyle = rangeGrad;
        ctx.beginPath();
        ctx.arc(t.x, t.y, t.stats.range, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
        ctx.setLineDash([5, 5]);
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(t.x, t.y, t.stats.range, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    const angle = t.angle || -Math.PI / 2;
    const recoil = t.recoilOffset || 0;

    if (t.type === 'FLAK') {
        // Concentric circles base
        ctx.fillStyle = '#000';
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(t.x, t.y, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(t.x, t.y, 6, 0, Math.PI * 2);
        ctx.stroke();

        // Dual barrels
        ctx.save();
        ctx.translate(t.x, t.y);
        ctx.rotate(angle);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-2, -recoil);
        ctx.lineTo(-2, -14 + recoil);
        ctx.moveTo(2, -recoil);
        ctx.lineTo(2, -14 + recoil);
        ctx.stroke();
        ctx.restore();

    } else if (t.type === 'SAM') {
        // Triangle base
        ctx.fillStyle = '#000';
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(t.x - 10, t.y);
        ctx.lineTo(t.x, t.y - 8);
        ctx.lineTo(t.x + 10, t.y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Gradient fill
        const samGrad = ctx.createLinearGradient(t.x, t.y, t.x, t.y - 8);
        samGrad.addColorStop(0, 'rgba(0, 255, 255, 0.1)');
        samGrad.addColorStop(1, 'rgba(0, 255, 255, 0.3)');
        ctx.fillStyle = samGrad;
        ctx.beginPath();
        ctx.moveTo(t.x - 10, t.y);
        ctx.lineTo(t.x, t.y - 8);
        ctx.lineTo(t.x + 10, t.y);
        ctx.closePath();
        ctx.fill();

        // Launcher rail
        ctx.save();
        ctx.translate(t.x, t.y - 4);
        ctx.rotate(angle + Math.PI / 2);
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, recoil);
        ctx.lineTo(0, 14 - recoil);
        ctx.stroke();
        // Rail tick marks
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-2, 4);
        ctx.lineTo(2, 4);
        ctx.moveTo(-2, 8);
        ctx.lineTo(2, 8);
        ctx.stroke();
        ctx.restore();

    } else if (t.type === 'ARTILLERY') {
        // Trapezoid body
        ctx.fillStyle = '#000';
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(t.x - 14, t.y + 6);
        ctx.lineTo(t.x - 10, t.y - 8);
        ctx.lineTo(t.x + 10, t.y - 8);
        ctx.lineTo(t.x + 14, t.y + 6);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Rivets
        ctx.fillStyle = color;
        ctx.fillRect(t.x - 8, t.y - 4, 2, 2);
        ctx.fillRect(t.x + 6, t.y - 4, 2, 2);
        ctx.fillRect(t.x - 8, t.y + 2, 2, 2);
        ctx.fillRect(t.x + 6, t.y + 2, 2, 2);

        // Long thick rotating barrel
        ctx.save();
        ctx.translate(t.x, t.y - 4);
        ctx.rotate(angle + Math.PI / 2);
        ctx.strokeStyle = color;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(0, recoil);
        ctx.lineTo(0, 20 - recoil);
        ctx.stroke();
        // Barrel tip
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(0, 18 - recoil);
        ctx.lineTo(0, 20 - recoil);
        ctx.stroke();
        ctx.restore();

    } else if (t.type === 'LASER') {
        // Octagon base
        ctx.fillStyle = '#000';
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            const a = (i / 8) * Math.PI * 2 - Math.PI / 8;
            const px = t.x + Math.cos(a) * 10;
            const py = t.y + Math.sin(a) * 10;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Pulsing inner ring
        const pulseAlpha = 0.3 + 0.7 * Math.abs(Math.sin(frameCount * 0.1 + (t.dwellTime || 0) * 0.05));
        ctx.strokeStyle = `rgba(255, 255, 0, ${pulseAlpha})`;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(t.x, t.y, 5, 0, Math.PI * 2);
        ctx.stroke();

        // Emitter stalk
        ctx.save();
        ctx.translate(t.x, t.y);
        ctx.rotate(angle + Math.PI / 2);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, 12);
        ctx.stroke();
        // Emitter tip dot
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(0, 13, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Heat bar
        const heat = t.laserHeat || 0;
        if (heat > 0) {
            const barW = 16;
            const barH = 2;
            const barX = t.x - barW / 2;
            const barY = t.y + 12;
            ctx.fillStyle = '#333';
            ctx.fillRect(barX, barY, barW, barH);
            const r = Math.min(255, Math.floor(heat * 2 * 255));
            const g = Math.max(0, Math.floor((1 - heat) * 200));
            ctx.fillStyle = t.laserOverheat
                ? (Math.floor(frameCount / 4) % 2 === 0 ? '#ff2200' : '#ff6600')
                : `rgb(${r}, ${g}, 0)`;
            ctx.fillRect(barX, barY, barW * heat, barH);
        }
    }

    // Muzzle flash
    if (t.muzzleFlashTimer > 0) {
        const flashAlpha = t.muzzleFlashTimer / 8;
        ctx.save();
        ctx.translate(t.x, t.y);
        ctx.rotate(angle + Math.PI / 2);
        const barrelLen = t.type === 'ARTILLERY' ? 20 : t.type === 'SAM' ? 14 : 14;
        ctx.fillStyle = `rgba(255, 255, 200, ${flashAlpha})`;
        ctx.beginPath();
        ctx.arc(0, barrelLen, 4 + t.muzzleFlashTimer, 0, Math.PI * 2);
        ctx.fill();
        // Starburst
        ctx.strokeStyle = `rgba(255, 255, 255, ${flashAlpha * 0.7})`;
        ctx.lineWidth = 1;
        for (let i = 0; i < 4; i++) {
            const sa = (i / 4) * Math.PI * 2;
            ctx.beginPath();
            ctx.moveTo(Math.cos(sa) * 2 + 0, barrelLen + Math.sin(sa) * 2);
            ctx.lineTo(Math.cos(sa) * (5 + t.muzzleFlashTimer), barrelLen + Math.sin(sa) * (5 + t.muzzleFlashTimer));
            ctx.stroke();
        }
        ctx.restore();
    }

    // Level pips - chevrons
    ctx.fillStyle = color;
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    for (let i = 0; i < t.level; i++) {
        const pipX = t.x - ((t.level - 1) * 4) / 2 + (i * 4);
        const pipY = t.y + 14;
        ctx.beginPath();
        ctx.moveTo(pipX, pipY + 3);
        ctx.lineTo(pipX + 2, pipY);
        ctx.lineTo(pipX + 4, pipY + 3);
        ctx.stroke();
    }

    // Glowing ring at level 3+
    if (t.level >= 3) {
        ctx.strokeStyle = `rgba(${color === '#00ff00' ? '0,255,0' : color === '#00ffff' ? '0,255,255' : color === '#ff00ff' ? '255,0,255' : '255,255,0'}, ${0.2 + 0.15 * Math.sin(frameCount * 0.08)})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(t.x, t.y, 14, 0, Math.PI * 2);
        ctx.stroke();
    }

    // EMP disabled overlay
    if (t.empDisabled > 0) {
        // Flickering opacity
        const flickerOn = Math.floor(frameCount / 3) % 2 === 0;
        ctx.save();
        ctx.globalAlpha = flickerOn ? 0.6 : 0.3;
        ctx.fillStyle = '#004466';
        ctx.beginPath();
        ctx.arc(t.x, t.y, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        // Cyan sparks around base
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 1;
        for (let i = 0; i < 3; i++) {
            const a = frameCount * 0.2 + (i / 3) * Math.PI * 2;
            const r = 10 + Math.random() * 4;
            ctx.beginPath();
            ctx.moveTo(t.x + Math.cos(a) * 8, t.y + Math.sin(a) * 8);
            ctx.lineTo(t.x + Math.cos(a + 0.3) * r, t.y + Math.sin(a + 0.3) * r);
            ctx.stroke();
        }

        // "EMP" text
        const textAlpha = t.empDisabled > 30 ? 0.8 : t.empDisabled / 30 * 0.8;
        ctx.fillStyle = `rgba(0, 255, 255, ${textAlpha})`;
        ctx.font = '8px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('EMP', t.x, t.y - 16);
        ctx.restore();
    }
};

const drawBomber = (ctx, b, frameCount) => {
    const dir = b.vx > 0 ? 1 : -1;

    // Fuselage - hexagonal
    ctx.save();
    ctx.translate(b.x, b.y);

    // Swept-back wings
    ctx.fillStyle = '#cccc00';
    ctx.beginPath();
    ctx.moveTo(dir * -4, 0);
    ctx.lineTo(dir * -12, -10);
    ctx.lineTo(dir * -8, 0);
    ctx.moveTo(dir * -4, 0);
    ctx.lineTo(dir * -12, 10);
    ctx.lineTo(dir * -8, 0);
    ctx.fill();

    // Fuselage gradient
    const fuseGrad = ctx.createLinearGradient(0, -5, 0, 5);
    fuseGrad.addColorStop(0, '#ffff44');
    fuseGrad.addColorStop(0.5, '#cccc00');
    fuseGrad.addColorStop(1, '#888800');
    ctx.fillStyle = fuseGrad;
    ctx.beginPath();
    ctx.moveTo(dir * 12, 0);
    ctx.lineTo(dir * 6, -5);
    ctx.lineTo(dir * -6, -5);
    ctx.lineTo(dir * -10, 0);
    ctx.lineTo(dir * -6, 5);
    ctx.lineTo(dir * 6, 5);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = '#aaaa00';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Cockpit
    ctx.fillStyle = '#aaffaa';
    ctx.fillRect(dir * 6, -2, dir * 4, 4);

    // Engine glow
    const enginePulse = 0.5 + 0.5 * Math.sin(frameCount * 0.3);
    ctx.fillStyle = `rgba(255, 150, 0, ${0.4 + enginePulse * 0.4})`;
    ctx.beginPath();
    ctx.ellipse(dir * -11, 0, 3 + enginePulse * 2, 2 + enginePulse, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();

    // HP bar
    if (b.hp < b.maxHp) {
        drawHPBar(ctx, b.x - 12, b.y - 16, 24, 3, b.hp / b.maxHp);
    }
};

const drawBossShip = (ctx, b, frameCount) => {
    const dir = b.vx > 0 ? 1 : -1;
    const scale = b.bossTier >= 2 ? 7.5 : 5.4;
    const isMega = b.bossTier >= 2;

    ctx.save();
    ctx.translate(b.x, b.y);

    // Shield visual (drawn behind ship)
    if (b.shieldActive && b.shield > 0) {
        const shieldAlpha = 0.15 + 0.1 * Math.sin(frameCount * 0.08);
        const shieldRadius = 20 * scale;
        ctx.save();
        ctx.strokeStyle = `rgba(0, 255, 255, ${shieldAlpha + 0.3})`;
        ctx.lineWidth = 2;
        // Hexagonal shield outline
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const a = (i / 6) * Math.PI * 2 + frameCount * 0.01;
            const px = Math.cos(a) * shieldRadius;
            const py = Math.sin(a) * shieldRadius * 0.7;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.stroke();
        ctx.fillStyle = `rgba(0, 255, 255, ${shieldAlpha})`;
        ctx.fill();
        ctx.restore();
    }

    // EMP charge glow (cyan, intensifies as charge builds)
    if (b.empCharge > 0 && b.empWindup <= 0) {
        const chargeRatio = b.empCharge / b.empMaxCharge;
        ctx.save();
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = chargeRatio * 15;
        ctx.fillStyle = `rgba(0, 255, 255, ${chargeRatio * 0.3})`;
        ctx.beginPath();
        ctx.arc(0, 0, 12 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    // EMP windup - blue arcs crackling
    if (b.empWindup > 0) {
        ctx.save();
        ctx.strokeStyle = `rgba(100, 150, 255, ${0.5 + 0.5 * Math.sin(frameCount * 0.5)})`;
        ctx.lineWidth = 2;
        for (let i = 0; i < 4; i++) {
            const a = (i / 4) * Math.PI * 2 + frameCount * 0.3;
            const r = 10 * scale;
            ctx.beginPath();
            ctx.moveTo(Math.cos(a) * r * 0.5, Math.sin(a) * r * 0.5);
            const mid1x = Math.cos(a + 0.3) * r * 0.75 + (Math.random() - 0.5) * 6;
            const mid1y = Math.sin(a + 0.3) * r * 0.75 + (Math.random() - 0.5) * 6;
            ctx.lineTo(mid1x, mid1y);
            ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
            ctx.stroke();
        }
        ctx.restore();
    }

    // Cluster bomb windup - orange glow
    if (b.clusterWindup > 0) {
        ctx.save();
        ctx.shadowColor = '#ff8800';
        ctx.shadowBlur = 12;
        ctx.fillStyle = `rgba(255, 136, 0, ${0.2 + 0.2 * Math.sin(frameCount * 0.4)})`;
        ctx.beginPath();
        ctx.arc(0, 0, 10 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    // Pulsing red glow
    ctx.save();
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 10 + 6 * Math.sin(frameCount * 0.12);

    // Swept-back wings (scaled)
    ctx.fillStyle = isMega ? '#880000' : '#993300';
    ctx.beginPath();
    ctx.moveTo(dir * -4 * scale, 0);
    ctx.lineTo(dir * -12 * scale, -10 * scale);
    ctx.lineTo(dir * -8 * scale, 0);
    ctx.moveTo(dir * -4 * scale, 0);
    ctx.lineTo(dir * -12 * scale, 10 * scale);
    ctx.lineTo(dir * -8 * scale, 0);
    ctx.fill();

    // Mega-boss: spiky wing protrusions
    if (isMega) {
        ctx.fillStyle = '#aa0000';
        ctx.beginPath();
        ctx.moveTo(dir * -8 * scale, -8 * scale);
        ctx.lineTo(dir * -14 * scale, -14 * scale);
        ctx.lineTo(dir * -10 * scale, -6 * scale);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(dir * -8 * scale, 8 * scale);
        ctx.lineTo(dir * -14 * scale, 14 * scale);
        ctx.lineTo(dir * -10 * scale, 6 * scale);
        ctx.fill();
    }

    // Fuselage gradient (red-orange)
    const fuseGrad = ctx.createLinearGradient(0, -5 * scale, 0, 5 * scale);
    fuseGrad.addColorStop(0, isMega ? '#ff2200' : '#ff6633');
    fuseGrad.addColorStop(0.5, isMega ? '#cc0000' : '#cc4400');
    fuseGrad.addColorStop(1, isMega ? '#880000' : '#882200');
    ctx.fillStyle = fuseGrad;
    ctx.beginPath();
    ctx.moveTo(dir * 12 * scale, 0);
    ctx.lineTo(dir * 6 * scale, -5 * scale);
    ctx.lineTo(dir * -6 * scale, -5 * scale);
    ctx.lineTo(dir * -10 * scale, 0);
    ctx.lineTo(dir * -6 * scale, 5 * scale);
    ctx.lineTo(dir * 6 * scale, 5 * scale);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = isMega ? '#ff4444' : '#cc6633';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.restore(); // end shadowBlur

    // Cockpit
    ctx.fillStyle = '#ff8866';
    ctx.fillRect(dir * 6 * scale, -2 * scale, dir * 4 * scale, 4 * scale);

    // Dual engine glows
    const enginePulse = 0.5 + 0.5 * Math.sin(frameCount * 0.25);
    const bombRunBoost = b.bombRunning > 0 ? 1.5 : 1;
    ctx.fillStyle = `rgba(255, ${b.bombRunning > 0 ? 200 : 80}, 0, ${(0.5 + enginePulse * 0.4) * bombRunBoost})`;
    ctx.beginPath();
    ctx.ellipse(dir * -11 * scale, -2.5 * scale, (3 + enginePulse * 2) * scale * bombRunBoost, (1.5 + enginePulse) * scale * 0.7, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(dir * -11 * scale, 2.5 * scale, (3 + enginePulse * 2) * scale * bombRunBoost, (1.5 + enginePulse) * scale * 0.7, 0, 0, Math.PI * 2);
    ctx.fill();

    // Bombing run afterburner trail
    if (b.bombRunning > 0) {
        ctx.fillStyle = `rgba(255, 150, 50, ${0.3 + enginePulse * 0.3})`;
        ctx.beginPath();
        ctx.ellipse(dir * -16 * scale, 0, (6 + enginePulse * 4) * scale, (3 + enginePulse * 2) * scale * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    // Mega-boss: center engine
    if (isMega) {
        ctx.fillStyle = `rgba(255, 200, 50, ${(0.4 + enginePulse * 0.5) * bombRunBoost})`;
        ctx.beginPath();
        ctx.ellipse(dir * -12 * scale, 0, (4 + enginePulse * 3) * scale * bombRunBoost, (2 + enginePulse) * scale * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    // Point defense flash
    if (b.pdFlash > 0) {
        ctx.save();
        ctx.fillStyle = `rgba(255, 50, 50, ${b.pdFlash / 10 * 0.4})`;
        ctx.beginPath();
        ctx.arc(0, 0, 15 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    ctx.restore();

    // HP bar (always visible for boss ships)
    const barW = isMega ? 60 : 40;
    const barY = b.y - 12 * scale - 4;
    drawHPBar(ctx, b.x - barW / 2, barY, barW, 4, b.hp / b.maxHp);

    // EMP charge bar (below HP bar)
    if (b.empCharge > 0 || b.empWindup > 0) {
        const empRatio = b.empWindup > 0 ? 1 : b.empCharge / b.empMaxCharge;
        ctx.fillStyle = '#333';
        ctx.fillRect(b.x - barW / 2, barY + 6, barW, 2);
        ctx.fillStyle = b.empWindup > 0 ? '#6699ff' : '#00cccc';
        ctx.fillRect(b.x - barW / 2, barY + 6, barW * empRatio, 2);
    }

    // Shield HP bar (below EMP bar, only when active)
    if (b.shieldActive && b.shield > 0) {
        ctx.fillStyle = '#333';
        ctx.fillRect(b.x - barW / 2, barY + 10, barW, 2);
        ctx.fillStyle = '#00ffff';
        ctx.fillRect(b.x - barW / 2, barY + 10, barW * (b.shield / 200), 2);
    }
};

const drawEnemyMissile = (ctx, m, frameCount) => {
    const isBoss = m.type === 'BOSS';
    const angle = Math.atan2(m.vy, m.vx);
    const speed = Math.sqrt(m.vx * m.vx + m.vy * m.vy);

    // Exhaust trail
    if (m.trailHistory && m.trailHistory.length > 1) {
        for (let i = 0; i < m.trailHistory.length - 1; i++) {
            const t = m.trailHistory[i];
            const alpha = (i / m.trailHistory.length) * 0.5;
            const width = (i / m.trailHistory.length) * (isBoss ? 4 : 2);
            ctx.strokeStyle = m.color;
            ctx.globalAlpha = alpha;
            ctx.lineWidth = width;
            ctx.beginPath();
            ctx.moveTo(t.x, t.y);
            ctx.lineTo(m.trailHistory[i + 1].x, m.trailHistory[i + 1].y);
            ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
    }

    ctx.save();
    ctx.translate(m.x, m.y);
    ctx.rotate(angle);

    if (m.type === 'NORMAL') {
        // Dart/arrowhead
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.moveTo(6, 0);
        ctx.lineTo(-4, -3);
        ctx.lineTo(-2, 0);
        ctx.lineTo(-4, 3);
        ctx.closePath();
        ctx.fill();
        // Glow dot at tail
        ctx.fillStyle = '#ffaa00';
        ctx.beginPath();
        ctx.arc(-3, 0, 1.5, 0, Math.PI * 2);
        ctx.fill();

    } else if (m.type === 'FAST') {
        // Elongated dart
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.moveTo(8, 0);
        ctx.lineTo(-5, -2.5);
        ctx.lineTo(-3, 0);
        ctx.lineTo(-5, 2.5);
        ctx.closePath();
        ctx.fill();
        // Speed lines
        ctx.strokeStyle = m.color;
        ctx.globalAlpha = 0.4;
        ctx.lineWidth = 1;
        for (let i = 0; i < 3; i++) {
            const y = -3 + i * 3;
            ctx.beginPath();
            ctx.moveTo(-8 - i * 4, y);
            ctx.lineTo(-14 - i * 4, y);
            ctx.stroke();
        }
        ctx.globalAlpha = 1.0;

    } else if (m.type === 'ARMORED') {
        // Larger diamond with inner diamond
        ctx.fillStyle = '#aaaaaa';
        ctx.beginPath();
        ctx.moveTo(7, 0);
        ctx.lineTo(0, -5);
        ctx.lineTo(-7, 0);
        ctx.lineTo(0, 5);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.stroke();
        // Inner diamond
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.moveTo(3, 0);
        ctx.lineTo(0, -2);
        ctx.lineTo(-3, 0);
        ctx.lineTo(0, 2);
        ctx.closePath();
        ctx.fill();
        // Partial shield arc
        ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(0, 0, 7, -0.8, 0.8);
        ctx.stroke();

    } else if (m.type === 'BOSS') {
        // Hexagonal head with pulsing glow
        ctx.save();
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 8 + 4 * Math.sin(frameCount * 0.15);
        ctx.fillStyle = '#cc0000';
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const a = (i / 6) * Math.PI * 2;
            const px = Math.cos(a) * 8;
            const py = Math.sin(a) * 8;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
        // Inner detail
        ctx.fillStyle = '#ff4444';
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const a = (i / 6) * Math.PI * 2;
            const px = Math.cos(a) * 4;
            const py = Math.sin(a) * 4;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();

    } else if (m.type === 'MIRV') {
        // Body
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.moveTo(5, 0);
        ctx.lineTo(-4, -3);
        ctx.lineTo(-4, 3);
        ctx.closePath();
        ctx.fill();
        // 3 warhead circles at nose
        ctx.fillStyle = '#ffcc00';
        const wobble = Math.sin(frameCount * 0.2) * 0.3;
        ctx.beginPath();
        ctx.arc(6, wobble - 2, 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(6, wobble + 2, 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(7, wobble, 1.5, 0, Math.PI * 2);
        ctx.fill();

    } else {
        // Fallback
        ctx.fillStyle = m.color;
        const s = m.size || 4;
        ctx.fillRect(-s / 2, -s / 2, s, s);
    }

    ctx.restore();

    // Boss ember particles spawned in update, not draw

    // HP bar
    if (m.hp < m.maxHp || isBoss) {
        const barW = isBoss ? 40 : 16;
        const barOff = isBoss ? 22 : 12;
        drawHPBar(ctx, m.x - barW / 2, m.y - barOff, barW, isBoss ? 4 : 2, m.hp / m.maxHp);
    }
};

const drawPlayerMissile = (ctx, m) => {
    const angle = Math.atan2(m.vy, m.vx);

    if (m.type === 'FLAK') {
        // Bright dot + trailing circles
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.arc(m.x, m.y, 2.5, 0, Math.PI * 2);
        ctx.fill();
        for (let i = 1; i <= 3; i++) {
            ctx.globalAlpha = 0.6 - i * 0.15;
            ctx.beginPath();
            ctx.arc(m.x - m.vx * i * 0.3, m.y - m.vy * i * 0.3, 2 - i * 0.4, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1.0;

    } else if (m.type === 'SAM') {
        // Elongated diamond oriented along velocity
        ctx.save();
        ctx.translate(m.x, m.y);
        ctx.rotate(angle);
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.moveTo(5, 0);
        ctx.lineTo(0, -2);
        ctx.lineTo(-3, 0);
        ctx.lineTo(0, 2);
        ctx.closePath();
        ctx.fill();
        // Orange exhaust
        ctx.fillStyle = '#ff8800';
        ctx.beginPath();
        ctx.arc(-4, 0, 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Occasional smoke particle (faint)
        if (Math.random() < 0.3) {
            ctx.globalAlpha = 0.2;
            ctx.fillStyle = '#888';
            ctx.beginPath();
            ctx.arc(m.x - m.vx * 2 + (Math.random() - 0.5) * 3, m.y - m.vy * 2 + (Math.random() - 0.5) * 3, 1, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }

    } else if (m.type === 'ARTILLERY') {
        // Larger circle with orange-white trail
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(m.x, m.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.arc(m.x, m.y, 2, 0, Math.PI * 2);
        ctx.fill();
        // Trail
        for (let i = 1; i <= 4; i++) {
            ctx.globalAlpha = 0.5 - i * 0.1;
            ctx.fillStyle = i < 2 ? '#ffaa44' : '#ff6600';
            ctx.beginPath();
            ctx.arc(m.x - m.vx * i * 0.25, m.y - m.vy * i * 0.25, 2.5 - i * 0.4, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1.0;

    } else {
        // Default
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.arc(m.x, m.y, 2, 0, Math.PI * 2);
        ctx.fill();
    }
};

const drawLaserBeam = (ctx, l) => {
    const w = l.width || 2;
    const alpha = Math.min(1, l.life / 3);

    // Outer glow
    ctx.save();
    ctx.shadowColor = l.color;
    ctx.shadowBlur = 8;
    ctx.strokeStyle = l.color;
    ctx.lineWidth = w + 2;
    ctx.globalAlpha = alpha * 0.6;
    ctx.beginPath();
    ctx.moveTo(l.x1, l.y1);
    ctx.lineTo(l.x2, l.y2);
    ctx.stroke();
    ctx.restore();

    // Main beam
    ctx.strokeStyle = l.color;
    ctx.lineWidth = w + 1;
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.moveTo(l.x1, l.y1);
    ctx.lineTo(l.x2, l.y2);
    ctx.stroke();

    // Core white
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = Math.max(1, w - 1);
    ctx.beginPath();
    ctx.moveTo(l.x1, l.y1);
    ctx.lineTo(l.x2, l.y2);
    ctx.stroke();

    // Energy crackle - 3 random fork lines
    if (w > 2) {
        ctx.strokeStyle = l.color;
        ctx.lineWidth = 1;
        ctx.globalAlpha = alpha * 0.5;
        const dx = l.x2 - l.x1;
        const dy = l.y2 - l.y1;
        const len = Math.sqrt(dx * dx + dy * dy);
        const nx = -dy / len;
        const ny = dx / len;
        for (let i = 0; i < 3; i++) {
            const t = 0.2 + Math.random() * 0.6;
            const mx = l.x1 + dx * t;
            const my = l.y1 + dy * t;
            const forkLen = (4 + Math.random() * 8) * (Math.random() > 0.5 ? 1 : -1);
            ctx.beginPath();
            ctx.moveTo(mx, my);
            ctx.lineTo(mx + nx * forkLen, my + ny * forkLen);
            ctx.stroke();
        }
    }

    // Impact point glow
    ctx.globalAlpha = alpha * 0.8;
    const impactGrad = ctx.createRadialGradient(l.x2, l.y2, 0, l.x2, l.y2, 6 + w);
    impactGrad.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
    impactGrad.addColorStop(0.5, l.color);
    impactGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = impactGrad;
    ctx.beginPath();
    ctx.arc(l.x2, l.y2, 6 + w, 0, Math.PI * 2);
    ctx.fill();

    ctx.globalAlpha = 1.0;
};

const drawExplosion = (ctx, ex) => {
    if (ex.radius < 1) return;

    // Filled radial gradient
    const pct = ex.growing ? (ex.radius / ex.maxRadius) : (ex.radius / ex.maxRadius);
    const grad = ctx.createRadialGradient(ex.x, ex.y, 0, ex.x, ex.y, ex.radius);

    // Parse color for secondary
    const isWhite = ex.color === '#fff' || ex.color === '#ffffff';
    const primaryColor = ex.color;

    if (ex.growing) {
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.3, primaryColor);
        grad.addColorStop(0.7, isWhite ? 'rgba(255, 200, 100, 0.4)' : primaryColor);
        grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    } else {
        const fadeAlpha = Math.max(0, ex.radius / ex.maxRadius);
        grad.addColorStop(0, primaryColor);
        grad.addColorStop(0.5, `rgba(255, 100, 0, ${fadeAlpha * 0.5})`);
        grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    }

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(ex.x, ex.y, ex.radius, 0, Math.PI * 2);
    ctx.fill();

    // Hot white core during growing
    if (ex.growing && ex.radius > 3) {
        ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * (1 - ex.radius / ex.maxRadius)})`;
        ctx.beginPath();
        ctx.arc(ex.x, ex.y, ex.radius * 0.3, 0, Math.PI * 2);
        ctx.fill();
    }

    // Shockwave ring
    if (ex.shockwaveRadius > 0 && ex.shockwaveRadius < ex.maxRadius * 2.5) {
        ctx.strokeStyle = `rgba(255, 255, 255, ${0.15 * (1 - ex.shockwaveRadius / (ex.maxRadius * 2.5))})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(ex.x, ex.y, ex.shockwaveRadius, 0, Math.PI * 2);
        ctx.stroke();
    }

    // Outline ring
    ctx.strokeStyle = primaryColor;
    ctx.globalAlpha = 0.4;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(ex.x, ex.y, ex.radius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1.0;
};

const drawParticle = (ctx, p) => {
    const lifeRatio = p.life / p.maxLife;
    const alpha = lifeRatio;
    const size = (p.size || 2) * lifeRatio;
    if (size < 0.3) return;

    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;

    // Trail: dim copy at previous position
    if (p.vx !== 0 || p.vy !== 0) {
        ctx.globalAlpha = alpha * 0.3;
        const prevSize = size * 0.7;
        if (p.shape === 'circle') {
            ctx.beginPath();
            ctx.arc(p.x - p.vx, p.y - p.vy, prevSize / 2, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.fillRect(p.x - p.vx - prevSize / 2, p.y - p.vy - prevSize / 2, prevSize, prevSize);
        }
        ctx.globalAlpha = alpha;
    }

    if (p.shape === 'circle') {
        ctx.beginPath();
        ctx.arc(p.x, p.y, size / 2, 0, Math.PI * 2);
        ctx.fill();
    } else {
        ctx.fillRect(p.x - size / 2, p.y - size / 2, size, size);
    }

    ctx.globalAlpha = 1.0;
};

const drawHPBar = (ctx, x, y, w, h, pct) => {
    pct = Math.max(0, Math.min(1, pct));
    // Border
    ctx.fillStyle = '#111';
    ctx.fillRect(x - 1, y - 1, w + 2, h + 2);
    // Background
    ctx.fillStyle = '#330000';
    ctx.fillRect(x, y, w, h);
    // Fill - color shifts green->yellow->red
    let barColor;
    if (pct > 0.6) barColor = '#00ff00';
    else if (pct > 0.3) barColor = '#ffff00';
    else barColor = '#ff0000';
    ctx.fillStyle = barColor;
    ctx.fillRect(x, y, w * pct, h);
};

// ============================================================

const App = () => {
  const canvasRef = useRef(null);
  const requestRef = useRef();

  // Game State
  const [gameState, setGameState] = useState('START');
  const [money, setMoney] = useState(3500);
  const [score, setScore] = useState(0);
  const [level, setLevel] = useState(1);
  const [message, setMessage] = useState('');
  const [bonusReport, setBonusReport] = useState(null);

  // Entities
  const [cities, setCities] = useState([]);
  const turrets = useRef([]);

  // Refs
  const enemyMissiles = useRef([]);
  const bombers = useRef([]);
  const playerMissiles = useRef([]);
  const lasers = useRef([]);
  const explosions = useRef([]);
  const particles = useRef([]);
  const empPulses = useRef([]);
  const terrain = useRef([]);
  const upperTerrain = useRef([]);
  const lowerTerrain = useRef([]);
  const mousePos = useRef({ x: 0, y: 0 });
  const blinkTimer = useRef(0);
  const frameCount = useRef(0);
  const screenShake = useRef(0);
  const mapData = useRef({ stars: [], bgTerrain: [], vegetation: [] });
  const fortifyCount = useRef(0);

  // Placement State
  const [selectedAction, setSelectedAction] = useState(null);
  const [hoveredTurret, setHoveredTurret] = useState(null);

  // Level Config
  const levelConfig = useRef({
    spawnTimer: 0,
    spawnInterval: 100,
    totalToSpawn: 0,
    bomberTimer: 0
  });
  const waveCompleted = useRef(false);

  // --- City Building Generator ---
  const TIER_CONFIG = [
      { buildings: [1, 3], heightScale: 0.6, spread: 15, antennaChance: 0, gradTop: '#009999', gradBot: '#004444', glowColor: [0, 120, 120], glowRadius: 30, glowAlpha: 0.04, styles: ['flat'] },
      { buildings: [4, 8], heightScale: 1.0, spread: 35, antennaChance: 0.2, gradTop: '#00cccc', gradBot: '#005566', glowColor: [0, 180, 180], glowRadius: 60, glowAlpha: 0.08, styles: ['flat', 'pointed'] },
      { buildings: [6, 10], heightScale: 1.3, spread: 40, antennaChance: 0.3, gradTop: '#00eeff', gradBot: '#006677', glowColor: [0, 220, 220], glowRadius: 70, glowAlpha: 0.10, styles: ['flat', 'pointed', 'stepped'] },
      { buildings: [8, 12], heightScale: 1.6, spread: 45, antennaChance: 0.4, gradTop: '#aaddff', gradBot: '#2255aa', glowColor: [100, 180, 255], glowRadius: 80, glowAlpha: 0.12, styles: ['flat', 'pointed', 'stepped', 'dome'] },
      { buildings: [10, 14], heightScale: 1.9, spread: 50, antennaChance: 0.5, gradTop: '#cc88ff', gradBot: '#3322aa', glowColor: [160, 100, 255], glowRadius: 90, glowAlpha: 0.14, styles: ['pointed', 'stepped', 'dome'] },
      { buildings: [12, 16], heightScale: 2.2, spread: 55, antennaChance: 0.6, gradTop: '#ffdd66', gradBot: '#aa6600', glowColor: [255, 200, 80], glowRadius: 100, glowAlpha: 0.16, styles: ['pointed', 'stepped', 'dome'] },
  ];

  const generateCityBuildings = (tier) => {
      const cfg = TIER_CONFIG[Math.min(tier, 5)];
      const buildings = [];
      const count = cfg.buildings[0] + Math.floor(Math.random() * (cfg.buildings[1] - cfg.buildings[0]));
      for (let b = 0; b < count; b++) {
          const bw = (6 + Math.random() * 12) * cfg.heightScale;
          const bh = (15 + Math.random() * 25) * cfg.heightScale;
          const style = cfg.styles[Math.floor(Math.random() * cfg.styles.length)];
          const windows = [];
          const cols = Math.max(1, Math.floor(bw / 4));
          const rows = Math.max(1, Math.floor(bh / 6));
          for (let wy = 0; wy < rows; wy++) {
              for (let wx = 0; wx < cols; wx++) {
                  windows.push({
                      ox: 2 + wx * (bw / cols),
                      oy: 3 + wy * (bh / rows),
                      phase: Math.floor(Math.random() * 10)
                  });
              }
          }
          buildings.push({
              w: bw,
              h: bh,
              xOffset: (Math.random() - 0.5) * cfg.spread,
              style,
              windows,
              hasAntenna: bh > 20 && Math.random() < cfg.antennaChance,
              damage: 0
          });
      }
      return buildings;
  };

  // --- Map Generation ---
  const generateMap = useCallback((numCities) => {
    const segments = 80;
    const segmentWidth = GAME_WIDTH / segments;

    // === Upper terrain (turret zone): gentle rolling hills with plateaus ===
    const upperPoints = [];
    for (let i = 0; i <= segments; i++) {
        const x = i * segmentWidth;
        const base = 460;
        const y = base - Math.sin(i * 0.15) * 50 - Math.cos(i * 0.08) * 35 + (Math.random() - 0.5) * 12;
        upperPoints.push({ x, y: Math.max(340, Math.min(520, y)) });
    }
    // Post-process: create plateaus by flattening local minima (highest elevation = lowest y)
    for (let i = 2; i < upperPoints.length - 2; i++) {
        if (upperPoints[i].y < upperPoints[i - 1].y && upperPoints[i].y < upperPoints[i + 1].y) {
            const flatY = upperPoints[i].y;
            upperPoints[i - 1].y = flatY;
            upperPoints[i + 1].y = flatY;
        }
    }
    // Additional plateaus every ~150-200px for turret placement
    for (let x = 100; x < GAME_WIDTH - 100; x += 150 + Math.random() * 50) {
        const idx = Math.round(x / segmentWidth);
        if (idx > 1 && idx < upperPoints.length - 2) {
            const flatY = Math.min(upperPoints[idx - 1].y, upperPoints[idx].y, upperPoints[idx + 1].y);
            for (let d = -1; d <= 1; d++) {
                upperPoints[idx + d].y = flatY;
            }
        }
    }

    // === Lower terrain (city zone): very flat ground plane ===
    const lowerPoints = [];
    const citySlots = [];
    // Place cities at 1/3 and 2/3 (or evenly spaced for other counts)
    for (let i = 0; i < numCities; i++) {
        const cx = GAME_WIDTH * ((i + 1) / (numCities + 1));
        citySlots.push({ x: cx, w: 40 });
    }
    for (let i = 0; i <= segments; i++) {
        const x = i * segmentWidth;
        // Very flat terrain with minimal undulation
        const undulation = Math.sin(i * 0.12) * 2 + (Math.random() - 0.5) * 1;
        const y = LOWER_TERRAIN_Y + undulation;
        lowerPoints.push({ x, y: Math.max(LOWER_TERRAIN_Y - 5, Math.min(LOWER_TERRAIN_Y + 5, y)) });
    }

    // Store both terrain arrays
    upperTerrain.current = upperPoints;
    lowerTerrain.current = lowerPoints;
    terrain.current = upperPoints; // backward compat for player missiles

    // Generate stars
    const stars = [];
    for (let i = 0; i < 100; i++) {
        stars.push({
            x: Math.random() * GAME_WIDTH,
            y: Math.random() * (GAME_HEIGHT * 0.6),
            brightness: 0.3 + Math.random() * 0.7,
            twinklePhase: Math.random() * Math.PI * 2,
            size: Math.random() > 0.7 ? 2 : 1,
            color: Math.random() > 0.8 ? '#aaccff' : '#ffffff'
        });
    }

    // Background mountains (behind upper terrain)
    const bgTerrain = [];
    for (let i = 0; i <= segments; i++) {
        const x = i * segmentWidth;
        const noise = Math.random() * 15;
        const bgY = 280 + Math.sin(i * 0.12 + 1) * 40 + Math.cos(i * 0.06 + 2) * 30 + noise;
        bgTerrain.push({ x, y: bgY });
    }

    // Vegetation on upper terrain gentle slopes
    const vegetation = [];
    for (let i = 0; i < upperPoints.length - 1; i++) {
        const p1 = upperPoints[i];
        const p2 = upperPoints[i + 1];
        const slope = Math.abs(p2.y - p1.y) / (p2.x - p1.x || 1);
        if (slope < 0.3) {
            const count = Math.floor(Math.random() * 3);
            for (let v = 0; v < count; v++) {
                const vx = p1.x + (p2.x - p1.x) * Math.random();
                const vy = p1.y + (p2.y - p1.y) * Math.random();
                vegetation.push({
                    x: vx, y: vy,
                    h: 2 + Math.random() * 4,
                    color: ['#004400', '#006600', '#003300', '#005500'][Math.floor(Math.random() * 4)]
                });
            }
        }
    }

    mapData.current = { stars, bgTerrain, vegetation };

    // Cities on lower terrain — start small (tier 1, reduced building count)
    const newCities = citySlots.map(slot => {
        const cy = getTerrainHeight(slot.x, lowerPoints);
        const buildings = generateCityBuildings(1);
        // Start with fewer buildings (reduce by ~40%)
        const reduced = buildings.slice(0, Math.max(2, Math.ceil(buildings.length * 0.6)));
        return { x: slot.x, y: cy, active: true, hp: 3, maxHp: 3, tier: 1, wavesSurvived: 0, growthLevel: 0, buildings: reduced };
    });
    setCities(newCities);
    return upperPoints;
  }, []);

  const getTerrainHeight = (x, terrainPoints) => {
      if (!terrainPoints || terrainPoints.length === 0) return GAME_HEIGHT;
      if (typeof x !== 'number' || isNaN(x)) return GAME_HEIGHT;
      const segmentWidth = GAME_WIDTH / (terrainPoints.length - 1);
      const index = Math.floor(x / segmentWidth);
      if (index < 0 || index >= terrainPoints.length - 1) return GAME_HEIGHT;
      const p1 = terrainPoints[index];
      const p2 = terrainPoints[index+1];
      if (!p1 || !p2) return GAME_HEIGHT;
      const ratio = (x - p1.x) / (p2.x - p1.x);
      return p1.y + (p2.y - p1.y) * ratio;
  };

  const getCityTerrainHeight = (x) => {
      return getTerrainHeight(x, lowerTerrain.current);
  };

  // --- Save / Load ---
  const SAVE_KEY = 'vectorDefenseSave';

  const saveGame = (lvl, m, s, c) => {
      try {
          const data = {
              level: lvl,
              money: m,
              score: s,
              cities: c,
              turrets: turrets.current.map(t => {
                  const { icon, ...savedStats } = t.stats;
                  return { id: t.id, x: t.x, y: t.y, type: t.type,
                      stats: savedStats, level: t.level, angle: t.angle };
              }),
              upperTerrain: upperTerrain.current,
              lowerTerrain: lowerTerrain.current,
              mapData: mapData.current,
              fortifyCount: fortifyCount.current
          };
          localStorage.setItem(SAVE_KEY, JSON.stringify(data));
      } catch (e) { /* storage full or unavailable */ }
  };

  const loadGame = () => {
      try {
          const raw = localStorage.getItem(SAVE_KEY);
          return raw ? JSON.parse(raw) : null;
      } catch (e) { return null; }
  };

  const clearSave = () => {
      try { localStorage.removeItem(SAVE_KEY); } catch (e) {}
  };

  const hasSave = () => {
      try { return !!localStorage.getItem(SAVE_KEY); } catch (e) { return false; }
  };

  const resumeGame = useCallback(() => {
      const save = loadGame();
      if (!save) return;
      initAudio();
      setLevel(save.level);
      setMoney(save.money);
      setScore(save.score);
      setCities(save.cities);
      turrets.current = save.turrets.map(t => ({
          ...t,
          stats: { ...TURRET_TYPES[t.type], ...t.stats },
          lastFired: 0, recoilOffset: 0, muzzleFlashTimer: 0
      }));
      upperTerrain.current = save.upperTerrain;
      lowerTerrain.current = save.lowerTerrain;
      terrain.current = save.upperTerrain;
      mapData.current = save.mapData;
      fortifyCount.current = save.fortifyCount || 0;
      resetEntities();
      setupLevel(save.level);
      setGameState('PLACEMENT');
      setMessage(`SYSTEMS RESTORED. WAVE ${save.level} STANDING BY.`);
  }, []);

  // --- Initialization ---
  const initGame = useCallback(() => {
    initAudio();
    clearSave();
    setMoney(3500);
    setScore(0);
    setLevel(1);
    setGameState('PLACEMENT');
    setMessage('Commander, hostile forces inbound.');
    turrets.current = [];
    fortifyCount.current = 0;
    resetEntities();
    generateMap(2);
    setupLevel(1);
  }, [generateMap]);

  const setupLevel = (lvl) => {
    levelConfig.current = {
        spawnTimer: 0,
        spawnInterval: Math.max(15, 90 - (lvl * 3)),
        totalToSpawn: 12 + (lvl * 4),
        bomberTimer: 0,
        isBossWave: lvl % 5 === 0 && lvl > 0,
        isMegaBossWave: lvl % 10 === 0 && lvl > 0
    };
  };

  const resetEntities = () => {
    enemyMissiles.current = [];
    bombers.current = [];
    playerMissiles.current = [];
    lasers.current = [];
    explosions.current = [];
    particles.current = [];
    empPulses.current = [];
  };

  const startWave = () => {
      const cfg = levelConfig.current;
      if (turrets.current.length === 0) {
          setMessage("WARNING: NO DEFENSES PLACED");
          setTimeout(() => setMessage(`WAVE ${level} INBOUND`), 2000);
      } else if (cfg.isMegaBossWave) {
          setMessage(`ALERT: MEGA BOSS INBOUND`);
          Sound.bossWarning();
      } else if (cfg.isBossWave) {
          setMessage(`WARNING: BOSS INBOUND`);
          Sound.bossWarning();
      } else {
          setMessage(`WAVE ${level} ENGAGING`);
          Sound.waveStart();
      }
      // Spawn boss ship on boss waves
      if (cfg.isMegaBossWave) {
          spawnBossShip(2);
      } else if (cfg.isBossWave) {
          spawnBossShip(1);
      }
      waveCompleted.current = false;
      setGameState('PLAYING');
      setSelectedAction(null);
  };

  // --- Game Loop ---
  const update = useCallback(() => {
    frameCount.current++;

    if (gameState === 'PLAYING') {
        const cfg = levelConfig.current;
        cfg.spawnTimer++;
        cfg.bomberTimer++;

        // Spawn Logic
        if (cfg.totalToSpawn > 0 && cfg.spawnTimer > cfg.spawnInterval) {
            spawnEnemyMissile();
            cfg.spawnTimer = 0;
            cfg.totalToSpawn--;
        }

        if (level >= 3 && cfg.bomberTimer > 500 && Math.random() < 0.25) {
            spawnBomber();
            cfg.bomberTimer = 0;
        }

        // Turret Logic
        turrets.current.forEach(turret => {
            turret.lastFired++;

            // EMP disable countdown
            if (turret.empDisabled > 0) {
                turret.empDisabled--;
                // Still decay recoil/flash while disabled
                if (turret.recoilOffset > 0) turret.recoilOffset *= 0.7;
                if (turret.recoilOffset < 0.1) turret.recoilOffset = 0;
                if (turret.muzzleFlashTimer > 0) turret.muzzleFlashTimer--;
                return; // Skip targeting/firing
            }

            // Decay recoil
            if (turret.recoilOffset > 0) turret.recoilOffset *= 0.7;
            if (turret.recoilOffset < 0.1) turret.recoilOffset = 0;

            // Decay FLAK heat
            if (turret.type === 'FLAK' && turret.heat > 0) {
                turret.heat = Math.max(0, turret.heat - 0.3);
            }

            // Decay muzzle flash
            if (turret.muzzleFlashTimer > 0) turret.muzzleFlashTimer--;

            let target = null;
            let minDist = turret.stats.range;

            const allTargets = [...bombers.current, ...enemyMissiles.current];

            // Laser turrets prefer their current target for beam continuity
            if (turret.type === 'LASER' && turret.laserTarget) {
                const cur = allTargets.find(m => m.id === turret.laserTarget);
                if (cur && cur.active && distance(turret.x, turret.y, cur.x, cur.y) < turret.stats.range) {
                    target = cur;
                }
            }

            if (!target) {
                allTargets.forEach(m => {
                    if (!m.active) return;
                    let d = distance(turret.x, turret.y, m.x, m.y);
                    if (d < minDist) {
                        minDist = d;
                        target = m;
                    }
                });
            }

            // Track target angle
            if (target) {
                const targetAngle = Math.atan2(target.y - turret.y, target.x - turret.x) - Math.PI / 2;
                const angleDiff = targetAngle - (turret.angle || -Math.PI / 2);
                turret.angle = (turret.angle || -Math.PI / 2) + angleDiff * 0.15;
            }

            if (turret.type === 'LASER') {
                // Heat mechanic: 1s firing = overheat, 3s cooldown
                if (turret.laserOverheat) {
                    turret.laserHeat = Math.max(0, (turret.laserHeat || 0) - (1 / 3)); // 180 frames to fully cool
                    if (turret.laserHeat <= 0) {
                        turret.laserOverheat = false;
                        turret.laserHeat = 0;
                    }
                    turret.laserTarget = null;
                    turret.dwellTime = 0;
                } else if (target) {
                    if (turret.laserTarget === target.id) {
                        turret.dwellTime = (turret.dwellTime || 0) + 1;
                    } else {
                        turret.laserTarget = target.id;
                        turret.dwellTime = 0;
                    }
                    if (turret.lastFired >= turret.stats.fireRate) {
                        fireTurret(turret, target);
                        turret.lastFired = 0;
                        turret.laserHeat = (turret.laserHeat || 0) + (1 / 60) * turret.stats.fireRate; // 60 frames of firing = 1.0
                        if (turret.laserHeat >= 1) {
                            turret.laserOverheat = true;
                            turret.laserHeat = 1;
                        }
                    }
                } else {
                    turret.laserTarget = null;
                    turret.dwellTime = 0;
                    // Cool down slowly when idle (same rate as overheat recovery)
                    if (turret.laserHeat > 0) {
                        turret.laserHeat = Math.max(0, turret.laserHeat - (1 / 3) / 60);
                    }
                }
            } else if (target && turret.lastFired >= turret.stats.fireRate) {
                fireTurret(turret, target);
                turret.lastFired = 0;
            }
        });

        updateEnemyMissiles();
        updateBombers();
        updatePlayerMissiles();
        updateLasers();
        updateExplosions();
        updateParticles();

        // Update EMP pulses
        empPulses.current.forEach(p => {
            p.radius += p.maxRadius / 60; // constant expansion rate
            p.life--;
        });
        empPulses.current = empPulses.current.filter(p => p.life > 0);

        // Decay screen shake
        if (screenShake.current > 0) screenShake.current *= 0.85;
        if (screenShake.current < 0.2) screenShake.current = 0;

        if (!waveCompleted.current && cfg.totalToSpawn === 0 && enemyMissiles.current.length === 0 && bombers.current.length === 0 && explosions.current.length === 0) {
            waveCompleted.current = true;
            handleWaveComplete();
        }

        if (cities.filter(c => c.active).length === 0) {
            setGameState('GAME_OVER');
            clearSave();
            Sound.gameOver();
        }
    } else {
        updateParticles();
        updateExplosions();
        blinkTimer.current++;
        frameCount.current++;
    }
  }, [gameState, cities, level]);

  const handleWaveComplete = () => {
      const levelMult = 1 + (level - 1) * 0.15;
      const baseBonus = Math.round(WAVE_COMPLETE_BONUS * levelMult);
      const cityBonus = cities.filter(c => c.active).length * Math.round(500 * levelMult);
      const totalBonus = baseBonus + cityBonus;

      let repairedCount = 0;
      let growingCount = 0;
      const updatedCities = cities.map(c => {
          if (!c.active) return c;
          const ws = (c.wavesSurvived || 0) + 1;
          const tier = c.tier != null ? c.tier : 1;
          const maxHp = c.maxHp || 3;

          if (c.hp < maxHp) {
              // Damaged city: heal HP and repair buildings
              repairedCount++;
              const healAmount = Math.ceil(maxHp * 0.20) + Math.ceil(maxHp * 0.03 * tier);
              const newHp = Math.min(c.hp + healAmount, maxHp);
              const repairRate = 0.15 + 0.03 * tier;
              const repairedBuildings = c.buildings.map(b => ({
                  ...b,
                  damage: Math.max(0, (b.damage || 0) - repairRate)
              }));
              createParticles(c.x, c.y, '#00ff88', 6);
              return { ...c, wavesSurvived: ws, hp: newHp, buildings: repairedBuildings };
          } else {
              // Undamaged city: organic growth
              growingCount++;
              const gl = (c.growthLevel || 0) + 1;
              const cfg = TIER_CONFIG[Math.min(tier, 5)];
              const isMetropolis = c.buildings.length > 15 || gl > 15;

              // Building growth: strong horizontal sprawl, slower vertical
              const driftRate = 1.5 + tier * 0.4 + gl * 0.15;
              const grownBuildings = c.buildings.map(b => {
                  const tall = isMetropolis && b.h > 30;
                  return {
                      ...b,
                      h: b.h * (tall ? 1.04 : 1.015),
                      w: b.w * 1.03,
                      xOffset: isMetropolis
                          ? b.xOffset * 0.999 // slight densification
                          : b.xOffset + (b.xOffset > 0 ? driftRate : -driftRate)
                  };
              });

              // Every wave: spawn 1-3 suburban buildings at city edges
              if (!isMetropolis) {
                  const suburbCount = 1 + (gl >= 5 ? 1 : 0) + (gl >= 12 ? 1 : 0);
                  const currentMaxOffset = Math.max(...grownBuildings.map(b => Math.abs(b.xOffset)), cfg.spread);
                  for (let s = 0; s < suburbCount; s++) {
                      const side = Math.random() > 0.5 ? 1 : -1;
                      const subOffset = side * (currentMaxOffset + 5 + Math.random() * 10);
                      const bw = 4 + Math.random() * 6;
                      const bh = 8 + Math.random() * 12;
                      const windows = [];
                      const cols = Math.max(1, Math.floor(bw / 4));
                      const rows = Math.max(1, Math.floor(bh / 6));
                      for (let wy = 0; wy < rows; wy++) {
                          for (let wx = 0; wx < cols; wx++) {
                              windows.push({ ox: 2 + wx * (bw / cols), oy: 3 + wy * (bh / rows), phase: Math.floor(Math.random() * 10) });
                          }
                      }
                      grownBuildings.push({
                          w: bw, h: bh,
                          xOffset: subOffset,
                          style: 'flat', windows,
                          hasAntenna: false,
                          damage: 0
                      });
                  }
              }

              // Every 5 growth levels: add a core building
              if (gl % 5 === 0) {
                  const bw = (6 + Math.random() * 12) * cfg.heightScale;
                  const bh = (15 + Math.random() * 25) * cfg.heightScale;
                  const style = cfg.styles[Math.floor(Math.random() * cfg.styles.length)];
                  const windows = [];
                  const cols = Math.max(1, Math.floor(bw / 4));
                  const rows = Math.max(1, Math.floor(bh / 6));
                  for (let wy = 0; wy < rows; wy++) {
                      for (let wx = 0; wx < cols; wx++) {
                          windows.push({ ox: 2 + wx * (bw / cols), oy: 3 + wy * (bh / rows), phase: Math.floor(Math.random() * 10) });
                      }
                  }
                  grownBuildings.push({
                      w: bw, h: bh,
                      xOffset: (Math.random() - 0.5) * (cfg.spread + gl * 3),
                      style, windows,
                      hasAntenna: bh > 20 && Math.random() < cfg.antennaChance,
                      damage: 0
                  });
              }

              // Upgrade flat buildings to futuristic styles
              const upgradeChance = isMetropolis ? 0.30 : 0.15;
              if (Math.random() < upgradeChance) {
                  const flatIdx = grownBuildings.findIndex(b => b.style === 'flat');
                  if (flatIdx >= 0) {
                      const newStyle = isMetropolis
                          ? ['pointed', 'stepped', 'dome'][Math.floor(Math.random() * 3)]
                          : (Math.random() > 0.5 ? 'stepped' : 'dome');
                      grownBuildings[flatIdx] = {
                          ...grownBuildings[flatIdx],
                          style: newStyle,
                          hasAntenna: isMetropolis ? Math.random() < 0.5 : grownBuildings[flatIdx].hasAntenna
                      };
                  }
              }

              // Village promotion: after 4 waves undamaged, promote to tier 1 town
              if (c.isVillage && ws >= 4) {
                  createParticles(c.x, c.y, '#00ffcc', 6);
                  return { ...c, wavesSurvived: ws, growthLevel: gl, buildings: grownBuildings,
                      tier: 1, maxHp: 2, hp: 2, isVillage: false };
              }

              createParticles(c.x, c.y, '#00ffcc', 4);
              return { ...c, wavesSurvived: ws, growthLevel: gl, buildings: grownBuildings };
          }
      });
      // Spawn villages in gaps between cities
      const withVillages = spawnVillages(updatedCities, level);
      // Check for city merges after growth
      const mergedCities = checkCityMerges(withVillages);
      setCities(mergedCities);

      const villageCount = mergedCities.filter(c => c.active && c.isVillage).length;
      setBonusReport({
          wave: level,
          base: baseBonus,
          cityCount: cities.filter(c => c.active).length,
          cityBonus: cityBonus,
          total: totalBonus,
          repairedCount,
          growingCount,
          villageCount
      });

      setMoney(prev => prev + totalBonus);
      saveGame(level, money + totalBonus, score, mergedCities);
      setGameState('LEVEL_COMPLETE');
  };

  const spawnVillages = (cityList, currentLevel) => {
      const active = cityList.filter(c => c.active);
      const destroyed = cityList.filter(c => !c.active);
      const result = [...cityList];

      const addVillage = (midX) => {
          const tooClose = result.filter(c => c.active).some(c => Math.abs(c.x - midX) < 40);
          if (tooClose) return;
          const vy = getCityTerrainHeight(midX);
          const villageBuildings = generateCityBuildings(0);
          const reduced = villageBuildings.slice(0, Math.max(1, Math.ceil(villageBuildings.length * 0.5)));
          result.push({
              x: midX, y: vy, active: true,
              hp: 1, maxHp: 1,
              tier: 0, wavesSurvived: 0, growthLevel: 0,
              buildings: reduced,
              isVillage: true
          });
          createParticles(midX, vy, '#88dddd', 4);
      };

      // Spawn near destroyed cities (high probability - resettlement)
      destroyed.forEach(d => {
          if (Math.random() < 0.7) {
              const offset = (Math.random() - 0.5) * 60;
              addVillage(Math.max(30, Math.min(GAME_WIDTH - 30, d.x + offset)));
          }
      });

      // Spawn in gaps between active cities (starts wave 2)
      if (active.length >= 1 && currentLevel >= 2) {
          // Also consider edges of the map as spawn zones
          const sorted = [...active].sort((a, b) => a.x - b.x);
          const positions = [];

          // Left edge gap
          if (sorted[0].x > 100) {
              positions.push({ left: 30, right: sorted[0].x });
          }
          // Gaps between cities
          for (let i = 0; i < sorted.length - 1; i++) {
              positions.push({ left: sorted[i].x, right: sorted[i + 1].x });
          }
          // Right edge gap
          if (sorted[sorted.length - 1].x < GAME_WIDTH - 100) {
              positions.push({ left: sorted[sorted.length - 1].x, right: GAME_WIDTH - 30 });
          }

          positions.forEach(({ left, right }) => {
              const gap = right - left;
              if (gap < 60) return;

              // Spawn chance scales with gap size and wave - much more aggressive
              const spawnChance = Math.min(0.8, 0.25 + (gap / 300) + (currentLevel - 1) * 0.05);
              if (Math.random() > spawnChance) return;

              const midX = left + gap * (0.3 + Math.random() * 0.4);
              addVillage(Math.max(30, Math.min(GAME_WIDTH - 30, midX)));

              // Large gaps can spawn multiple villages
              if (gap > 200 && Math.random() < 0.5) {
                  const midX2 = left + gap * (Math.random() > 0.5 ? 0.2 : 0.8);
                  addVillage(Math.max(30, Math.min(GAME_WIDTH - 30, midX2)));
              }
          });
      }

      return result;
  };

  const checkCityMerges = (cityList) => {
      const result = [...cityList];
      let merged = true;
      while (merged) {
          merged = false;
          const active = result.filter(c => c.active);
          for (let i = 0; i < active.length && !merged; i++) {
              for (let j = i + 1; j < active.length && !merged; j++) {
                  const a = active[i];
                  const b = active[j];
                  if (!a.active || !b.active) continue;
                  const tierA = a.tier != null ? a.tier : 1;
                  const tierB = b.tier != null ? b.tier : 1;
                  const cfgA = TIER_CONFIG[Math.min(tierA, 5)];
                  const cfgB = TIER_CONFIG[Math.min(tierB, 5)];
                  const spreadA = cfgA.spread + (a.growthLevel || 0) * 2.5;
                  const spreadB = cfgB.spread + (b.growthLevel || 0) * 2.5;
                  const gap = Math.abs(a.x - b.x) - spreadA - spreadB;
                  if (gap < 35) {
                      const midX = (a.x + b.x) / 2;
                      const midY = getCityTerrainHeight(midX);
                      const offsetA = a.x - midX;
                      const offsetB = b.x - midX;
                      const combinedBuildings = [
                          ...a.buildings.map(bl => ({ ...bl, xOffset: bl.xOffset + offsetA })),
                          ...b.buildings.map(bl => ({ ...bl, xOffset: bl.xOffset + offsetB }))
                      ];
                      // Infill buildings to connect the gap
                      const infillCount = 2 + Math.floor(Math.random() * 3);
                      for (let f = 0; f < infillCount; f++) {
                          const t = (f + 0.5) / infillCount;
                          const fx = offsetA + (offsetB - offsetA) * t;
                          const bw = 5 + Math.random() * 8;
                          const bh = 10 + Math.random() * 15;
                          const windows = [];
                          const cols = Math.max(1, Math.floor(bw / 4));
                          const rows = Math.max(1, Math.floor(bh / 6));
                          for (let wy = 0; wy < rows; wy++) {
                              for (let wx = 0; wx < cols; wx++) {
                                  windows.push({ ox: 2 + wx * (bw / cols), oy: 3 + wy * (bh / rows), phase: Math.floor(Math.random() * 10) });
                              }
                          }
                          combinedBuildings.push({
                              w: bw, h: bh, xOffset: fx,
                              style: 'flat', windows,
                              hasAntenna: false, damage: 0
                          });
                      }
                      // Tier boost when merging same-tier cities
                      const mergedTier = (tierA === tierB && tierA < 5)
                          ? tierA + 1
                          : Math.max(tierA, tierB);
                      const idxA = result.indexOf(a);
                      const idxB = result.indexOf(b);
                      result[idxA] = {
                          ...a,
                          x: midX,
                          y: midY,
                          hp: a.hp + b.hp,
                          maxHp: a.maxHp + b.maxHp,
                          tier: mergedTier,
                          growthLevel: Math.max(a.growthLevel || 0, b.growthLevel || 0),
                          buildings: combinedBuildings,
                          isVillage: false
                      };
                      result[idxB] = { ...b, active: false };
                      createParticles(midX, midY, '#ffff00', 12);
                      merged = true; // restart to check for cascade merges
                  }
              }
          }
      }
      return result;
  };

  const advanceLevel = () => {
      const nextLvl = level + 1;
      setLevel(nextLvl);
      resetEntities();
      setupLevel(nextLvl);
      saveGame(nextLvl, money, score, cities);
      setGameState('PLACEMENT');
      setMessage('PREPARE DEFENSES. HOSTILES INBOUND.');
  };

  // --- Logic Helpers ---
  const applyDamage = (enemy, damage) => {
      if (!enemy.active || enemy.hp <= 0) return;
      // Boss shield absorbs damage first
      if (enemy.shieldActive && enemy.shield > 0) {
          const absorbed = Math.min(damage, enemy.shield);
          enemy.shield -= absorbed;
          damage -= absorbed;
          if (damage <= 0) {
              createParticles(enemy.x, enemy.y, '#00ffff', 2);
              return;
          }
      }
      enemy.hp -= damage;
      if (enemy.hp <= 0) {
          enemy.active = false;
          const levelMult = 1 + (level - 1) * 0.15;
          let reward = Math.round(50 * levelMult);
          let scoreReward = Math.round(100 * levelMult);
          if (enemy.type === 'BOSS_SHIP') {
              const isMega = enemy.bossTier >= 2;
              reward = Math.round((isMega ? 3000 : 1500) * levelMult);
              scoreReward = Math.round((isMega ? 10000 : 5000) * levelMult);
          }
          else if (enemy.type === 'BOSS') { reward = Math.round(800 * levelMult); scoreReward = Math.round(2000 * levelMult); }
          if (enemy.type === 'ARMORED') { reward = Math.round(100 * levelMult); scoreReward = Math.round(300 * levelMult); }

          setMoney(m => m + reward);
          setScore(s => s + scoreReward);

          const deathRadius = enemy.type === 'BOSS_SHIP' ? (enemy.bossTier >= 2 ? 150 : 100) : (enemy.type === 'BOSS' ? 80 : 30);
          createExplosion(enemy.x, enemy.y, true, deathRadius);
          createParticles(enemy.x, enemy.y, enemy.color);
      } else {
          if (frameCount.current - lastEnemyHitFrame >= 5) {
              Sound.enemyHit();
              lastEnemyHitFrame = frameCount.current;
          }
          createParticles(enemy.x, enemy.y, '#fff', 2);
      }
  };

  const fireTurret = (turret, target) => {
      if (turret.type === 'LASER') {
          const dist = distance(turret.x, turret.y, target.x, target.y);
          const distFalloff = Math.max(0.2, 1 - (dist / turret.stats.range) * 0.8);
          const dwellBonus = 1 + Math.min((turret.dwellTime || 0) / 30, 5);
          const finalDamage = turret.stats.damage * distFalloff * dwellBonus;
          const beamWidth = Math.min(1 + (turret.dwellTime || 0) / 15, 6);
          lasers.current.push({
              x1: turret.x, y1: turret.y,
              x2: target.x, y2: target.y,
              color: turret.stats.projectileColor,
              life: turret.stats.fireRate,
              width: beamWidth
          });
          if ((turret.dwellTime || 0) > 10) {
              createParticles(target.x, target.y, '#ff00ff', 1);
          }
          Sound.laserBeam(turret.dwellTime);
          applyDamage(target, finalDamage);
          return;
      }

      // Trigger recoil and muzzle flash
      turret.recoilOffset = turret.type === 'ARTILLERY' ? 6 : 4;
      turret.muzzleFlashTimer = turret.type === 'ARTILLERY' ? 8 : 5;
      Sound.turretFire(turret.type);

      if (turret.type === 'SAM') {
           playerMissiles.current.push({
              x: turret.x,
              y: turret.y,
              vx: 0,
              vy: -SAM_SPEED,
              targetId: target.id,
              active: true,
              type: 'SAM',
              color: turret.stats.projectileColor,
              damage: turret.stats.damage,
              explosionRadius: turret.stats.explosionRadius
          });
          return;
      }

      const dist = distance(turret.x, turret.y, target.x, target.y);
      const timeToHit = dist / PLAYER_PROJECTILE_SPEED;
      const predX = target.x + (target.vx * timeToHit);
      const predY = target.y + (target.vy * timeToHit);
      let angle = Math.atan2(predY - turret.y, predX - turret.x);

      // FLAK: inaccuracy that worsens with heat
      if (turret.type === 'FLAK') {
          const heat = turret.heat || 0;
          const spread = 0.12 + heat * 0.006;
          angle += (Math.random() - 0.5) * spread;
          turret.heat = Math.min((turret.heat || 0) + 2, 30);
      }

      playerMissiles.current.push({
          x: turret.x,
          y: turret.y,
          vx: Math.cos(angle) * PLAYER_PROJECTILE_SPEED,
          vy: Math.sin(angle) * PLAYER_PROJECTILE_SPEED,
          targetX: predX,
          targetY: predY,
          active: true,
          type: turret.type,
          color: turret.stats.projectileColor,
          damage: turret.stats.damage,
          explosionRadius: turret.stats.explosionRadius
      });
  };

  const spawnEnemyMissile = (originX = null, originY = null, isBomblet = false) => {
    const startX = originX ?? Math.random() * GAME_WIDTH;
    const startY = originY ?? 0;

    const validCities = cities.filter(c => c.active);
    if (validCities.length === 0) return;
    const targetCity = validCities[Math.floor(Math.random() * validCities.length)];

    const angle = Math.atan2(targetCity.y - startY, targetCity.x - startX);

    let type = 'NORMAL';
    let speed = 0.8 + (level * 0.08);
    let color = '#ff0000';
    let maxHp = HP_NORMAL;
    let size = 4;
    let canSplit = false;

    if (!isBomblet) {
        const rand = Math.random();

        if (level >= 5 && rand < 0.05) {
            type = 'BOSS';
            speed = 0.4;
            maxHp = HP_BOSS_BASE + (level * 50);
            size = 15;
            color = '#ff0000';
        }
        else if (level >= 7 && rand < 0.2) {
            type = 'MIRV'; canSplit = true; color = '#ffaa00'; maxHp = HP_NORMAL * 2;
        }
        else if (level >= 4 && rand < 0.3) {
            type = 'ARMORED';
            speed *= 1.1;
            maxHp = HP_ARMORED;
            size = 6;
            color = '#ffffff';
        }
        else if (level >= 3 && rand < 0.45) {
            type = 'FAST';
            speed = 2.2 + (level * 0.1);
            color = '#bd00ff';
            maxHp = HP_FAST;
        }
    }

    enemyMissiles.current.push({
        id: Math.random().toString(36),
        x: startX,
        y: startY,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        active: true,
        type,
        color,
        maxHp,
        hp: maxHp,
        size,
        canSplit,
        trailHistory: []
    });
  };

  const spawnBomber = () => {
      const fromLeft = Math.random() > 0.5;
      const y = 50 + Math.random() * 80;
      bombers.current.push({
          id: Math.random().toString(36),
          x: fromLeft ? -50 : GAME_WIDTH + 50,
          y: y,
          vx: fromLeft ? 1.2 : -1.2,
          active: true,
          type: 'BOMBER',
          maxHp: 60,
          hp: 60,
          color: '#ffff00',
          size: 10,
          lastDrop: 0,
          dropInterval: 50,
          dropChance: 0.03
      });
  };

  const spawnBossShip = (tier) => {
      const fromLeft = Math.random() > 0.5;
      const y = 40 + Math.random() * 50;
      const isMega = tier >= 2;
      const bossHp = (isMega ? 1500 + level * 100 : 750 + level * 60) * 20;
      bombers.current.push({
          id: Math.random().toString(36),
          x: fromLeft ? -80 : GAME_WIDTH + 80,
          y: y,
          baseSpeed: isMega ? 0.6 : 0.8,
          vx: fromLeft ? (isMega ? 0.6 : 0.8) : (isMega ? -0.6 : -0.8),
          active: true,
          type: 'BOSS_SHIP',
          maxHp: bossHp,
          hp: bossHp,
          color: '#ff4400',
          size: isMega ? 75 : 54,
          lastDrop: 0,
          dropInterval: isMega ? 18 : 25,
          dropChance: isMega ? 0.10 : 0.06,
          isBossShip: true,
          bossTier: tier,
          escortsSpawned: false,
          // Looping & descent
          passCount: 0,
          reentryTimer: 0,
          // Point defense
          pdCooldown: 0,
          pdCharges: isMega ? 4 : 2,
          pdMaxCharges: isMega ? 4 : 2,
          pdRegenTimer: 0,
          pdFlash: 0,
          // EMP
          empCharge: 0,
          empMaxCharge: isMega ? 400 : 600,
          empWindup: 0,
          // Cluster bomb
          clusterTimer: 0,
          clusterWindup: 0,
          // Shield (mega only)
          shield: 0,
          shieldTimer: isMega ? 0 : -1,
          shieldActive: false,
          shieldDuration: 0,
          // Bombing run
          bombRunTimer: 0,
          bombRunning: 0
      });
  };

  const updateBombers = () => {
      bombers.current.forEach(b => {
          if (!b.active) return;

          // --- Boss ship special movement: fly across, exit, reappear lower ---
          if (b.isBossShip) {
              const isMega = b.bossTier >= 2;
              const onScreen = b.x > -80 && b.x < GAME_WIDTH + 80;

              // Reentry delay: boss is off-screen waiting to reappear
              if (b.reentryTimer > 0) {
                  b.reentryTimer--;
                  if (b.reentryTimer <= 0) {
                      // Reappear from the side it exited, heading back
                      b.passCount++;
                      const minAlt = CITY_ZONE_TOP - 50;
                      const descent = isMega ? (10 + Math.random() * 10) : (15 + Math.random() * 10);
                      b.y = Math.min(b.y + descent, minAlt);
                      // Reverse direction: reappear from exit side
                      b.vx = -b.vx;
                      b.x = b.vx > 0 ? -79 : GAME_WIDTH + 79;
                  }
                  return; // skip all logic while off-screen
              }

              // Movement
              const speed = b.bombRunning > 0 ? b.baseSpeed * 3 : b.baseSpeed;
              b.vx = b.vx > 0 ? speed : -speed;
              b.x += b.vx;

              // Check if boss has exited the screen
              if (b.x < -80 || b.x > GAME_WIDTH + 80) {
                  b.reentryTimer = 120; // ~2 second delay before reappearing
                  return;
              }

              // --- Altitude-scaled drop chance: lower = more aggressive ---
              const altRatio = 1 - Math.max(0, Math.min(1, (b.y - 40) / (CITY_ZONE_TOP - 90)));
              // altRatio: 1 at top (y=40), 0 at lowest altitude
              const dropMult = 1 + (1 - altRatio) * 3; // 1x at top, 4x at lowest

              // --- Bombing run ---
              if (b.bombRunning > 0) {
                  b.bombRunning--;
                  if (b.bombRunning % 8 === 0) {
                      spawnEnemyMissile(b.x, b.y, true);
                  }
                  if (b.bombRunning <= 0) {
                      b.bombRunTimer = 0;
                  }
              } else {
                  b.bombRunTimer++;
                  if (b.bombRunTimer >= 600) {
                      b.bombRunning = 90;
                  }
              }

              // --- Normal bomb drops (scaled by altitude) ---
              b.lastDrop++;
              if (b.bombRunning <= 0 && b.lastDrop > (b.dropInterval || 50) && Math.random() < (b.dropChance || 0.03) * dropMult) {
                  spawnEnemyMissile(b.x, b.y, true);
                  b.lastDrop = 0;
              }

              // --- EMP system ---
              if (b.empWindup > 0) {
                  b.empWindup--;
                  if (b.empWindup <= 0) {
                      Sound.empFire();
                      empPulses.current.push({ x: b.x, y: b.y, radius: 0, maxRadius: 450, life: 60 });
                      turrets.current.forEach(t => {
                          const d = distance(b.x, b.y, t.x, t.y);
                          if (d < 150) t.empDisabled = 180;
                          else if (d < 300) t.empDisabled = Math.max(t.empDisabled || 0, 120);
                          else if (d < 450) t.empDisabled = Math.max(t.empDisabled || 0, 60);
                      });
                      b.empCharge = 0;
                  }
              } else {
                  b.empCharge++;
                  if (b.empCharge >= b.empMaxCharge) {
                      b.empWindup = 30;
                  }
              }

              // --- Point Defense (intercept player missiles) ---
              b.pdCooldown = Math.max(0, b.pdCooldown - 1);
              b.pdRegenTimer++;
              if (b.pdRegenTimer >= 120 && b.pdCharges < b.pdMaxCharges) {
                  b.pdCharges++;
                  b.pdRegenTimer = 0;
              }
              if (b.pdFlash > 0) b.pdFlash--;
              if (b.pdCooldown <= 0 && b.pdCharges > 0) {
                  const interceptLimit = isMega ? 2 : 1;
                  let intercepted = 0;
                  for (let pm of playerMissiles.current) {
                      if (!pm.active || intercepted >= interceptLimit) break;
                      if (distance(b.x, b.y, pm.x, pm.y) < 80) {
                          pm.active = false;
                          intercepted++;
                          b.pdCharges--;
                          b.pdFlash = 10;
                          Sound.pointDefense();
                          for (let i = 0; i < 6; i++) {
                              particles.current.push({
                                  x: pm.x, y: pm.y,
                                  vx: (Math.random() - 0.5) * 4,
                                  vy: (Math.random() - 0.5) * 4,
                                  color: '#ff3333',
                                  life: 15 + Math.random() * 10,
                                  maxLife: 25,
                                  size: 1.5 + Math.random() * 2,
                                  shape: 'circle'
                              });
                          }
                      }
                  }
                  if (intercepted > 0) b.pdCooldown = 45;
              }

              // --- Cluster Bomb ---
              b.clusterTimer++;
              if (b.clusterWindup > 0) {
                  b.clusterWindup--;
                  if (b.clusterWindup <= 0) {
                      const count = 5 + Math.floor(Math.random() * 3);
                      const spreadAngle = Math.PI / 6;
                      for (let i = 0; i < count; i++) {
                          const angle = (Math.PI / 2) + (i / (count - 1) - 0.5) * 2 * spreadAngle;
                          const spd = 1.8 + Math.random() * 0.4;
                          enemyMissiles.current.push({
                              id: Math.random().toString(36),
                              x: b.x, y: b.y,
                              vx: Math.cos(angle) * spd,
                              vy: Math.sin(angle) * spd,
                              active: true,
                              type: 'FAST',
                              color: '#ff8800',
                              maxHp: HP_FAST,
                              hp: HP_FAST,
                              size: 4,
                              canSplit: false,
                              trailHistory: []
                          });
                      }
                      b.clusterTimer = 0;
                  }
              } else if (b.clusterTimer >= 400) {
                  b.clusterWindup = 20;
              }

              // --- Shield Regen (mega-boss only) ---
              if (b.shieldTimer >= 0) {
                  if (b.shieldActive) {
                      b.shieldDuration--;
                      if (b.shieldDuration <= 0 || b.shield <= 0) {
                          b.shieldActive = false;
                          b.shield = 0;
                          b.shieldTimer = 0;
                      }
                  } else {
                      b.shieldTimer++;
                      if (b.shieldTimer >= 500) {
                          b.shield = 200;
                          b.shieldActive = true;
                          b.shieldDuration = 300;
                      }
                  }
              }

              // Mega-boss escort spawning
              if (isMega && !b.escortsSpawned && b.x > 200 && b.x < 600) {
                  b.escortsSpawned = true;
                  spawnBomber();
                  spawnBomber();
              }

          } else {
              // Non-boss bomber: original behavior
              b.x += b.vx;
              b.lastDrop++;
              if (b.lastDrop > (b.dropInterval || 50) && Math.random() < (b.dropChance || 0.03)) {
                  spawnEnemyMissile(b.x, b.y, true);
                  b.lastDrop = 0;
              }
              if (b.x < -100 || b.x > GAME_WIDTH + 100) b.active = false;
          }

          // Explosion damage (all bombers)
          for (let ex of explosions.current) {
            if (!b.active) break;
            if (distance(b.x, b.y, ex.x, ex.y) < ex.radius) {
                applyDamage(b, 2);
            }
          }
      });
      bombers.current = bombers.current.filter(b => b.active);
  };

  const updateEnemyMissiles = () => {
    enemyMissiles.current.forEach(m => {
        if (!m.active) return;
        m.x += m.vx;
        m.y += m.vy;

        // Update trail history
        if (m.trailHistory) {
            m.trailHistory.push({ x: m.x, y: m.y });
            if (m.trailHistory.length > 8) m.trailHistory.shift();
        }

        // Boss ember particles
        if (m.type === 'BOSS' && Math.random() < 0.3) {
            const room = 500 - particles.current.length;
            if (room > 0) {
                particles.current.push({
                    x: m.x - m.vx * 5 + (Math.random() - 0.5) * 8,
                    y: m.y - m.vy * 5 + (Math.random() - 0.5) * 8,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    color: Math.random() > 0.5 ? '#ff4400' : '#ff8800',
                    life: 10 + Math.random() * 10,
                    maxLife: 20,
                    size: 1 + Math.random() * 2,
                    shape: Math.random() > 0.5 ? 'circle' : 'square'
                });
            }
        }

        if (m.type === 'MIRV' && m.canSplit && m.y > 150 && Math.random() < 0.02) {
            m.active = false;
            createExplosion(m.x, m.y);
            spawnEnemyMissile(m.x, m.y, true);
            spawnEnemyMissile(m.x, m.y, true);
            spawnEnemyMissile(m.x, m.y, true);
            return;
        }

        const groundY = getTerrainHeight(m.x, lowerTerrain.current);
        if (m.y >= groundY) {
            m.active = false;
            createExplosion(m.x, m.y);
            checkCityDamage(m.x, m.y);
        }

        for (let ex of explosions.current) {
            if (!m.active) break;
            if (distance(m.x, m.y, ex.x, ex.y) < ex.radius) {
                applyDamage(m, 2);
            }
        }
    });
    enemyMissiles.current = enemyMissiles.current.filter(m => m.active);
  };

  const updatePlayerMissiles = () => {
    playerMissiles.current.forEach(m => {
        if (!m.active) return;

        if (m.type === 'SAM' && m.targetId) {
             const target = [...enemyMissiles.current, ...bombers.current].find(e => e.id === m.targetId);
             if (target && target.active) {
                 const angle = Math.atan2(target.y - m.y, target.x - m.x);
                 m.vx = Math.cos(angle) * SAM_SPEED;
                 m.vy = Math.sin(angle) * SAM_SPEED;
             }
        }

        m.x += m.vx;
        m.y += m.vy;

        let detonated = false;

        if (m.type === 'SAM') {
             const target = [...enemyMissiles.current, ...bombers.current].find(e => e.id === m.targetId);
             if (target && target.active && distance(m.x, m.y, target.x, target.y) < 15) {
                 detonated = true;
             }
        }
        else {
            const dist = distance(m.x, m.y, m.targetX, m.targetY);
            if (dist < PLAYER_PROJECTILE_SPEED) {
                detonated = true;
            }
        }

        const groundY = getTerrainHeight(m.x, terrain.current);
        if (m.y > groundY || m.y < 0 || m.x < 0 || m.x > GAME_WIDTH) {
            detonated = true;
        }

        if (detonated) {
            m.active = false;
            createExplosion(m.x, m.y, false, m.explosionRadius, m.color);

            const targets = [...enemyMissiles.current, ...bombers.current];
            targets.forEach(t => {
                if (t.active && distance(m.x, m.y, t.x, t.y) < m.explosionRadius) {
                    applyDamage(t, m.damage);
                }
            });
        }
    });
    playerMissiles.current = playerMissiles.current.filter(m => m.active);
  };

  const updateLasers = () => {
      lasers.current.forEach(l => l.life--);
      lasers.current = lasers.current.filter(l => l.life > 0);
  };

  const checkCityDamage = (x, y) => {
      let changed = false;
      let destroyed = false;
      const newCities = cities.map(c => {
          if (c.active && distance(x, y, c.x, c.y) < 55) {
              const newHp = c.hp - 1;
              createParticles(c.x, c.y, '#f00');
              changed = true;
              // Apply damage to 1-3 random buildings
              const newBuildings = [...c.buildings];
              const hitCount = 1 + Math.floor(Math.random() * 3);
              for (let i = 0; i < hitCount; i++) {
                  const bi = Math.floor(Math.random() * newBuildings.length);
                  const b = { ...newBuildings[bi] };
                  b.damage = Math.min(1.0, (b.damage || 0) + 0.2 + Math.random() * 0.2);
                  newBuildings[bi] = b;
              }
              if (newHp <= 0) {
                  destroyed = true;
                  // All buildings become rubble
                  const rubbleBuildings = newBuildings.map(b => ({ ...b, damage: 1.0 }));
                  return { ...c, hp: 0, active: false, buildings: rubbleBuildings };
              }
              return { ...c, hp: newHp, buildings: newBuildings };
          }
          return c;
      });

      if (changed) {
          setCities(newCities);
          if (destroyed) {
              Sound.cityDestroyed();
              setMoney(m => Math.max(0, m - CITY_REPAIR_PENALTY));
              setMessage('CRITICAL: CITY DESTROYED');
          } else {
              Sound.enemyHit();
              const hit = newCities.find(c => c.active && distance(x, y, c.x, c.y) < 55);
              if (hit) setMessage(`CITY HIT — SHIELDS ${hit.hp}/${hit.maxHp}`);
          }
      }
  };

  const updateExplosions = () => {
    explosions.current.forEach(ex => {
        if (!ex.active) return;
        // Update shockwave
        if (ex.shockwaveRadius !== undefined) {
            ex.shockwaveRadius += 3;
        }
        if (ex.growing) {
            ex.radius += EXPLOSION_GROWTH;
            if (ex.radius >= ex.maxRadius) ex.growing = false;
        } else {
            ex.radius -= EXPLOSION_GROWTH * 0.5;
            if (ex.radius <= 0) ex.active = false;
        }
    });
    explosions.current = explosions.current.filter(ex => ex.active);
  };

  const updateParticles = () => {
      particles.current.forEach(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.life--;
      });
      particles.current = particles.current.filter(p => p.life > 0);
  };

  const createExplosion = (x, y, isChain = false, maxRadius = 30, color = null) => {
      if (explosions.current.length >= 50) return;
      const mr = isChain ? 25 : maxRadius;
      if (mr > 10) Sound.explosion(mr);
      explosions.current.push({
          x, y,
          radius: 1,
          maxRadius: mr,
          growing: true,
          active: true,
          color: color || (isChain ? '#ffaa00' : '#fff'),
          shockwaveRadius: 0,
          screenShakeAmount: mr > 50 ? 4 : mr > 30 ? 2 : 0
      });
      // Screen shake for large explosions
      if (mr > 30) {
          screenShake.current = Math.max(screenShake.current, mr > 50 ? 6 : 3);
      }
  };

  const createParticles = (x, y, color, count = 8) => {
      const room = 500 - particles.current.length;
      const actual = Math.min(count, room);
      for(let i=0; i<actual; i++) {
          const maxLife = 20 + Math.random() * 20;
          particles.current.push({
              x, y,
              vx: (Math.random() - 0.5) * 5,
              vy: (Math.random() - 0.5) * 5,
              color: color,
              life: maxLife,
              maxLife: maxLife,
              size: 1 + Math.random() * 3,
              shape: Math.random() > 0.5 ? 'circle' : 'square'
          });
      }
  };

  // --- Input Handling ---
  const handleCanvasClick = (e) => {
    if (gameState !== 'PLACEMENT') return;

    const rect = canvasRef.current.getBoundingClientRect();
    const scaleX = GAME_WIDTH / rect.width;
    const scaleY = GAME_HEIGHT / rect.height;
    const x = (e.clientX - rect.left) * scaleX;
    const clickY = (e.clientY - rect.top) * scaleY;

    // Restrict turret placement/upgrade to upper terrain zone
    if (clickY > CITY_ZONE_TOP) {
        if (selectedAction) {
            setMessage('CANNOT PLACE IN CIVILIAN ZONE');
        }
        return;
    }

    const y = getTerrainHeight(x, upperTerrain.current);

    const clickedTurret = turrets.current.find(t => distance(x, y, t.x, t.y) < 30);
    if (clickedTurret) {
        const upgradeCost = UPGRADE_BASE_COST * Math.pow(2, clickedTurret.level - 1);
        if (money >= upgradeCost) {
            setMoney(m => m - upgradeCost);
            clickedTurret.stats.fireRate = Math.max(2, clickedTurret.stats.fireRate * 0.85);
            clickedTurret.stats.range += 40;
            clickedTurret.stats.damage *= 1.2;
            clickedTurret.level++;
            createParticles(clickedTurret.x, clickedTurret.y, '#0f0');
            Sound.upgrade();
            setMessage(`SYSTEM UPGRADED TO MK ${clickedTurret.level} (NEXT: $${UPGRADE_BASE_COST * Math.pow(2, clickedTurret.level - 1)})`);
        } else {
            setMessage(`INSUFFICIENT FUNDS (NEED $${upgradeCost})`);
        }
        return;
    }

    if (selectedAction) {
        const typeData = TURRET_TYPES[selectedAction];
        if (money >= typeData.cost) {
            setMoney(m => m - typeData.cost);
            turrets.current.push({
                id: Date.now(),
                x,
                y: y - 10,
                type: selectedAction,
                stats: { ...typeData },
                lastFired: 0,
                level: 1,
                angle: -Math.PI / 2,
                recoilOffset: 0,
                muzzleFlashTimer: 0
            });
            createParticles(x, y, typeData.color);
            Sound.placeTurret();
            setSelectedAction(null);
            setMessage(`${typeData.name} ONLINE`);
        } else {
            setMessage('INSUFFICIENT FUNDS');
            setSelectedAction(null);
        }
    }
  };

  const fortifyCity = () => {
      const cost = FORTIFY_BASE_COST * Math.pow(2, fortifyCount.current);
      const activeCities = cities.filter(c => c.active && !c.isVillage);
      if (activeCities.length === 0) {
          setMessage("NO CITIES TO FORTIFY");
          return;
      }
      if (activeCities.every(c => (c.tier || 1) >= 5)) {
          setMessage("ALL CITIES AT MAX TIER");
          return;
      }
      if (money < cost) {
          setMessage("INSUFFICIENT FUNDS");
          return;
      }
      setMoney(m => m - cost);
      fortifyCount.current++;
      // Upgrade lowest-tier active city
      const minTier = Math.min(...activeCities.map(c => c.tier || 1));
      let upgraded = false;
      const newCities = cities.map(c => {
          if (!upgraded && c.active && !c.isVillage && (c.tier || 1) === minTier && (c.tier || 1) < 5) {
              upgraded = true;
              const newTier = (c.tier || 1) + 1;
              const newMaxHp = (c.maxHp || 3) + 2;
              createParticles(c.x, c.y, '#0ff', 12);
              Sound.upgrade();
              return { ...c, tier: newTier, maxHp: newMaxHp, hp: newMaxHp, buildings: generateCityBuildings(newTier) };
          }
          return c;
      });
      setCities(newCities);
      const fortified = newCities.find(c => c.active && upgraded);
      setMessage(`CITY FORTIFIED — TIER ${fortified ? fortified.tier : '?'}`);
  };

  const handleMouseMove = (e) => {
      const rect = canvasRef.current.getBoundingClientRect();
      const scaleX = GAME_WIDTH / rect.width;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * (GAME_HEIGHT / rect.height);

      mousePos.current = { x, y };

      if (gameState === 'PLACEMENT') {
          // Only show turret hover when in upper terrain zone
          if (y <= CITY_ZONE_TOP) {
              const terrainY = getTerrainHeight(x, upperTerrain.current);
              const hovered = turrets.current.find(t => distance(x, terrainY, t.x, t.y) < 30);
              setHoveredTurret(hovered || null);
          } else {
              setHoveredTurret(null);
          }
      }
  };

  // --- Rendering ---
  const draw = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const fc = frameCount.current;

    // Screen shake
    ctx.save();
    if (screenShake.current > 0.5) {
        const sx = (Math.random() - 0.5) * screenShake.current * 2;
        const sy = (Math.random() - 0.5) * screenShake.current * 2;
        ctx.translate(sx, sy);
    }

    drawBackground(ctx, mapData.current, fc);
    drawUpperTerrain(ctx, upperTerrain.current, mapData.current);

    // Turrets on upper terrain
    turrets.current.forEach(t => {
        const isHovered = hoveredTurret && hoveredTurret.id === t.id;
        drawTurret(ctx, t, isHovered, gameState, fc);
    });

    // Compute foreground zoom-out based on tallest building
    const maxBuildingH = cities.reduce((max, c) => {
        if (!c.active) return max;
        return c.buildings.reduce((m, b) => Math.max(m, (b.damage || 0) < 0.8 ? b.h : 0), max);
    }, 0);
    const cityZoneHeight = LOWER_TERRAIN_Y - CITY_ZONE_TOP + 20; // allow slight turret overlap
    const maxAllowed = cityZoneHeight * 0.95;
    const fgScale = maxBuildingH > maxAllowed ? maxAllowed / maxBuildingH : 1.0;

    if (fgScale < 1.0) {
        ctx.save();
        // Scale from bottom-center: shrink foreground, anchored at canvas bottom
        ctx.translate(GAME_WIDTH / 2, GAME_HEIGHT);
        ctx.scale(fgScale, fgScale);
        ctx.translate(-GAME_WIDTH / 2, -GAME_HEIGHT);
    }

    drawLowerTerrain(ctx, lowerTerrain.current);

    // Cities on lower terrain
    cities.forEach(c => drawCity(ctx, c, fc));

    if (fgScale < 1.0) {
        ctx.restore();
    }

    // Placement ghost — only in turret zone
    if (gameState === 'PLACEMENT' && selectedAction && mousePos.current.y <= CITY_ZONE_TOP) {
        const mx = mousePos.current.x;
        const my = getTerrainHeight(mx, upperTerrain.current);
        const typeData = TURRET_TYPES[selectedAction];

        ctx.strokeStyle = typeData.color;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(mx, my - 10, 10, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1.0;

        // Ghost range
        const ghostGrad = ctx.createRadialGradient(mx, my - 10, 0, mx, my - 10, typeData.range);
        ghostGrad.addColorStop(0, 'rgba(0, 255, 0, 0.02)');
        ghostGrad.addColorStop(1, 'rgba(0, 255, 0, 0)');
        ctx.fillStyle = ghostGrad;
        ctx.beginPath();
        ctx.arc(mx, my - 10, typeData.range, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#333';
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.arc(mx, my - 10, typeData.range, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    bombers.current.forEach(b => b.isBossShip ? drawBossShip(ctx, b, fc) : drawBomber(ctx, b, fc));
    enemyMissiles.current.forEach(m => drawEnemyMissile(ctx, m, fc));
    playerMissiles.current.forEach(m => drawPlayerMissile(ctx, m));
    lasers.current.forEach(l => drawLaserBeam(ctx, l));
    explosions.current.forEach(ex => drawExplosion(ctx, ex));
    particles.current.forEach(p => drawParticle(ctx, p));

    // EMP pulse rings
    empPulses.current.forEach(p => {
        const alpha = (p.life / 60) * 0.6;
        ctx.save();
        ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
        ctx.lineWidth = 3 * (p.life / 60);
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.stroke();
        // Inner glow ring
        ctx.strokeStyle = `rgba(100, 200, 255, ${alpha * 0.4})`;
        ctx.lineWidth = 8 * (p.life / 60);
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    });

    ctx.restore(); // End screen shake
  };

  const loop = useCallback(() => {
    update();
    draw();
    requestRef.current = requestAnimationFrame(loop);
  }, [update]);

  useEffect(() => {
    requestRef.current = requestAnimationFrame(loop);
    return () => cancelAnimationFrame(requestRef.current);
  }, [loop]);


  // --- UI ---
  return (
    <div className="w-full h-full min-h-screen bg-zinc-950 flex flex-col items-center p-2 font-mono text-green-500 select-none overflow-y-auto">

      {/* HUD */}
      <div className="w-full max-w-[800px] bg-black border border-green-900 p-2 mb-2 flex justify-between items-center shadow-lg rounded">
        <div className="flex gap-4 md:gap-8">
            <div className="flex flex-col">
                <span className="text-[10px] text-green-700">FUNDS</span>
                <div className="flex items-center gap-1 text-lg font-bold text-green-400">
                    <DollarSign size={16} />{money}
                </div>
            </div>
            <div className="flex flex-col">
                <span className="text-[10px] text-green-700">SCORE</span>
                <div className="flex items-center gap-1 text-lg font-bold">
                    <Trophy size={16} />{score}
                </div>
            </div>
            <div className="flex flex-col">
                <span className="text-[10px] text-green-700">WAVE</span>
                <div className="flex items-center gap-1 text-lg font-bold">
                    <Shield size={16} />{level}
                </div>
            </div>
        </div>
        <div className="text-green-400 font-bold animate-pulse text-right text-sm">
            {message}
        </div>
      </div>

      {/* Game Viewport */}
      <div className="relative border-2 border-zinc-800 rounded shadow-2xl bg-black mb-2 overflow-hidden">
        <canvas
            ref={canvasRef}
            width={GAME_WIDTH}
            height={GAME_HEIGHT}
            onClick={handleCanvasClick}
            onMouseMove={handleMouseMove}
            className="block cursor-crosshair max-w-full h-auto"
        />

        {/* --- OVERLAYS --- */}

        {gameState === 'START' && (
            <div className="absolute inset-0 bg-black/90 flex flex-col items-center justify-center">
                <h1 className="text-4xl md:text-6xl font-black text-green-500 tracking-tighter mb-4" style={{textShadow: '0 0 15px #0f0'}}>VECTOR DEFENSE</h1>
                <p className="text-green-700 mb-8 tracking-widest text-center">DEFEND THE CITIES</p>
                <div className="flex flex-col gap-3">
                    {hasSave() && (
                        <button onClick={resumeGame} className="px-8 py-3 border border-green-500 text-green-500 hover:bg-green-500 hover:text-black font-bold uppercase tracking-widest transition-all">
                            Continue (Wave {(() => { try { const s = JSON.parse(localStorage.getItem(SAVE_KEY)); return s?.level || '?'; } catch(e) { return '?'; } })()})
                        </button>
                    )}
                    <button onClick={initGame} className="px-8 py-3 border border-green-500 text-green-500 hover:bg-green-500 hover:text-black font-bold uppercase tracking-widest transition-all">
                        {hasSave() ? 'New Game' : 'Initialize'}
                    </button>
                </div>
            </div>
        )}

        {/* LEVEL COMPLETE */}
        {gameState === 'LEVEL_COMPLETE' && bonusReport && (
             <div className="absolute inset-0 bg-black flex flex-col items-center justify-center font-mono">
                <h2 className="text-4xl text-green-500 font-bold mb-8 blink">WAVE {bonusReport.wave} CLEARED</h2>

                <div className="w-64 space-y-4 mb-8 text-green-400">
                    <div className="flex justify-between border-b border-green-900 pb-1">
                        <span>BASE BONUS</span>
                        <span>{bonusReport.base}</span>
                    </div>
                    <div className="flex justify-between border-b border-green-900 pb-1">
                        <span>CITIES SECURE ({bonusReport.cityCount})</span>
                        <span>{bonusReport.cityBonus}</span>
                    </div>
                    {bonusReport.repairedCount > 0 && (
                    <div className="flex justify-between border-b border-cyan-900 pb-1 text-cyan-400">
                        <span>CITIES REPAIRED</span>
                        <span>{bonusReport.repairedCount}</span>
                    </div>
                    )}
                    {bonusReport.growingCount > 0 && (
                    <div className="flex justify-between border-b border-emerald-900 pb-1 text-emerald-400">
                        <span>CITIES GROWING</span>
                        <span>{bonusReport.growingCount}</span>
                    </div>
                    )}
                    {bonusReport.villageCount > 0 && (
                    <div className="flex justify-between border-b border-amber-900 pb-1 text-amber-400">
                        <span>VILLAGES SETTLED</span>
                        <span>{bonusReport.villageCount}</span>
                    </div>
                    )}
                    <div className="flex justify-between text-yellow-400 font-bold pt-2">
                        <span>TOTAL FUNDS</span>
                        <span>+{bonusReport.total}</span>
                    </div>
                </div>

                <button
                    onClick={advanceLevel}
                    className="px-8 py-3 bg-green-900 text-white font-bold hover:bg-green-700 animate-pulse border border-green-500"
                >
                    PROCEED TO NEXT SECTOR
                </button>
             </div>
        )}

        {/* GAME OVER */}
        {gameState === 'GAME_OVER' && (
            <div className="absolute inset-0 bg-black/95 flex flex-col items-center justify-center">
                <h2 className="text-5xl text-red-500 font-bold mb-2 glitch-effect">SECTOR LOST</h2>
                <div className="text-2xl mb-8 border border-green-900 px-6 py-2 text-white">FINAL SCORE: {score}</div>
                <button onClick={initGame} className="flex items-center gap-2 px-6 py-3 border border-red-500 text-red-500 hover:bg-red-900/30 font-bold transition-all">
                    <RotateCcw size={18} /> REBOOT SYSTEM
                </button>
            </div>
        )}
      </div>

      {/* Armory */}
      <div className={`w-full max-w-[800px] transition-all duration-300 ${gameState === 'PLACEMENT' ? 'opacity-100 translate-y-0' : 'opacity-30 grayscale pointer-events-none'}`}>
          <div className="grid grid-cols-2 md:grid-cols-[1fr_auto] gap-2">

              <div className="bg-black border border-green-900 p-2 rounded flex flex-wrap gap-2 justify-center md:justify-start">

                  {Object.keys(TURRET_TYPES).map(key => {
                      const t = TURRET_TYPES[key];
                      const Icon = t.icon;
                      return (
                        <button
                            key={key}
                            onClick={() => setSelectedAction(key)}
                            className={`flex flex-col items-center justify-center w-20 h-20 border rounded transition-all ${selectedAction === key ? 'bg-green-900/40 border-green-400' : 'border-zinc-800 hover:border-zinc-600'}`}
                        >
                            <Icon size={20} style={{color: t.color}} className="mb-1" />
                            <span className="text-[10px] font-bold text-zinc-300">{t.name}</span>
                            <span className="text-[10px] text-green-600">${t.cost}</span>
                        </button>
                      );
                  })}

                  <div className="w-px bg-zinc-800 mx-1"></div>

                   <button
                        onClick={fortifyCity}
                        className="flex flex-col items-center justify-center w-20 h-20 border border-zinc-800 rounded hover:border-cyan-500 group transition-all"
                    >
                        <Wifi size={20} className="text-cyan-400 mb-1 group-hover:animate-pulse" />
                        <span className="text-[10px] font-bold text-zinc-300">FORTIFY</span>
                        <span className="text-[10px] text-cyan-400">${FORTIFY_BASE_COST * Math.pow(2, fortifyCount.current)}</span>
                    </button>
              </div>

              <button
                onClick={startWave}
                className="col-span-2 md:col-span-1 bg-green-900/20 border border-green-600 text-green-400 hover:bg-green-500 hover:text-black transition-all px-6 rounded font-bold text-lg flex items-center justify-center uppercase tracking-wider"
              >
                  <Play size={24} className="mr-2" /> ENGAGE
              </button>
          </div>
          <div className="text-center text-xs text-zinc-600 mt-2">
            Click Unit to Upgrade (cost scales per level)
          </div>
      </div>

      <style>{`
        @keyframes blink { 50% { opacity: 0; } }
        .blink { animation: blink 1s step-end infinite; }
      `}</style>
    </div>
  );
};

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
