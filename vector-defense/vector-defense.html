<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Defense</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        html, body { margin: 0; padding: 0; background: #09090b; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
const { useState, useEffect, useRef, useCallback } = React;

// --- Inline SVG Icon Components (replacing lucide-react) ---
const SvgIcon = ({ children, size = 24, className = '', style = {}, ...props }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24"
         fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round"
         strokeLinejoin="round" className={className} style={style} {...props}>
        {children}
    </svg>
);

const Play = (props) => <SvgIcon {...props}><polygon points="5 3 19 12 5 21 5 3"/></SvgIcon>;
const RotateCcw = (props) => <SvgIcon {...props}><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></SvgIcon>;
const Shield = (props) => <SvgIcon {...props}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></SvgIcon>;
const DollarSign = (props) => <SvgIcon {...props}><line x1="12" y1="1" x2="12" y2="23"/><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/></SvgIcon>;
const Crosshair = (props) => <SvgIcon {...props}><circle cx="12" cy="12" r="10"/><line x1="22" y1="12" x2="18" y2="12"/><line x1="6" y1="12" x2="2" y2="12"/><line x1="12" y1="6" x2="12" y2="2"/><line x1="12" y1="22" x2="12" y2="18"/></SvgIcon>;
const Trophy = (props) => <SvgIcon {...props}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></SvgIcon>;
const AlertTriangle = (props) => <SvgIcon {...props}><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></SvgIcon>;
const Zap = (props) => <SvgIcon {...props}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></SvgIcon>;
const Target = (props) => <SvgIcon {...props}><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></SvgIcon>;
const Wifi = (props) => <SvgIcon {...props}><path d="M5 12.55a11 11 0 0 1 14.08 0"/><path d="M1.42 9a16 16 0 0 1 21.16 0"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><line x1="12" y1="20" x2="12.01" y2="20"/></SvgIcon>;

// --- Constants ---
const GAME_WIDTH = 800;
const GAME_HEIGHT = 600;
const PLAYER_PROJECTILE_SPEED = 15;
const SAM_SPEED = 7;
const EXPLOSION_GROWTH = 1.5;

// Balance Constants
const FLAK_COST = 800;
const SAM_COST = 1800;
const ARTILLERY_COST = 2800;
const LASER_COST = 4500;
const UPGRADE_BASE_COST = 500;
const FORTIFY_COST = 1500;
const CITY_REPAIR_PENALTY = 300;
const WAVE_COMPLETE_BONUS = 2500;

// Enemy Stats (HP values)
const HP_NORMAL = 10;
const HP_FAST = 15;
const HP_ARMORED = 40;
const HP_BOSS_BASE = 200;

// Turret Stats
const TURRET_TYPES = {
  FLAK: {
    name: 'FLAK',
    desc: 'Suppression',
    color: '#00ff00',
    range: 600,
    fireRate: 12,
    explosionRadius: 8,
    projectileColor: '#0f0',
    damage: 3,
    cost: FLAK_COST,
    icon: Crosshair
  },
  SAM: {
    name: 'SAM',
    desc: 'High Impact',
    color: '#00ffff',
    range: 400,
    fireRate: 45,
    explosionRadius: 20,
    projectileColor: '#0ff',
    damage: 40,
    cost: SAM_COST,
    icon: Target
  },
  ARTILLERY: {
    name: 'ARTILLERY',
    desc: 'Massive Area',
    color: '#ff00ff',
    range: 350,
    fireRate: 70,
    explosionRadius: 100,
    projectileColor: '#f0f',
    damage: 20,
    cost: ARTILLERY_COST,
    icon: Shield
  },
  LASER: {
    name: 'LASER',
    desc: 'Focused Beam',
    color: '#ffff00',
    range: 500,
    fireRate: 8,
    explosionRadius: 10,
    projectileColor: '#ff0',
    damage: 3,
    cost: LASER_COST,
    icon: Zap
  }
};

// --- Helper Functions ---
const distance = (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);

// --- Audio Engine ---
let audioCtx = null;
let masterGain = null;
const initAudio = () => {
    if (audioCtx) return;
    audioCtx = new AudioContext();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.3;
    masterGain.connect(audioCtx.destination);
};

let lastEnemyHitFrame = 0;

const Sound = {
    turretFire(type) {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        if (type === 'FLAK') {
            // Short white noise burst, bandpass ~2kHz
            const bufferSize = audioCtx.sampleRate * 0.08;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
            const src = audioCtx.createBufferSource();
            src.buffer = buffer;
            const bp = audioCtx.createBiquadFilter();
            bp.type = 'bandpass';
            bp.frequency.value = 2000;
            bp.Q.value = 1.5;
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0.4, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
            src.connect(bp).connect(g).connect(masterGain);
            src.start(t);
            src.stop(t + 0.08);
        } else if (type === 'SAM') {
            // Rising sine sweep 200->800Hz
            const osc = audioCtx.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(200, t);
            osc.frequency.exponentialRampToValueAtTime(800, t + 0.12);
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0.3, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
            osc.connect(g).connect(masterGain);
            osc.start(t);
            osc.stop(t + 0.12);
        } else if (type === 'ARTILLERY') {
            // Low boom: sine 80Hz + noise burst
            const osc = audioCtx.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = 80;
            const g1 = audioCtx.createGain();
            g1.gain.setValueAtTime(0.5, t);
            g1.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
            osc.connect(g1).connect(masterGain);
            osc.start(t);
            osc.stop(t + 0.15);
            // noise layer
            const bufferSize = audioCtx.sampleRate * 0.1;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
            const src = audioCtx.createBufferSource();
            src.buffer = buffer;
            const lp = audioCtx.createBiquadFilter();
            lp.type = 'lowpass';
            lp.frequency.value = 600;
            const g2 = audioCtx.createGain();
            g2.gain.setValueAtTime(0.4, t);
            g2.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
            src.connect(lp).connect(g2).connect(masterGain);
            src.start(t);
            src.stop(t + 0.1);
        }
    },

    laserBeam(dwellTime) {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        const dwell = dwellTime || 0;
        const osc = audioCtx.createOscillator();
        osc.type = 'sine';
        // Low base pitch that rises slightly with dwell
        const baseFreq = 180 + Math.min(dwell, 60) * 2;
        osc.frequency.setValueAtTime(baseFreq, t);
        osc.frequency.linearRampToValueAtTime(baseFreq + 40, t + 0.06);
        // Subtle slow vibrato
        const lfo = audioCtx.createOscillator();
        lfo.frequency.value = 8;
        const lfoGain = audioCtx.createGain();
        lfoGain.gain.value = 6;
        lfo.connect(lfoGain).connect(osc.frequency);
        const g = audioCtx.createGain();
        const vol = Math.min(0.06 + dwell / 500, 0.15);
        g.gain.setValueAtTime(vol, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.06);
        osc.connect(g).connect(masterGain);
        osc.start(t);
        lfo.start(t);
        osc.stop(t + 0.06);
        lfo.stop(t + 0.06);
    },

    explosion(maxRadius) {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        const large = maxRadius > 50;
        const dur = large ? 0.4 : 0.2;
        const bufferSize = audioCtx.sampleRate * dur;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        const lp = audioCtx.createBiquadFilter();
        lp.type = 'lowpass';
        lp.frequency.setValueAtTime(large ? 800 : 1200, t);
        lp.frequency.exponentialRampToValueAtTime(100, t + dur);
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(large ? 0.5 : 0.3, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + dur);
        src.connect(lp).connect(g).connect(masterGain);
        src.start(t);
        src.stop(t + dur);
    },

    enemyHit() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        osc.type = 'triangle';
        osc.frequency.value = 600;
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.15, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.03);
        osc.connect(g).connect(masterGain);
        osc.start(t);
        osc.stop(t + 0.03);
    },

    cityDestroyed() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        // Low descending tone + noise
        const osc = audioCtx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, t);
        osc.frequency.exponentialRampToValueAtTime(100, t + 0.5);
        const g1 = audioCtx.createGain();
        g1.gain.setValueAtTime(0.4, t);
        g1.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
        osc.connect(g1).connect(masterGain);
        osc.start(t);
        osc.stop(t + 0.5);
        const bufferSize = audioCtx.sampleRate * 0.3;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        const lp = audioCtx.createBiquadFilter();
        lp.type = 'lowpass';
        lp.frequency.value = 400;
        const g2 = audioCtx.createGain();
        g2.gain.setValueAtTime(0.3, t);
        g2.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        src.connect(lp).connect(g2).connect(masterGain);
        src.start(t);
        src.stop(t + 0.3);
    },

    waveStart() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(300, t);
        osc.frequency.exponentialRampToValueAtTime(600, t + 0.3);
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.2, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        osc.connect(g).connect(masterGain);
        osc.start(t);
        osc.stop(t + 0.3);
    },

    bossWarning() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        // Two alternating low alarm tones
        for (let i = 0; i < 3; i++) {
            const osc = audioCtx.createOscillator();
            osc.type = 'square';
            osc.frequency.value = i % 2 === 0 ? 150 : 120;
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0, t + i * 0.2);
            g.gain.linearRampToValueAtTime(0.3, t + i * 0.2 + 0.02);
            g.gain.setValueAtTime(0.3, t + i * 0.2 + 0.15);
            g.gain.linearRampToValueAtTime(0, t + i * 0.2 + 0.19);
            osc.connect(g).connect(masterGain);
            osc.start(t + i * 0.2);
            osc.stop(t + i * 0.2 + 0.2);
        }
    },

    gameOver() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        // Descending 3-note sequence
        const notes = [440, 330, 220];
        notes.forEach((freq, i) => {
            const osc = audioCtx.createOscillator();
            osc.type = 'square';
            osc.frequency.value = freq;
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0.25, t + i * 0.25);
            g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.25 + 0.22);
            osc.connect(g).connect(masterGain);
            osc.start(t + i * 0.25);
            osc.stop(t + i * 0.25 + 0.25);
        });
    },

    upgrade() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        // Quick ascending 2-note chirp
        const notes = [500, 750];
        notes.forEach((freq, i) => {
            const osc = audioCtx.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = freq;
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0.25, t + i * 0.07);
            g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.07 + 0.06);
            osc.connect(g).connect(masterGain);
            osc.start(t + i * 0.07);
            osc.stop(t + i * 0.07 + 0.07);
        });
    },

    placeTurret() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        // Short click + confirmation beep
        const bufferSize = audioCtx.sampleRate * 0.02;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        const g1 = audioCtx.createGain();
        g1.gain.setValueAtTime(0.2, t);
        g1.gain.exponentialRampToValueAtTime(0.001, t + 0.02);
        src.connect(g1).connect(masterGain);
        src.start(t);
        src.stop(t + 0.02);
        // Confirmation beep
        const osc = audioCtx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = 880;
        const g2 = audioCtx.createGain();
        g2.gain.setValueAtTime(0, t + 0.03);
        g2.gain.linearRampToValueAtTime(0.2, t + 0.04);
        g2.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
        osc.connect(g2).connect(masterGain);
        osc.start(t + 0.03);
        osc.stop(t + 0.1);
    }
};

// --- Pre-create scanline overlay canvas ---
const scanlineCanvas = document.createElement('canvas');
scanlineCanvas.width = GAME_WIDTH;
scanlineCanvas.height = GAME_HEIGHT;
const scanlineCtx = scanlineCanvas.getContext('2d');
scanlineCtx.fillStyle = 'rgba(0, 0, 0, 0.12)';
for (let i = 0; i < GAME_HEIGHT; i += 4) {
    scanlineCtx.fillRect(0, i, GAME_WIDTH, 1);
}

// ============================================================
// MODULAR DRAW HELPERS (Phase 1-5)
// ============================================================

const drawBackground = (ctx, mapData, frameCount) => {
    ctx.fillStyle = '#050510';
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    // Stars
    if (mapData.stars) {
        mapData.stars.forEach(s => {
            const twinkle = 0.4 + 0.6 * Math.abs(Math.sin(frameCount * 0.02 + s.twinklePhase));
            ctx.globalAlpha = s.brightness * twinkle;
            ctx.fillStyle = s.color;
            ctx.fillRect(s.x, s.y, s.size, s.size);
        });
        ctx.globalAlpha = 1.0;
    }

    // Scanlines via offscreen canvas
    ctx.drawImage(scanlineCanvas, 0, 0);

    // Grid
    ctx.strokeStyle = '#0a0a0a';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let i = 0; i < GAME_WIDTH; i += 50) { ctx.moveTo(i, 0); ctx.lineTo(i, GAME_HEIGHT); }
    for (let i = 0; i < GAME_HEIGHT; i += 50) { ctx.moveTo(0, i); ctx.lineTo(GAME_WIDTH, i); }
    ctx.stroke();
};

const drawTerrain = (ctx, terrainPoints, mapData) => {
    if (!terrainPoints || terrainPoints.length === 0) return;

    // Background mountains
    if (mapData.bgTerrain && mapData.bgTerrain.length > 0) {
        ctx.beginPath();
        ctx.moveTo(0, GAME_HEIGHT);
        ctx.lineTo(0, mapData.bgTerrain[0].y);
        mapData.bgTerrain.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.lineTo(GAME_WIDTH, mapData.bgTerrain[mapData.bgTerrain.length - 1].y);
        ctx.lineTo(GAME_WIDTH, GAME_HEIGHT);
        ctx.fillStyle = '#000d00';
        ctx.fill();
        ctx.strokeStyle = '#002200';
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    // Main terrain fill
    ctx.beginPath();
    ctx.moveTo(0, GAME_HEIGHT);
    ctx.lineTo(0, terrainPoints[0].y);
    terrainPoints.forEach(p => ctx.lineTo(p.x, p.y));
    ctx.lineTo(GAME_WIDTH, terrainPoints[terrainPoints.length - 1].y);
    ctx.lineTo(GAME_WIDTH, GAME_HEIGHT);
    ctx.fillStyle = '#001a00';
    ctx.fill();

    // Rock face hatching on steep slopes
    for (let i = 0; i < terrainPoints.length - 1; i++) {
        const p1 = terrainPoints[i];
        const p2 = terrainPoints[i + 1];
        const slope = Math.abs(p2.y - p1.y) / (p2.x - p1.x || 1);
        if (slope > 1.2) {
            ctx.strokeStyle = '#002200';
            ctx.lineWidth = 1;
            const steps = 3;
            for (let s = 0; s < steps; s++) {
                const t = (s + 0.5) / steps;
                const hx = p1.x + (p2.x - p1.x) * t;
                const hy = p1.y + (p2.y - p1.y) * t;
                ctx.beginPath();
                ctx.moveTo(hx, hy);
                ctx.lineTo(hx + 4, hy + 6);
                ctx.stroke();
            }
        }
    }

    // Snow caps on highest peaks
    for (let i = 1; i < terrainPoints.length - 1; i++) {
        const p = terrainPoints[i];
        if (p.y < GAME_HEIGHT - 180 && p.y < terrainPoints[i - 1].y && p.y < terrainPoints[i + 1].y) {
            ctx.fillStyle = 'rgba(200, 220, 255, 0.15)';
            ctx.beginPath();
            ctx.moveTo(p.x - 6, p.y);
            ctx.lineTo(p.x, p.y - 5);
            ctx.lineTo(p.x + 6, p.y);
            ctx.fill();
        }
    }

    // Main terrain outline with CRT glow
    ctx.save();
    ctx.shadowColor = '#00ff00';
    ctx.shadowBlur = 6;
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, terrainPoints[0].y);
    terrainPoints.forEach(p => ctx.lineTo(p.x, p.y));
    ctx.lineTo(GAME_WIDTH, terrainPoints[terrainPoints.length - 1].y);
    ctx.stroke();
    ctx.restore();

    // Vegetation
    if (mapData.vegetation) {
        mapData.vegetation.forEach(v => {
            ctx.strokeStyle = v.color;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(v.x, v.y);
            ctx.lineTo(v.x, v.y - v.h);
            ctx.stroke();
        });
    }

    // Atmospheric haze
    const hazeGrad = ctx.createLinearGradient(0, GAME_HEIGHT * 0.7, 0, GAME_HEIGHT);
    hazeGrad.addColorStop(0, 'rgba(0, 20, 0, 0)');
    hazeGrad.addColorStop(1, 'rgba(0, 20, 0, 0.3)');
    ctx.fillStyle = hazeGrad;
    ctx.fillRect(0, GAME_HEIGHT * 0.7, GAME_WIDTH, GAME_HEIGHT * 0.3);
};

const TIER_COLORS = [
    null,
    { gradTop: '#00cccc', gradBot: '#005566', outline: '#006677', winLit: '#aaffff', winDark: '#003344', antenna: '#006666' },
    { gradTop: '#00eeff', gradBot: '#006677', outline: '#007788', winLit: '#bbffff', winDark: '#004455', antenna: '#008888' },
    { gradTop: '#aaddff', gradBot: '#2255aa', outline: '#3366bb', winLit: '#ddeeff', winDark: '#113366', antenna: '#4488cc' },
    { gradTop: '#cc88ff', gradBot: '#3322aa', outline: '#5533cc', winLit: '#ddaaff', winDark: '#221166', antenna: '#7744dd' },
    { gradTop: '#ffdd66', gradBot: '#aa6600', outline: '#cc8800', winLit: '#ffeeaa', winDark: '#554400', antenna: '#ddaa44' },
];

const drawCity = (ctx, city, frameCount) => {
    if (!city.active) return;
    const tier = city.tier || 1;
    const tc = TIER_COLORS[Math.min(tier, 5)];

    // Light pollution glow — scales with tier
    ctx.save();
    const glowR = 50 + tier * 10;
    const glowA = 0.06 + tier * 0.02;
    const gc = TIER_COLORS[Math.min(tier, 5)];
    const glowGrad = ctx.createRadialGradient(city.x, city.y, 5, city.x, city.y, glowR);
    glowGrad.addColorStop(0, `rgba(${gc.winLit === '#ffeeaa' ? '255,220,100' : gc.winLit === '#ddaaff' ? '180,120,255' : gc.winLit === '#ddeeff' ? '150,200,255' : '0,200,200'}, ${glowA})`);
    glowGrad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = glowGrad;
    ctx.fillRect(city.x - glowR, city.y - glowR, glowR * 2, glowR);
    ctx.restore();

    // Shield shimmer for tier 3+
    if (tier >= 3) {
        ctx.save();
        const shimmerAlpha = 0.04 + 0.03 * Math.sin(frameCount * 0.03);
        const shieldR = 45 + tier * 8;
        ctx.strokeStyle = tier >= 5
            ? `rgba(255, 220, 100, ${shimmerAlpha + 0.06 * Math.sin(frameCount * 0.08)})`
            : tier >= 4
            ? `rgba(180, 120, 255, ${shimmerAlpha})`
            : `rgba(100, 200, 255, ${shimmerAlpha})`;
        ctx.lineWidth = tier >= 5 ? 2 : 1;
        ctx.beginPath();
        ctx.arc(city.x, city.y - 10, shieldR, Math.PI, 0);
        ctx.stroke();
        // Tier 5: pulsing golden ring
        if (tier >= 5) {
            const ringAlpha = 0.08 + 0.06 * Math.sin(frameCount * 0.06);
            ctx.strokeStyle = `rgba(255, 200, 80, ${ringAlpha})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(city.x, city.y - 5, shieldR + 8, Math.PI * 1.1, Math.PI * -0.1);
            ctx.stroke();
        }
        ctx.restore();
    }

    city.buildings.forEach(b => {
        const bx = city.x + b.xOffset - (b.w / 2);
        const by = city.y - b.h;

        // Building gradient fill — tier colored
        const bGrad = ctx.createLinearGradient(bx, by, bx, city.y);
        bGrad.addColorStop(0, tc.gradTop);
        bGrad.addColorStop(1, tc.gradBot);
        ctx.fillStyle = bGrad;

        // Building shape
        if (b.style === 'pointed') {
            ctx.beginPath();
            ctx.moveTo(bx, city.y);
            ctx.lineTo(bx, by + 4);
            ctx.lineTo(bx + b.w / 2, by);
            ctx.lineTo(bx + b.w, by + 4);
            ctx.lineTo(bx + b.w, city.y);
            ctx.fill();
        } else if (b.style === 'dome') {
            ctx.fillRect(bx, by + 4, b.w, b.h - 4);
            ctx.beginPath();
            ctx.arc(bx + b.w / 2, by + 4, b.w / 2, Math.PI, 0);
            ctx.fill();
        } else if (b.style === 'stepped') {
            ctx.fillRect(bx + 2, by, b.w - 4, b.h);
            ctx.fillRect(bx, by + b.h * 0.3, b.w, b.h * 0.7);
        } else {
            // flat with parapet lip
            ctx.fillRect(bx, by, b.w, b.h);
            ctx.fillRect(bx - 1, by, b.w + 2, 2);
        }

        // Building outline
        ctx.strokeStyle = tc.outline;
        ctx.lineWidth = 1;
        ctx.strokeRect(bx, by, b.w, b.h);

        // Windows
        if (b.windows) {
            b.windows.forEach(win => {
                const lit = ((frameCount >> 6) + win.phase) % 3 !== 0;
                ctx.fillStyle = lit ? tc.winLit : tc.winDark;
                ctx.fillRect(bx + win.ox, by + win.oy, 2, 2);
            });
        }

        // Antenna
        if (b.hasAntenna) {
            ctx.strokeStyle = tc.antenna;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(bx + b.w / 2, by);
            ctx.lineTo(bx + b.w / 2, by - 8);
            ctx.stroke();
            if ((frameCount >> 5) % 2 === 0) {
                ctx.fillStyle = tier >= 5 ? '#ffdd00' : tier >= 4 ? '#cc66ff' : '#ff0000';
                ctx.fillRect(bx + b.w / 2 - 1, by - 9, 2, 2);
            }
        }
    });

    // HP bar above city
    const barW = 30;
    const barH = 3;
    const barX = city.x - barW / 2;
    const barY = city.y - (tier >= 3 ? 55 + tier * 5 : 45) ;
    const hpRatio = (city.hp || 1) / (city.maxHp || 1);
    ctx.fillStyle = '#111';
    ctx.fillRect(barX - 1, barY - 1, barW + 2, barH + 2);
    ctx.fillStyle = hpRatio > 0.5 ? tc.gradTop : hpRatio > 0.25 ? '#ffaa00' : '#ff3333';
    ctx.fillRect(barX, barY, barW * hpRatio, barH);
};

const drawTurret = (ctx, t, isHovered, gameState, frameCount) => {
    const color = isHovered ? '#ffff00' : t.stats.color;

    // Range circle
    if (gameState === 'PLACEMENT' && isHovered) {
        const rangeGrad = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, t.stats.range);
        rangeGrad.addColorStop(0, 'rgba(0, 255, 0, 0.03)');
        rangeGrad.addColorStop(0.8, 'rgba(0, 255, 0, 0.02)');
        rangeGrad.addColorStop(1, 'rgba(0, 255, 0, 0)');
        ctx.fillStyle = rangeGrad;
        ctx.beginPath();
        ctx.arc(t.x, t.y, t.stats.range, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
        ctx.setLineDash([5, 5]);
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(t.x, t.y, t.stats.range, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    const angle = t.angle || -Math.PI / 2;
    const recoil = t.recoilOffset || 0;

    if (t.type === 'FLAK') {
        // Concentric circles base
        ctx.fillStyle = '#000';
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(t.x, t.y, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(t.x, t.y, 6, 0, Math.PI * 2);
        ctx.stroke();

        // Dual barrels
        ctx.save();
        ctx.translate(t.x, t.y);
        ctx.rotate(angle);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-2, -recoil);
        ctx.lineTo(-2, -14 + recoil);
        ctx.moveTo(2, -recoil);
        ctx.lineTo(2, -14 + recoil);
        ctx.stroke();
        ctx.restore();

    } else if (t.type === 'SAM') {
        // Triangle base
        ctx.fillStyle = '#000';
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(t.x - 10, t.y);
        ctx.lineTo(t.x, t.y - 8);
        ctx.lineTo(t.x + 10, t.y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Gradient fill
        const samGrad = ctx.createLinearGradient(t.x, t.y, t.x, t.y - 8);
        samGrad.addColorStop(0, 'rgba(0, 255, 255, 0.1)');
        samGrad.addColorStop(1, 'rgba(0, 255, 255, 0.3)');
        ctx.fillStyle = samGrad;
        ctx.beginPath();
        ctx.moveTo(t.x - 10, t.y);
        ctx.lineTo(t.x, t.y - 8);
        ctx.lineTo(t.x + 10, t.y);
        ctx.closePath();
        ctx.fill();

        // Launcher rail
        ctx.save();
        ctx.translate(t.x, t.y - 4);
        ctx.rotate(angle + Math.PI / 2);
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, recoil);
        ctx.lineTo(0, 14 - recoil);
        ctx.stroke();
        // Rail tick marks
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-2, 4);
        ctx.lineTo(2, 4);
        ctx.moveTo(-2, 8);
        ctx.lineTo(2, 8);
        ctx.stroke();
        ctx.restore();

    } else if (t.type === 'ARTILLERY') {
        // Trapezoid body
        ctx.fillStyle = '#000';
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(t.x - 14, t.y + 6);
        ctx.lineTo(t.x - 10, t.y - 8);
        ctx.lineTo(t.x + 10, t.y - 8);
        ctx.lineTo(t.x + 14, t.y + 6);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Rivets
        ctx.fillStyle = color;
        ctx.fillRect(t.x - 8, t.y - 4, 2, 2);
        ctx.fillRect(t.x + 6, t.y - 4, 2, 2);
        ctx.fillRect(t.x - 8, t.y + 2, 2, 2);
        ctx.fillRect(t.x + 6, t.y + 2, 2, 2);

        // Long thick rotating barrel
        ctx.save();
        ctx.translate(t.x, t.y - 4);
        ctx.rotate(angle + Math.PI / 2);
        ctx.strokeStyle = color;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(0, recoil);
        ctx.lineTo(0, 20 - recoil);
        ctx.stroke();
        // Barrel tip
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(0, 18 - recoil);
        ctx.lineTo(0, 20 - recoil);
        ctx.stroke();
        ctx.restore();

    } else if (t.type === 'LASER') {
        // Octagon base
        ctx.fillStyle = '#000';
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            const a = (i / 8) * Math.PI * 2 - Math.PI / 8;
            const px = t.x + Math.cos(a) * 10;
            const py = t.y + Math.sin(a) * 10;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Pulsing inner ring
        const pulseAlpha = 0.3 + 0.7 * Math.abs(Math.sin(frameCount * 0.1 + (t.dwellTime || 0) * 0.05));
        ctx.strokeStyle = `rgba(255, 255, 0, ${pulseAlpha})`;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(t.x, t.y, 5, 0, Math.PI * 2);
        ctx.stroke();

        // Emitter stalk
        ctx.save();
        ctx.translate(t.x, t.y);
        ctx.rotate(angle + Math.PI / 2);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, 12);
        ctx.stroke();
        // Emitter tip dot
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(0, 13, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    // Muzzle flash
    if (t.muzzleFlashTimer > 0) {
        const flashAlpha = t.muzzleFlashTimer / 8;
        ctx.save();
        ctx.translate(t.x, t.y);
        ctx.rotate(angle + Math.PI / 2);
        const barrelLen = t.type === 'ARTILLERY' ? 20 : t.type === 'SAM' ? 14 : 14;
        ctx.fillStyle = `rgba(255, 255, 200, ${flashAlpha})`;
        ctx.beginPath();
        ctx.arc(0, barrelLen, 4 + t.muzzleFlashTimer, 0, Math.PI * 2);
        ctx.fill();
        // Starburst
        ctx.strokeStyle = `rgba(255, 255, 255, ${flashAlpha * 0.7})`;
        ctx.lineWidth = 1;
        for (let i = 0; i < 4; i++) {
            const sa = (i / 4) * Math.PI * 2;
            ctx.beginPath();
            ctx.moveTo(Math.cos(sa) * 2 + 0, barrelLen + Math.sin(sa) * 2);
            ctx.lineTo(Math.cos(sa) * (5 + t.muzzleFlashTimer), barrelLen + Math.sin(sa) * (5 + t.muzzleFlashTimer));
            ctx.stroke();
        }
        ctx.restore();
    }

    // Level pips - chevrons
    ctx.fillStyle = color;
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    for (let i = 0; i < t.level; i++) {
        const pipX = t.x - ((t.level - 1) * 4) / 2 + (i * 4);
        const pipY = t.y + 14;
        ctx.beginPath();
        ctx.moveTo(pipX, pipY + 3);
        ctx.lineTo(pipX + 2, pipY);
        ctx.lineTo(pipX + 4, pipY + 3);
        ctx.stroke();
    }

    // Glowing ring at level 3+
    if (t.level >= 3) {
        ctx.strokeStyle = `rgba(${color === '#00ff00' ? '0,255,0' : color === '#00ffff' ? '0,255,255' : color === '#ff00ff' ? '255,0,255' : '255,255,0'}, ${0.2 + 0.15 * Math.sin(frameCount * 0.08)})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(t.x, t.y, 14, 0, Math.PI * 2);
        ctx.stroke();
    }
};

const drawBomber = (ctx, b, frameCount) => {
    const dir = b.vx > 0 ? 1 : -1;

    // Fuselage - hexagonal
    ctx.save();
    ctx.translate(b.x, b.y);

    // Swept-back wings
    ctx.fillStyle = '#cccc00';
    ctx.beginPath();
    ctx.moveTo(dir * -4, 0);
    ctx.lineTo(dir * -12, -10);
    ctx.lineTo(dir * -8, 0);
    ctx.moveTo(dir * -4, 0);
    ctx.lineTo(dir * -12, 10);
    ctx.lineTo(dir * -8, 0);
    ctx.fill();

    // Fuselage gradient
    const fuseGrad = ctx.createLinearGradient(0, -5, 0, 5);
    fuseGrad.addColorStop(0, '#ffff44');
    fuseGrad.addColorStop(0.5, '#cccc00');
    fuseGrad.addColorStop(1, '#888800');
    ctx.fillStyle = fuseGrad;
    ctx.beginPath();
    ctx.moveTo(dir * 12, 0);
    ctx.lineTo(dir * 6, -5);
    ctx.lineTo(dir * -6, -5);
    ctx.lineTo(dir * -10, 0);
    ctx.lineTo(dir * -6, 5);
    ctx.lineTo(dir * 6, 5);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = '#aaaa00';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Cockpit
    ctx.fillStyle = '#aaffaa';
    ctx.fillRect(dir * 6, -2, dir * 4, 4);

    // Engine glow
    const enginePulse = 0.5 + 0.5 * Math.sin(frameCount * 0.3);
    ctx.fillStyle = `rgba(255, 150, 0, ${0.4 + enginePulse * 0.4})`;
    ctx.beginPath();
    ctx.ellipse(dir * -11, 0, 3 + enginePulse * 2, 2 + enginePulse, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();

    // HP bar
    if (b.hp < b.maxHp) {
        drawHPBar(ctx, b.x - 12, b.y - 16, 24, 3, b.hp / b.maxHp);
    }
};

const drawBossShip = (ctx, b, frameCount) => {
    const dir = b.vx > 0 ? 1 : -1;
    const scale = b.bossTier >= 2 ? 2.5 : 1.8;
    const isMega = b.bossTier >= 2;

    ctx.save();
    ctx.translate(b.x, b.y);

    // Pulsing red glow
    ctx.save();
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 10 + 6 * Math.sin(frameCount * 0.12);

    // Swept-back wings (scaled)
    ctx.fillStyle = isMega ? '#880000' : '#993300';
    ctx.beginPath();
    ctx.moveTo(dir * -4 * scale, 0);
    ctx.lineTo(dir * -12 * scale, -10 * scale);
    ctx.lineTo(dir * -8 * scale, 0);
    ctx.moveTo(dir * -4 * scale, 0);
    ctx.lineTo(dir * -12 * scale, 10 * scale);
    ctx.lineTo(dir * -8 * scale, 0);
    ctx.fill();

    // Mega-boss: spiky wing protrusions
    if (isMega) {
        ctx.fillStyle = '#aa0000';
        ctx.beginPath();
        ctx.moveTo(dir * -8 * scale, -8 * scale);
        ctx.lineTo(dir * -14 * scale, -14 * scale);
        ctx.lineTo(dir * -10 * scale, -6 * scale);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(dir * -8 * scale, 8 * scale);
        ctx.lineTo(dir * -14 * scale, 14 * scale);
        ctx.lineTo(dir * -10 * scale, 6 * scale);
        ctx.fill();
    }

    // Fuselage gradient (red-orange)
    const fuseGrad = ctx.createLinearGradient(0, -5 * scale, 0, 5 * scale);
    fuseGrad.addColorStop(0, isMega ? '#ff2200' : '#ff6633');
    fuseGrad.addColorStop(0.5, isMega ? '#cc0000' : '#cc4400');
    fuseGrad.addColorStop(1, isMega ? '#880000' : '#882200');
    ctx.fillStyle = fuseGrad;
    ctx.beginPath();
    ctx.moveTo(dir * 12 * scale, 0);
    ctx.lineTo(dir * 6 * scale, -5 * scale);
    ctx.lineTo(dir * -6 * scale, -5 * scale);
    ctx.lineTo(dir * -10 * scale, 0);
    ctx.lineTo(dir * -6 * scale, 5 * scale);
    ctx.lineTo(dir * 6 * scale, 5 * scale);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = isMega ? '#ff4444' : '#cc6633';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.restore(); // end shadowBlur

    // Cockpit
    ctx.fillStyle = '#ff8866';
    ctx.fillRect(dir * 6 * scale, -2 * scale, dir * 4 * scale, 4 * scale);

    // Dual engine glows
    const enginePulse = 0.5 + 0.5 * Math.sin(frameCount * 0.25);
    ctx.fillStyle = `rgba(255, 80, 0, ${0.5 + enginePulse * 0.4})`;
    ctx.beginPath();
    ctx.ellipse(dir * -11 * scale, -2.5 * scale, (3 + enginePulse * 2) * scale, (1.5 + enginePulse) * scale * 0.7, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(dir * -11 * scale, 2.5 * scale, (3 + enginePulse * 2) * scale, (1.5 + enginePulse) * scale * 0.7, 0, 0, Math.PI * 2);
    ctx.fill();

    // Mega-boss: center engine
    if (isMega) {
        ctx.fillStyle = `rgba(255, 200, 50, ${0.4 + enginePulse * 0.5})`;
        ctx.beginPath();
        ctx.ellipse(dir * -12 * scale, 0, (4 + enginePulse * 3) * scale, (2 + enginePulse) * scale * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.restore();

    // HP bar (always visible for boss ships)
    const barW = isMega ? 60 : 40;
    drawHPBar(ctx, b.x - barW / 2, b.y - 12 * scale - 4, barW, 4, b.hp / b.maxHp);
};

const drawEnemyMissile = (ctx, m, frameCount) => {
    const isBoss = m.type === 'BOSS';
    const angle = Math.atan2(m.vy, m.vx);
    const speed = Math.sqrt(m.vx * m.vx + m.vy * m.vy);

    // Exhaust trail
    if (m.trailHistory && m.trailHistory.length > 1) {
        for (let i = 0; i < m.trailHistory.length - 1; i++) {
            const t = m.trailHistory[i];
            const alpha = (i / m.trailHistory.length) * 0.5;
            const width = (i / m.trailHistory.length) * (isBoss ? 4 : 2);
            ctx.strokeStyle = m.color;
            ctx.globalAlpha = alpha;
            ctx.lineWidth = width;
            ctx.beginPath();
            ctx.moveTo(t.x, t.y);
            ctx.lineTo(m.trailHistory[i + 1].x, m.trailHistory[i + 1].y);
            ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
    }

    ctx.save();
    ctx.translate(m.x, m.y);
    ctx.rotate(angle);

    if (m.type === 'NORMAL') {
        // Dart/arrowhead
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.moveTo(6, 0);
        ctx.lineTo(-4, -3);
        ctx.lineTo(-2, 0);
        ctx.lineTo(-4, 3);
        ctx.closePath();
        ctx.fill();
        // Glow dot at tail
        ctx.fillStyle = '#ffaa00';
        ctx.beginPath();
        ctx.arc(-3, 0, 1.5, 0, Math.PI * 2);
        ctx.fill();

    } else if (m.type === 'FAST') {
        // Elongated dart
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.moveTo(8, 0);
        ctx.lineTo(-5, -2.5);
        ctx.lineTo(-3, 0);
        ctx.lineTo(-5, 2.5);
        ctx.closePath();
        ctx.fill();
        // Speed lines
        ctx.strokeStyle = m.color;
        ctx.globalAlpha = 0.4;
        ctx.lineWidth = 1;
        for (let i = 0; i < 3; i++) {
            const y = -3 + i * 3;
            ctx.beginPath();
            ctx.moveTo(-8 - i * 4, y);
            ctx.lineTo(-14 - i * 4, y);
            ctx.stroke();
        }
        ctx.globalAlpha = 1.0;

    } else if (m.type === 'ARMORED') {
        // Larger diamond with inner diamond
        ctx.fillStyle = '#aaaaaa';
        ctx.beginPath();
        ctx.moveTo(7, 0);
        ctx.lineTo(0, -5);
        ctx.lineTo(-7, 0);
        ctx.lineTo(0, 5);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.stroke();
        // Inner diamond
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.moveTo(3, 0);
        ctx.lineTo(0, -2);
        ctx.lineTo(-3, 0);
        ctx.lineTo(0, 2);
        ctx.closePath();
        ctx.fill();
        // Partial shield arc
        ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(0, 0, 7, -0.8, 0.8);
        ctx.stroke();

    } else if (m.type === 'BOSS') {
        // Hexagonal head with pulsing glow
        ctx.save();
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 8 + 4 * Math.sin(frameCount * 0.15);
        ctx.fillStyle = '#cc0000';
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const a = (i / 6) * Math.PI * 2;
            const px = Math.cos(a) * 8;
            const py = Math.sin(a) * 8;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
        // Inner detail
        ctx.fillStyle = '#ff4444';
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const a = (i / 6) * Math.PI * 2;
            const px = Math.cos(a) * 4;
            const py = Math.sin(a) * 4;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();

    } else if (m.type === 'MIRV') {
        // Body
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.moveTo(5, 0);
        ctx.lineTo(-4, -3);
        ctx.lineTo(-4, 3);
        ctx.closePath();
        ctx.fill();
        // 3 warhead circles at nose
        ctx.fillStyle = '#ffcc00';
        const wobble = Math.sin(frameCount * 0.2) * 0.3;
        ctx.beginPath();
        ctx.arc(6, wobble - 2, 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(6, wobble + 2, 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(7, wobble, 1.5, 0, Math.PI * 2);
        ctx.fill();

    } else {
        // Fallback
        ctx.fillStyle = m.color;
        const s = m.size || 4;
        ctx.fillRect(-s / 2, -s / 2, s, s);
    }

    ctx.restore();

    // Boss ember particles spawned in update, not draw

    // HP bar
    if (m.hp < m.maxHp || isBoss) {
        const barW = isBoss ? 40 : 16;
        const barOff = isBoss ? 22 : 12;
        drawHPBar(ctx, m.x - barW / 2, m.y - barOff, barW, isBoss ? 4 : 2, m.hp / m.maxHp);
    }
};

const drawPlayerMissile = (ctx, m) => {
    const angle = Math.atan2(m.vy, m.vx);

    if (m.type === 'FLAK') {
        // Bright dot + trailing circles
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.arc(m.x, m.y, 2.5, 0, Math.PI * 2);
        ctx.fill();
        for (let i = 1; i <= 3; i++) {
            ctx.globalAlpha = 0.6 - i * 0.15;
            ctx.beginPath();
            ctx.arc(m.x - m.vx * i * 0.3, m.y - m.vy * i * 0.3, 2 - i * 0.4, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1.0;

    } else if (m.type === 'SAM') {
        // Elongated diamond oriented along velocity
        ctx.save();
        ctx.translate(m.x, m.y);
        ctx.rotate(angle);
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.moveTo(5, 0);
        ctx.lineTo(0, -2);
        ctx.lineTo(-3, 0);
        ctx.lineTo(0, 2);
        ctx.closePath();
        ctx.fill();
        // Orange exhaust
        ctx.fillStyle = '#ff8800';
        ctx.beginPath();
        ctx.arc(-4, 0, 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Occasional smoke particle (faint)
        if (Math.random() < 0.3) {
            ctx.globalAlpha = 0.2;
            ctx.fillStyle = '#888';
            ctx.beginPath();
            ctx.arc(m.x - m.vx * 2 + (Math.random() - 0.5) * 3, m.y - m.vy * 2 + (Math.random() - 0.5) * 3, 1, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }

    } else if (m.type === 'ARTILLERY') {
        // Larger circle with orange-white trail
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(m.x, m.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.arc(m.x, m.y, 2, 0, Math.PI * 2);
        ctx.fill();
        // Trail
        for (let i = 1; i <= 4; i++) {
            ctx.globalAlpha = 0.5 - i * 0.1;
            ctx.fillStyle = i < 2 ? '#ffaa44' : '#ff6600';
            ctx.beginPath();
            ctx.arc(m.x - m.vx * i * 0.25, m.y - m.vy * i * 0.25, 2.5 - i * 0.4, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1.0;

    } else {
        // Default
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.arc(m.x, m.y, 2, 0, Math.PI * 2);
        ctx.fill();
    }
};

const drawLaserBeam = (ctx, l) => {
    const w = l.width || 2;
    const alpha = Math.min(1, l.life / 3);

    // Outer glow
    ctx.save();
    ctx.shadowColor = l.color;
    ctx.shadowBlur = 8;
    ctx.strokeStyle = l.color;
    ctx.lineWidth = w + 2;
    ctx.globalAlpha = alpha * 0.6;
    ctx.beginPath();
    ctx.moveTo(l.x1, l.y1);
    ctx.lineTo(l.x2, l.y2);
    ctx.stroke();
    ctx.restore();

    // Main beam
    ctx.strokeStyle = l.color;
    ctx.lineWidth = w + 1;
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.moveTo(l.x1, l.y1);
    ctx.lineTo(l.x2, l.y2);
    ctx.stroke();

    // Core white
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = Math.max(1, w - 1);
    ctx.beginPath();
    ctx.moveTo(l.x1, l.y1);
    ctx.lineTo(l.x2, l.y2);
    ctx.stroke();

    // Energy crackle - 3 random fork lines
    if (w > 2) {
        ctx.strokeStyle = l.color;
        ctx.lineWidth = 1;
        ctx.globalAlpha = alpha * 0.5;
        const dx = l.x2 - l.x1;
        const dy = l.y2 - l.y1;
        const len = Math.sqrt(dx * dx + dy * dy);
        const nx = -dy / len;
        const ny = dx / len;
        for (let i = 0; i < 3; i++) {
            const t = 0.2 + Math.random() * 0.6;
            const mx = l.x1 + dx * t;
            const my = l.y1 + dy * t;
            const forkLen = (4 + Math.random() * 8) * (Math.random() > 0.5 ? 1 : -1);
            ctx.beginPath();
            ctx.moveTo(mx, my);
            ctx.lineTo(mx + nx * forkLen, my + ny * forkLen);
            ctx.stroke();
        }
    }

    // Impact point glow
    ctx.globalAlpha = alpha * 0.8;
    const impactGrad = ctx.createRadialGradient(l.x2, l.y2, 0, l.x2, l.y2, 6 + w);
    impactGrad.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
    impactGrad.addColorStop(0.5, l.color);
    impactGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = impactGrad;
    ctx.beginPath();
    ctx.arc(l.x2, l.y2, 6 + w, 0, Math.PI * 2);
    ctx.fill();

    ctx.globalAlpha = 1.0;
};

const drawExplosion = (ctx, ex) => {
    if (ex.radius < 1) return;

    // Filled radial gradient
    const pct = ex.growing ? (ex.radius / ex.maxRadius) : (ex.radius / ex.maxRadius);
    const grad = ctx.createRadialGradient(ex.x, ex.y, 0, ex.x, ex.y, ex.radius);

    // Parse color for secondary
    const isWhite = ex.color === '#fff' || ex.color === '#ffffff';
    const primaryColor = ex.color;

    if (ex.growing) {
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.3, primaryColor);
        grad.addColorStop(0.7, isWhite ? 'rgba(255, 200, 100, 0.4)' : primaryColor);
        grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    } else {
        const fadeAlpha = Math.max(0, ex.radius / ex.maxRadius);
        grad.addColorStop(0, primaryColor);
        grad.addColorStop(0.5, `rgba(255, 100, 0, ${fadeAlpha * 0.5})`);
        grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    }

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(ex.x, ex.y, ex.radius, 0, Math.PI * 2);
    ctx.fill();

    // Hot white core during growing
    if (ex.growing && ex.radius > 3) {
        ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * (1 - ex.radius / ex.maxRadius)})`;
        ctx.beginPath();
        ctx.arc(ex.x, ex.y, ex.radius * 0.3, 0, Math.PI * 2);
        ctx.fill();
    }

    // Shockwave ring
    if (ex.shockwaveRadius > 0 && ex.shockwaveRadius < ex.maxRadius * 2.5) {
        ctx.strokeStyle = `rgba(255, 255, 255, ${0.15 * (1 - ex.shockwaveRadius / (ex.maxRadius * 2.5))})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(ex.x, ex.y, ex.shockwaveRadius, 0, Math.PI * 2);
        ctx.stroke();
    }

    // Outline ring
    ctx.strokeStyle = primaryColor;
    ctx.globalAlpha = 0.4;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(ex.x, ex.y, ex.radius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1.0;
};

const drawParticle = (ctx, p) => {
    const lifeRatio = p.life / p.maxLife;
    const alpha = lifeRatio;
    const size = (p.size || 2) * lifeRatio;
    if (size < 0.3) return;

    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;

    // Trail: dim copy at previous position
    if (p.vx !== 0 || p.vy !== 0) {
        ctx.globalAlpha = alpha * 0.3;
        const prevSize = size * 0.7;
        if (p.shape === 'circle') {
            ctx.beginPath();
            ctx.arc(p.x - p.vx, p.y - p.vy, prevSize / 2, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.fillRect(p.x - p.vx - prevSize / 2, p.y - p.vy - prevSize / 2, prevSize, prevSize);
        }
        ctx.globalAlpha = alpha;
    }

    if (p.shape === 'circle') {
        ctx.beginPath();
        ctx.arc(p.x, p.y, size / 2, 0, Math.PI * 2);
        ctx.fill();
    } else {
        ctx.fillRect(p.x - size / 2, p.y - size / 2, size, size);
    }

    ctx.globalAlpha = 1.0;
};

const drawHPBar = (ctx, x, y, w, h, pct) => {
    pct = Math.max(0, Math.min(1, pct));
    // Border
    ctx.fillStyle = '#111';
    ctx.fillRect(x - 1, y - 1, w + 2, h + 2);
    // Background
    ctx.fillStyle = '#330000';
    ctx.fillRect(x, y, w, h);
    // Fill - color shifts green->yellow->red
    let barColor;
    if (pct > 0.6) barColor = '#00ff00';
    else if (pct > 0.3) barColor = '#ffff00';
    else barColor = '#ff0000';
    ctx.fillStyle = barColor;
    ctx.fillRect(x, y, w * pct, h);
};

// ============================================================

const App = () => {
  const canvasRef = useRef(null);
  const requestRef = useRef();

  // Game State
  const [gameState, setGameState] = useState('START');
  const [money, setMoney] = useState(3500);
  const [score, setScore] = useState(0);
  const [level, setLevel] = useState(1);
  const [message, setMessage] = useState('');
  const [bonusReport, setBonusReport] = useState(null);

  // Entities
  const [cities, setCities] = useState([]);
  const turrets = useRef([]);

  // Refs
  const enemyMissiles = useRef([]);
  const bombers = useRef([]);
  const playerMissiles = useRef([]);
  const lasers = useRef([]);
  const explosions = useRef([]);
  const particles = useRef([]);
  const terrain = useRef([]);
  const mousePos = useRef({ x: 0, y: 0 });
  const blinkTimer = useRef(0);
  const frameCount = useRef(0);
  const screenShake = useRef(0);
  const mapData = useRef({ stars: [], bgTerrain: [], vegetation: [] });

  // Placement State
  const [selectedAction, setSelectedAction] = useState(null);
  const [hoveredTurret, setHoveredTurret] = useState(null);

  // Level Config
  const levelConfig = useRef({
    spawnTimer: 0,
    spawnInterval: 100,
    totalToSpawn: 0,
    bomberTimer: 0
  });
  const waveCompleted = useRef(false);

  // --- City Building Generator ---
  const TIER_CONFIG = [
      null, // index 0 unused
      { buildings: [4, 8], heightScale: 1.0, spread: 35, antennaChance: 0.2, gradTop: '#00cccc', gradBot: '#005566', glowColor: [0, 180, 180], glowRadius: 60, glowAlpha: 0.08, styles: ['flat', 'pointed'] },
      { buildings: [6, 10], heightScale: 1.3, spread: 40, antennaChance: 0.3, gradTop: '#00eeff', gradBot: '#006677', glowColor: [0, 220, 220], glowRadius: 70, glowAlpha: 0.10, styles: ['flat', 'pointed', 'stepped'] },
      { buildings: [8, 12], heightScale: 1.6, spread: 45, antennaChance: 0.4, gradTop: '#aaddff', gradBot: '#2255aa', glowColor: [100, 180, 255], glowRadius: 80, glowAlpha: 0.12, styles: ['flat', 'pointed', 'stepped', 'dome'] },
      { buildings: [10, 14], heightScale: 1.9, spread: 50, antennaChance: 0.5, gradTop: '#cc88ff', gradBot: '#3322aa', glowColor: [160, 100, 255], glowRadius: 90, glowAlpha: 0.14, styles: ['pointed', 'stepped', 'dome'] },
      { buildings: [12, 16], heightScale: 2.2, spread: 55, antennaChance: 0.6, gradTop: '#ffdd66', gradBot: '#aa6600', glowColor: [255, 200, 80], glowRadius: 100, glowAlpha: 0.16, styles: ['pointed', 'stepped', 'dome'] },
  ];

  const generateCityBuildings = (tier) => {
      const cfg = TIER_CONFIG[Math.min(tier, 5)];
      const buildings = [];
      const count = cfg.buildings[0] + Math.floor(Math.random() * (cfg.buildings[1] - cfg.buildings[0]));
      for (let b = 0; b < count; b++) {
          const bw = (6 + Math.random() * 12) * cfg.heightScale;
          const bh = (15 + Math.random() * 25) * cfg.heightScale;
          const style = cfg.styles[Math.floor(Math.random() * cfg.styles.length)];
          const windows = [];
          const cols = Math.max(1, Math.floor(bw / 4));
          const rows = Math.max(1, Math.floor(bh / 6));
          for (let wy = 0; wy < rows; wy++) {
              for (let wx = 0; wx < cols; wx++) {
                  windows.push({
                      ox: 2 + wx * (bw / cols),
                      oy: 3 + wy * (bh / rows),
                      phase: Math.floor(Math.random() * 10)
                  });
              }
          }
          buildings.push({
              w: bw,
              h: bh,
              xOffset: (Math.random() - 0.5) * cfg.spread,
              style,
              windows,
              hasAntenna: bh > 20 && Math.random() < cfg.antennaChance
          });
      }
      return buildings;
  };

  // --- Map Generation ---
  const generateMap = useCallback((numCities, lvl = 1) => {
    const points = [];
    const segments = 80;
    const segmentWidth = GAME_WIDTH / segments;
    const citySlots = [];
    const padding = 80;
    const availableWidth = GAME_WIDTH - (padding * 2);
    const spacing = availableWidth / (numCities - 1 || 1);

    for (let i = 0; i < numCities; i++) {
        const jitter = (Math.random() - 0.5) * 60;
        let cx = padding + (i * spacing) + jitter;
        cx = Math.max(50, Math.min(GAME_WIDTH - 50, cx));
        citySlots.push({ x: cx, w: 40 });
    }

    for(let i=0; i<=segments; i++) {
        const x = i * segmentWidth;
        let distToCity = Infinity;
        citySlots.forEach(slot => {
            const d = Math.abs(x - slot.x);
            if (d < distToCity) distToCity = d;
        });

        let height = 0;
        if (distToCity < 50) {
            height = 20;
        } else {
            const blend = Math.min(1, (distToCity - 50) / 80);
            const noise = Math.random() * 40;
            const mountainHeight = 120 + (Math.sin(i * 0.3) * 80) + (Math.cos(i * 1.5) * 20) + noise;
            height = 20 + (mountainHeight * blend);
        }
        points.push({ x: x, y: GAME_HEIGHT - height });
    }
    terrain.current = points;

    // Generate stars
    const stars = [];
    for (let i = 0; i < 100; i++) {
        stars.push({
            x: Math.random() * GAME_WIDTH,
            y: Math.random() * (GAME_HEIGHT * 0.6),
            brightness: 0.3 + Math.random() * 0.7,
            twinklePhase: Math.random() * Math.PI * 2,
            size: Math.random() > 0.7 ? 2 : 1,
            color: Math.random() > 0.8 ? '#aaccff' : '#ffffff'
        });
    }

    // Generate background mountains
    const bgTerrain = [];
    for (let i = 0; i <= segments; i++) {
        const x = i * segmentWidth;
        const noise = Math.random() * 20;
        const bgHeight = 80 + (Math.sin(i * 0.2 + 1) * 50) + (Math.cos(i * 0.8 + 2) * 30) + noise;
        bgTerrain.push({ x, y: GAME_HEIGHT - bgHeight });
    }

    // Generate vegetation along flat segments
    const vegetation = [];
    for (let i = 0; i < points.length - 1; i++) {
        const p1 = points[i];
        const p2 = points[i + 1];
        const slope = Math.abs(p2.y - p1.y) / (p2.x - p1.x || 1);
        if (slope < 0.3 && p1.y > GAME_HEIGHT - 100) {
            const count = Math.floor(Math.random() * 3);
            for (let v = 0; v < count; v++) {
                const vx = p1.x + (p2.x - p1.x) * Math.random();
                const vy = p1.y + (p2.y - p1.y) * Math.random();
                vegetation.push({
                    x: vx,
                    y: vy,
                    h: 2 + Math.random() * 4,
                    color: ['#004400', '#006600', '#003300', '#005500'][Math.floor(Math.random() * 4)]
                });
            }
        }
    }

    mapData.current = { stars, bgTerrain, vegetation };

    const newCities = citySlots.map(slot => {
        const cy = getTerrainHeight(slot.x, points);
        return { x: slot.x, y: cy, active: true, hp: 3, maxHp: 3, tier: 1, wavesSurvived: 0, buildings: generateCityBuildings(1) };
    });
    setCities(newCities);
    return points;
  }, []);

  const getTerrainHeight = (x, terrainPoints) => {
      if (!terrainPoints || terrainPoints.length === 0) return GAME_HEIGHT;
      if (typeof x !== 'number' || isNaN(x)) return GAME_HEIGHT;
      const segmentWidth = GAME_WIDTH / (terrainPoints.length - 1);
      const index = Math.floor(x / segmentWidth);
      if (index < 0 || index >= terrainPoints.length - 1) return GAME_HEIGHT;
      const p1 = terrainPoints[index];
      const p2 = terrainPoints[index+1];
      if (!p1 || !p2) return GAME_HEIGHT;
      const ratio = (x - p1.x) / (p2.x - p1.x);
      return p1.y + (p2.y - p1.y) * ratio;
  };

  // --- Initialization ---
  const initGame = useCallback(() => {
    initAudio();
    setMoney(3500);
    setScore(0);
    setLevel(1);
    setGameState('PLACEMENT');
    setMessage('Commander, hostile forces inbound.');
    turrets.current = [];
    resetEntities();
    generateMap(3);
    setupLevel(1);
  }, [generateMap]);

  const setupLevel = (lvl) => {
    levelConfig.current = {
        spawnTimer: 0,
        spawnInterval: Math.max(15, 90 - (lvl * 3)),
        totalToSpawn: 12 + (lvl * 4),
        bomberTimer: 0,
        isBossWave: lvl % 5 === 0 && lvl > 0,
        isMegaBossWave: lvl % 10 === 0 && lvl > 0
    };
  };

  const resetEntities = () => {
    enemyMissiles.current = [];
    bombers.current = [];
    playerMissiles.current = [];
    lasers.current = [];
    explosions.current = [];
    particles.current = [];
  };

  const startWave = () => {
      const cfg = levelConfig.current;
      if (turrets.current.length === 0) {
          setMessage("WARNING: NO DEFENSES PLACED");
          setTimeout(() => setMessage(`WAVE ${level} INBOUND`), 2000);
      } else if (cfg.isMegaBossWave) {
          setMessage(`ALERT: MEGA BOSS INBOUND`);
          Sound.bossWarning();
      } else if (cfg.isBossWave) {
          setMessage(`WARNING: BOSS INBOUND`);
          Sound.bossWarning();
      } else {
          setMessage(`WAVE ${level} ENGAGING`);
          Sound.waveStart();
      }
      // Spawn boss ship on boss waves
      if (cfg.isMegaBossWave) {
          spawnBossShip(2);
      } else if (cfg.isBossWave) {
          spawnBossShip(1);
      }
      waveCompleted.current = false;
      setGameState('PLAYING');
      setSelectedAction(null);
  };

  // --- Game Loop ---
  const update = useCallback(() => {
    frameCount.current++;

    if (gameState === 'PLAYING') {
        const cfg = levelConfig.current;
        cfg.spawnTimer++;
        cfg.bomberTimer++;

        // Spawn Logic
        if (cfg.totalToSpawn > 0 && cfg.spawnTimer > cfg.spawnInterval) {
            spawnEnemyMissile();
            cfg.spawnTimer = 0;
            cfg.totalToSpawn--;
        }

        if (level >= 3 && cfg.bomberTimer > 500 && Math.random() < 0.25) {
            spawnBomber();
            cfg.bomberTimer = 0;
        }

        // Turret Logic
        turrets.current.forEach(turret => {
            turret.lastFired++;

            // Decay recoil
            if (turret.recoilOffset > 0) turret.recoilOffset *= 0.7;
            if (turret.recoilOffset < 0.1) turret.recoilOffset = 0;

            // Decay FLAK heat
            if (turret.type === 'FLAK' && turret.heat > 0) {
                turret.heat = Math.max(0, turret.heat - 0.3);
            }

            // Decay muzzle flash
            if (turret.muzzleFlashTimer > 0) turret.muzzleFlashTimer--;

            let target = null;
            let minDist = turret.stats.range;

            const allTargets = [...bombers.current, ...enemyMissiles.current];

            // Laser turrets prefer their current target for beam continuity
            if (turret.type === 'LASER' && turret.laserTarget) {
                const cur = allTargets.find(m => m.id === turret.laserTarget);
                if (cur && cur.active && distance(turret.x, turret.y, cur.x, cur.y) < turret.stats.range) {
                    target = cur;
                }
            }

            if (!target) {
                allTargets.forEach(m => {
                    if (!m.active) return;
                    let d = distance(turret.x, turret.y, m.x, m.y);
                    if (d < minDist) {
                        minDist = d;
                        target = m;
                    }
                });
            }

            // Track target angle
            if (target) {
                const targetAngle = Math.atan2(target.y - turret.y, target.x - turret.x) - Math.PI / 2;
                const angleDiff = targetAngle - (turret.angle || -Math.PI / 2);
                turret.angle = (turret.angle || -Math.PI / 2) + angleDiff * 0.15;
            }

            if (turret.type === 'LASER') {
                if (target) {
                    if (turret.laserTarget === target.id) {
                        turret.dwellTime = (turret.dwellTime || 0) + 1;
                    } else {
                        turret.laserTarget = target.id;
                        turret.dwellTime = 0;
                    }
                    if (turret.lastFired >= turret.stats.fireRate) {
                        fireTurret(turret, target);
                        turret.lastFired = 0;
                    }
                } else {
                    turret.laserTarget = null;
                    turret.dwellTime = 0;
                }
            } else if (target && turret.lastFired >= turret.stats.fireRate) {
                fireTurret(turret, target);
                turret.lastFired = 0;
            }
        });

        updateEnemyMissiles();
        updateBombers();
        updatePlayerMissiles();
        updateLasers();
        updateExplosions();
        updateParticles();

        // Decay screen shake
        if (screenShake.current > 0) screenShake.current *= 0.85;
        if (screenShake.current < 0.2) screenShake.current = 0;

        if (!waveCompleted.current && cfg.totalToSpawn === 0 && enemyMissiles.current.length === 0 && bombers.current.length === 0 && explosions.current.length === 0) {
            waveCompleted.current = true;
            handleWaveComplete();
        }

        if (cities.filter(c => c.active).length === 0) {
            setGameState('GAME_OVER');
            Sound.gameOver();
        }
    } else {
        updateParticles();
        updateExplosions();
        blinkTimer.current++;
        frameCount.current++;
    }
  }, [gameState, cities, level]);

  const handleWaveComplete = () => {
      const levelMult = 1 + (level - 1) * 0.15;
      const baseBonus = Math.round(WAVE_COMPLETE_BONUS * levelMult);
      const cityBonus = cities.filter(c => c.active).length * Math.round(500 * levelMult);
      const totalBonus = baseBonus + cityBonus;

      // Evolve cities
      let evolvedCount = 0;
      const evolvedCities = cities.map(c => {
          if (!c.active) return c;
          const ws = (c.wavesSurvived || 0) + 1;
          const newHp = Math.min((c.hp || 1) + 1, c.maxHp || 3);
          let tier = c.tier || 1;
          let maxHp = c.maxHp || 3;
          let buildings = c.buildings;
          if (ws % 3 === 0 && tier < 5) {
              tier++;
              maxHp += 2;
              buildings = generateCityBuildings(tier);
              evolvedCount++;
              createParticles(c.x, c.y, '#0ff', 12);
          }
          return { ...c, wavesSurvived: ws, hp: Math.min(newHp, maxHp), maxHp, tier, buildings };
      });
      setCities(evolvedCities);

      setBonusReport({
          wave: level,
          base: baseBonus,
          cityCount: cities.filter(c => c.active).length,
          cityBonus: cityBonus,
          total: totalBonus,
          evolvedCount
      });

      setMoney(prev => prev + totalBonus);
      setGameState('LEVEL_COMPLETE');
  };

  const findMountainPeaks = (terrainPoints, count) => {
      const candidates = terrainPoints
          .filter((p, i) => i > 5 && i < terrainPoints.length - 5)
          .map(p => ({ x: p.x, y: p.y }))
          .sort((a, b) => a.y - b.y);
      const peaks = [];
      for (const c of candidates) {
          if (peaks.every(p => Math.abs(p.x - c.x) > 60)) {
              peaks.push(c);
              if (peaks.length >= count) break;
          }
      }
      return peaks;
  };

  const advanceLevel = () => {
      const nextLvl = level + 1;
      setLevel(nextLvl);
      const nextCities = Math.max(2, 3 - Math.floor(nextLvl / 8));

      // Preserve city state (sorted by tier desc so highest-tier states survive city count reduction)
      const savedState = cities
          .filter(c => c.active)
          .sort((a, b) => (b.tier || 1) - (a.tier || 1))
          .map(c => ({ tier: c.tier || 1, hp: c.hp || 3, maxHp: c.maxHp || 3, wavesSurvived: c.wavesSurvived || 0 }));

      const newTerrainPoints = generateMap(nextCities, nextLvl);

      // Apply saved state to new cities
      const restoredCities = cities.map((c, i) => {
          if (i < savedState.length) {
              const s = savedState[i];
              return { ...c, tier: s.tier, hp: s.hp, maxHp: s.maxHp, wavesSurvived: s.wavesSurvived, buildings: generateCityBuildings(s.tier) };
          }
          return c;
      });
      setCities(restoredCities);

      const peaks = findMountainPeaks(newTerrainPoints, turrets.current.length);
      turrets.current.forEach((t, i) => {
          if (peaks[i]) {
              t.x = peaks[i].x;
              t.y = peaks[i].y - 10;
          } else {
              const newY = getTerrainHeight(t.x, newTerrainPoints);
              t.y = newY - 10;
          }
          createParticles(t.x, t.y, '#00ff00');
      });

      resetEntities();
      setupLevel(nextLvl);

      setGameState('LEVEL_START');
      setTimeout(() => {
          setGameState('PLACEMENT');
          setMessage('DEFENSES RELOCATED. PREPARE FOR BATTLE.');
      }, 3000);
  };

  // --- Logic Helpers ---
  const applyDamage = (enemy, damage) => {
      if (!enemy.active || enemy.hp <= 0) return;
      enemy.hp -= damage;
      if (enemy.hp <= 0) {
          enemy.active = false;
          const levelMult = 1 + (level - 1) * 0.15;
          let reward = Math.round(50 * levelMult);
          let scoreReward = Math.round(100 * levelMult);
          if (enemy.type === 'BOSS_SHIP') {
              const isMega = enemy.bossTier >= 2;
              reward = Math.round((isMega ? 3000 : 1500) * levelMult);
              scoreReward = Math.round((isMega ? 10000 : 5000) * levelMult);
          }
          else if (enemy.type === 'BOSS') { reward = Math.round(800 * levelMult); scoreReward = Math.round(2000 * levelMult); }
          if (enemy.type === 'ARMORED') { reward = Math.round(100 * levelMult); scoreReward = Math.round(300 * levelMult); }

          setMoney(m => m + reward);
          setScore(s => s + scoreReward);

          const deathRadius = enemy.type === 'BOSS_SHIP' ? (enemy.bossTier >= 2 ? 150 : 100) : (enemy.type === 'BOSS' ? 80 : 30);
          createExplosion(enemy.x, enemy.y, true, deathRadius);
          createParticles(enemy.x, enemy.y, enemy.color);
      } else {
          if (frameCount.current - lastEnemyHitFrame >= 5) {
              Sound.enemyHit();
              lastEnemyHitFrame = frameCount.current;
          }
          createParticles(enemy.x, enemy.y, '#fff', 2);
      }
  };

  const fireTurret = (turret, target) => {
      if (turret.type === 'LASER') {
          const dist = distance(turret.x, turret.y, target.x, target.y);
          const distFalloff = Math.max(0.2, 1 - (dist / turret.stats.range) * 0.8);
          const dwellBonus = 1 + Math.min((turret.dwellTime || 0) / 30, 5);
          const finalDamage = turret.stats.damage * distFalloff * dwellBonus;
          const beamWidth = Math.min(1 + (turret.dwellTime || 0) / 15, 6);
          lasers.current.push({
              x1: turret.x, y1: turret.y,
              x2: target.x, y2: target.y,
              color: turret.stats.projectileColor,
              life: turret.stats.fireRate,
              width: beamWidth
          });
          if ((turret.dwellTime || 0) > 10) {
              createParticles(target.x, target.y, '#ff00ff', 1);
          }
          Sound.laserBeam(turret.dwellTime);
          applyDamage(target, finalDamage);
          return;
      }

      // Trigger recoil and muzzle flash
      turret.recoilOffset = turret.type === 'ARTILLERY' ? 6 : 4;
      turret.muzzleFlashTimer = turret.type === 'ARTILLERY' ? 8 : 5;
      Sound.turretFire(turret.type);

      if (turret.type === 'SAM') {
           playerMissiles.current.push({
              x: turret.x,
              y: turret.y,
              vx: 0,
              vy: -SAM_SPEED,
              targetId: target.id,
              active: true,
              type: 'SAM',
              color: turret.stats.projectileColor,
              damage: turret.stats.damage,
              explosionRadius: turret.stats.explosionRadius
          });
          return;
      }

      const dist = distance(turret.x, turret.y, target.x, target.y);
      const timeToHit = dist / PLAYER_PROJECTILE_SPEED;
      const predX = target.x + (target.vx * timeToHit);
      const predY = target.y + (target.vy * timeToHit);
      let angle = Math.atan2(predY - turret.y, predX - turret.x);

      // FLAK: inaccuracy that worsens with heat
      if (turret.type === 'FLAK') {
          const heat = turret.heat || 0;
          const spread = 0.12 + heat * 0.006;
          angle += (Math.random() - 0.5) * spread;
          turret.heat = Math.min((turret.heat || 0) + 2, 30);
      }

      playerMissiles.current.push({
          x: turret.x,
          y: turret.y,
          vx: Math.cos(angle) * PLAYER_PROJECTILE_SPEED,
          vy: Math.sin(angle) * PLAYER_PROJECTILE_SPEED,
          targetX: predX,
          targetY: predY,
          active: true,
          type: turret.type,
          color: turret.stats.projectileColor,
          damage: turret.stats.damage,
          explosionRadius: turret.stats.explosionRadius
      });
  };

  const spawnEnemyMissile = (originX = null, originY = null, isBomblet = false) => {
    const startX = originX ?? Math.random() * GAME_WIDTH;
    const startY = originY ?? 0;

    const validCities = cities.filter(c => c.active);
    if (validCities.length === 0) return;
    const targetCity = validCities[Math.floor(Math.random() * validCities.length)];

    const angle = Math.atan2(targetCity.y - startY, targetCity.x - startX);

    let type = 'NORMAL';
    let speed = 0.8 + (level * 0.08);
    let color = '#ff0000';
    let maxHp = HP_NORMAL;
    let size = 4;
    let canSplit = false;

    if (!isBomblet) {
        const rand = Math.random();

        if (level >= 5 && rand < 0.05) {
            type = 'BOSS';
            speed = 0.4;
            maxHp = HP_BOSS_BASE + (level * 50);
            size = 15;
            color = '#ff0000';
        }
        else if (level >= 7 && rand < 0.2) {
            type = 'MIRV'; canSplit = true; color = '#ffaa00'; maxHp = HP_NORMAL * 2;
        }
        else if (level >= 4 && rand < 0.3) {
            type = 'ARMORED';
            speed *= 1.1;
            maxHp = HP_ARMORED;
            size = 6;
            color = '#ffffff';
        }
        else if (level >= 3 && rand < 0.45) {
            type = 'FAST';
            speed = 2.2 + (level * 0.1);
            color = '#bd00ff';
            maxHp = HP_FAST;
        }
    }

    enemyMissiles.current.push({
        id: Math.random().toString(36),
        x: startX,
        y: startY,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        active: true,
        type,
        color,
        maxHp,
        hp: maxHp,
        size,
        canSplit,
        trailHistory: []
    });
  };

  const spawnBomber = () => {
      const fromLeft = Math.random() > 0.5;
      const y = 50 + Math.random() * 80;
      bombers.current.push({
          id: Math.random().toString(36),
          x: fromLeft ? -50 : GAME_WIDTH + 50,
          y: y,
          vx: fromLeft ? 1.2 : -1.2,
          active: true,
          type: 'BOMBER',
          maxHp: 60,
          hp: 60,
          color: '#ffff00',
          size: 10,
          lastDrop: 0,
          dropInterval: 50,
          dropChance: 0.03
      });
  };

  const spawnBossShip = (tier) => {
      const fromLeft = Math.random() > 0.5;
      const y = 40 + Math.random() * 50;
      const isMega = tier >= 2;
      const bossHp = isMega ? 1500 + level * 100 : 750 + level * 60;
      bombers.current.push({
          id: Math.random().toString(36),
          x: fromLeft ? -80 : GAME_WIDTH + 80,
          y: y,
          vx: fromLeft ? (isMega ? 0.6 : 0.8) : (isMega ? -0.6 : -0.8),
          active: true,
          type: 'BOSS_SHIP',
          maxHp: bossHp,
          hp: bossHp,
          color: '#ff4400',
          size: isMega ? 25 : 18,
          lastDrop: 0,
          dropInterval: isMega ? 18 : 25,
          dropChance: isMega ? 0.10 : 0.06,
          isBossShip: true,
          bossTier: tier,
          escortsSpawned: false
      });
  };

  const updateBombers = () => {
      bombers.current.forEach(b => {
          if (!b.active) return;
          b.x += b.vx;
          b.lastDrop++;
          if (b.lastDrop > (b.dropInterval || 50) && Math.random() < (b.dropChance || 0.03)) {
              spawnEnemyMissile(b.x, b.y, true);
              b.lastDrop = 0;
          }

          // Mega-boss escort spawning
          if (b.bossTier >= 2 && !b.escortsSpawned && b.x > 200 && b.x < 600) {
              b.escortsSpawned = true;
              spawnBomber();
              spawnBomber();
          }

          if (b.x < -100 || b.x > GAME_WIDTH + 100) b.active = false;

          for (let ex of explosions.current) {
            if (!b.active) break;
            if (distance(b.x, b.y, ex.x, ex.y) < ex.radius) {
                applyDamage(b, 2);
            }
          }
      });
      bombers.current = bombers.current.filter(b => b.active);
  };

  const updateEnemyMissiles = () => {
    enemyMissiles.current.forEach(m => {
        if (!m.active) return;
        m.x += m.vx;
        m.y += m.vy;

        // Update trail history
        if (m.trailHistory) {
            m.trailHistory.push({ x: m.x, y: m.y });
            if (m.trailHistory.length > 8) m.trailHistory.shift();
        }

        // Boss ember particles
        if (m.type === 'BOSS' && Math.random() < 0.3) {
            const room = 500 - particles.current.length;
            if (room > 0) {
                particles.current.push({
                    x: m.x - m.vx * 5 + (Math.random() - 0.5) * 8,
                    y: m.y - m.vy * 5 + (Math.random() - 0.5) * 8,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    color: Math.random() > 0.5 ? '#ff4400' : '#ff8800',
                    life: 10 + Math.random() * 10,
                    maxLife: 20,
                    size: 1 + Math.random() * 2,
                    shape: Math.random() > 0.5 ? 'circle' : 'square'
                });
            }
        }

        if (m.type === 'MIRV' && m.canSplit && m.y > 150 && Math.random() < 0.02) {
            m.active = false;
            createExplosion(m.x, m.y);
            spawnEnemyMissile(m.x, m.y, true);
            spawnEnemyMissile(m.x, m.y, true);
            spawnEnemyMissile(m.x, m.y, true);
            return;
        }

        const groundY = getTerrainHeight(m.x, terrain.current);
        if (m.y >= groundY) {
            m.active = false;
            createExplosion(m.x, m.y);
            checkCityDamage(m.x, m.y);
        }

        for (let ex of explosions.current) {
            if (!m.active) break;
            if (distance(m.x, m.y, ex.x, ex.y) < ex.radius) {
                applyDamage(m, 2);
            }
        }
    });
    enemyMissiles.current = enemyMissiles.current.filter(m => m.active);
  };

  const updatePlayerMissiles = () => {
    playerMissiles.current.forEach(m => {
        if (!m.active) return;

        if (m.type === 'SAM' && m.targetId) {
             const target = [...enemyMissiles.current, ...bombers.current].find(e => e.id === m.targetId);
             if (target && target.active) {
                 const angle = Math.atan2(target.y - m.y, target.x - m.x);
                 m.vx = Math.cos(angle) * SAM_SPEED;
                 m.vy = Math.sin(angle) * SAM_SPEED;
             }
        }

        m.x += m.vx;
        m.y += m.vy;

        let detonated = false;

        if (m.type === 'SAM') {
             const target = [...enemyMissiles.current, ...bombers.current].find(e => e.id === m.targetId);
             if (target && target.active && distance(m.x, m.y, target.x, target.y) < 15) {
                 detonated = true;
             }
        }
        else {
            const dist = distance(m.x, m.y, m.targetX, m.targetY);
            if (dist < PLAYER_PROJECTILE_SPEED) {
                detonated = true;
            }
        }

        const groundY = getTerrainHeight(m.x, terrain.current);
        if (m.y > groundY || m.y < 0 || m.x < 0 || m.x > GAME_WIDTH) {
            detonated = true;
        }

        if (detonated) {
            m.active = false;
            createExplosion(m.x, m.y, false, m.explosionRadius, m.color);

            const targets = [...enemyMissiles.current, ...bombers.current];
            targets.forEach(t => {
                if (t.active && distance(m.x, m.y, t.x, t.y) < m.explosionRadius) {
                    applyDamage(t, m.damage);
                }
            });
        }
    });
    playerMissiles.current = playerMissiles.current.filter(m => m.active);
  };

  const updateLasers = () => {
      lasers.current.forEach(l => l.life--);
      lasers.current = lasers.current.filter(l => l.life > 0);
  };

  const checkCityDamage = (x, y) => {
      let changed = false;
      let destroyed = false;
      const newCities = cities.map(c => {
          if (c.active && distance(x, y, c.x, c.y) < 55) {
              const newHp = c.hp - 1;
              createParticles(c.x, c.y, '#f00');
              changed = true;
              if (newHp <= 0) {
                  destroyed = true;
                  return { ...c, hp: 0, active: false };
              }
              return { ...c, hp: newHp };
          }
          return c;
      });

      if (changed) {
          setCities(newCities);
          if (destroyed) {
              Sound.cityDestroyed();
              setMoney(m => Math.max(0, m - CITY_REPAIR_PENALTY));
              setMessage('CRITICAL: CITY DESTROYED');
          } else {
              Sound.enemyHit();
              const hit = newCities.find(c => c.active && distance(x, y, c.x, c.y) < 55);
              if (hit) setMessage(`CITY HIT — SHIELDS ${hit.hp}/${hit.maxHp}`);
          }
      }
  };

  const updateExplosions = () => {
    explosions.current.forEach(ex => {
        if (!ex.active) return;
        // Update shockwave
        if (ex.shockwaveRadius !== undefined) {
            ex.shockwaveRadius += 3;
        }
        if (ex.growing) {
            ex.radius += EXPLOSION_GROWTH;
            if (ex.radius >= ex.maxRadius) ex.growing = false;
        } else {
            ex.radius -= EXPLOSION_GROWTH * 0.5;
            if (ex.radius <= 0) ex.active = false;
        }
    });
    explosions.current = explosions.current.filter(ex => ex.active);
  };

  const updateParticles = () => {
      particles.current.forEach(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.life--;
      });
      particles.current = particles.current.filter(p => p.life > 0);
  };

  const createExplosion = (x, y, isChain = false, maxRadius = 30, color = null) => {
      if (explosions.current.length >= 50) return;
      const mr = isChain ? 25 : maxRadius;
      if (mr > 10) Sound.explosion(mr);
      explosions.current.push({
          x, y,
          radius: 1,
          maxRadius: mr,
          growing: true,
          active: true,
          color: color || (isChain ? '#ffaa00' : '#fff'),
          shockwaveRadius: 0,
          screenShakeAmount: mr > 50 ? 4 : mr > 30 ? 2 : 0
      });
      // Screen shake for large explosions
      if (mr > 30) {
          screenShake.current = Math.max(screenShake.current, mr > 50 ? 6 : 3);
      }
  };

  const createParticles = (x, y, color, count = 8) => {
      const room = 500 - particles.current.length;
      const actual = Math.min(count, room);
      for(let i=0; i<actual; i++) {
          const maxLife = 20 + Math.random() * 20;
          particles.current.push({
              x, y,
              vx: (Math.random() - 0.5) * 5,
              vy: (Math.random() - 0.5) * 5,
              color: color,
              life: maxLife,
              maxLife: maxLife,
              size: 1 + Math.random() * 3,
              shape: Math.random() > 0.5 ? 'circle' : 'square'
          });
      }
  };

  // --- Input Handling ---
  const handleCanvasClick = (e) => {
    if (gameState !== 'PLACEMENT') return;

    const rect = canvasRef.current.getBoundingClientRect();
    const scaleX = GAME_WIDTH / rect.width;
    const x = (e.clientX - rect.left) * scaleX;
    const y = getTerrainHeight(x, terrain.current);

    const clickedTurret = turrets.current.find(t => distance(x, y, t.x, t.y) < 30);
    if (clickedTurret) {
        const upgradeCost = UPGRADE_BASE_COST * Math.pow(2, clickedTurret.level - 1);
        if (money >= upgradeCost) {
            setMoney(m => m - upgradeCost);
            clickedTurret.stats.fireRate = Math.max(2, clickedTurret.stats.fireRate * 0.85);
            clickedTurret.stats.range += 40;
            clickedTurret.stats.damage *= 1.2;
            clickedTurret.level++;
            createParticles(clickedTurret.x, clickedTurret.y, '#0f0');
            Sound.upgrade();
            setMessage(`SYSTEM UPGRADED TO MK ${clickedTurret.level} (NEXT: $${UPGRADE_BASE_COST * Math.pow(2, clickedTurret.level - 1)})`);
        } else {
            setMessage(`INSUFFICIENT FUNDS (NEED $${upgradeCost})`);
        }
        return;
    }

    if (selectedAction) {
        const typeData = TURRET_TYPES[selectedAction];
        if (money >= typeData.cost) {
            setMoney(m => m - typeData.cost);
            turrets.current.push({
                id: Date.now(),
                x,
                y: y - 10,
                type: selectedAction,
                stats: { ...typeData },
                lastFired: 0,
                level: 1,
                angle: -Math.PI / 2,
                recoilOffset: 0,
                muzzleFlashTimer: 0
            });
            createParticles(x, y, typeData.color);
            Sound.placeTurret();
            setSelectedAction(null);
            setMessage(`${typeData.name} ONLINE`);
        } else {
            setMessage('INSUFFICIENT FUNDS');
            setSelectedAction(null);
        }
    }
  };

  const fortifyCity = () => {
      const activeCities = cities.filter(c => c.active);
      if (activeCities.length === 0) {
          setMessage("NO CITIES TO FORTIFY");
          return;
      }
      if (activeCities.every(c => (c.tier || 1) >= 5)) {
          setMessage("ALL CITIES AT MAX TIER");
          return;
      }
      if (money < FORTIFY_COST) {
          setMessage("INSUFFICIENT FUNDS");
          return;
      }
      setMoney(m => m - FORTIFY_COST);
      // Upgrade lowest-tier active city
      const minTier = Math.min(...activeCities.map(c => c.tier || 1));
      let upgraded = false;
      const newCities = cities.map(c => {
          if (!upgraded && c.active && (c.tier || 1) === minTier && (c.tier || 1) < 5) {
              upgraded = true;
              const newTier = (c.tier || 1) + 1;
              const newMaxHp = (c.maxHp || 3) + 2;
              createParticles(c.x, c.y, '#0ff', 12);
              Sound.upgrade();
              return { ...c, tier: newTier, maxHp: newMaxHp, hp: newMaxHp, buildings: generateCityBuildings(newTier) };
          }
          return c;
      });
      setCities(newCities);
      const fortified = newCities.find(c => c.active && upgraded);
      setMessage(`CITY FORTIFIED — TIER ${fortified ? fortified.tier : '?'}`);
  };

  const handleMouseMove = (e) => {
      const rect = canvasRef.current.getBoundingClientRect();
      const scaleX = GAME_WIDTH / rect.width;
      const x = (e.clientX - rect.left) * scaleX;
      const terrainY = getTerrainHeight(x, terrain.current);
      const y = (e.clientY - rect.top) * (GAME_HEIGHT / rect.height);

      mousePos.current = { x, y };

      if (gameState === 'PLACEMENT') {
          const hovered = turrets.current.find(t => distance(x, terrainY, t.x, t.y) < 30);
          setHoveredTurret(hovered || null);
      }
  };

  // --- Rendering ---
  const draw = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const fc = frameCount.current;

    // Screen shake
    ctx.save();
    if (screenShake.current > 0.5) {
        const sx = (Math.random() - 0.5) * screenShake.current * 2;
        const sy = (Math.random() - 0.5) * screenShake.current * 2;
        ctx.translate(sx, sy);
    }

    drawBackground(ctx, mapData.current, fc);
    drawTerrain(ctx, terrain.current, mapData.current);

    cities.forEach(c => drawCity(ctx, c, fc));

    turrets.current.forEach(t => {
        const isHovered = hoveredTurret && hoveredTurret.id === t.id;
        drawTurret(ctx, t, isHovered, gameState, fc);
    });

    // Placement ghost
    if (gameState === 'PLACEMENT' && selectedAction) {
        const mx = mousePos.current.x;
        const my = getTerrainHeight(mx, terrain.current);
        const typeData = TURRET_TYPES[selectedAction];

        ctx.strokeStyle = typeData.color;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(mx, my - 10, 10, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1.0;

        // Ghost range
        const ghostGrad = ctx.createRadialGradient(mx, my - 10, 0, mx, my - 10, typeData.range);
        ghostGrad.addColorStop(0, 'rgba(0, 255, 0, 0.02)');
        ghostGrad.addColorStop(1, 'rgba(0, 255, 0, 0)');
        ctx.fillStyle = ghostGrad;
        ctx.beginPath();
        ctx.arc(mx, my - 10, typeData.range, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#333';
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.arc(mx, my - 10, typeData.range, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    bombers.current.forEach(b => b.isBossShip ? drawBossShip(ctx, b, fc) : drawBomber(ctx, b, fc));
    enemyMissiles.current.forEach(m => drawEnemyMissile(ctx, m, fc));
    playerMissiles.current.forEach(m => drawPlayerMissile(ctx, m));
    lasers.current.forEach(l => drawLaserBeam(ctx, l));
    explosions.current.forEach(ex => drawExplosion(ctx, ex));
    particles.current.forEach(p => drawParticle(ctx, p));

    ctx.restore(); // End screen shake
  };

  const loop = useCallback(() => {
    update();
    draw();
    requestRef.current = requestAnimationFrame(loop);
  }, [update]);

  useEffect(() => {
    requestRef.current = requestAnimationFrame(loop);
    return () => cancelAnimationFrame(requestRef.current);
  }, [loop]);


  // --- UI ---
  return (
    <div className="w-full h-full min-h-screen bg-zinc-950 flex flex-col items-center p-2 font-mono text-green-500 select-none overflow-y-auto">

      {/* HUD */}
      <div className="w-full max-w-[800px] bg-black border border-green-900 p-2 mb-2 flex justify-between items-center shadow-lg rounded">
        <div className="flex gap-4 md:gap-8">
            <div className="flex flex-col">
                <span className="text-[10px] text-green-700">FUNDS</span>
                <div className="flex items-center gap-1 text-lg font-bold text-green-400">
                    <DollarSign size={16} />{money}
                </div>
            </div>
            <div className="flex flex-col">
                <span className="text-[10px] text-green-700">SCORE</span>
                <div className="flex items-center gap-1 text-lg font-bold">
                    <Trophy size={16} />{score}
                </div>
            </div>
            <div className="flex flex-col">
                <span className="text-[10px] text-green-700">WAVE</span>
                <div className="flex items-center gap-1 text-lg font-bold">
                    <Shield size={16} />{level}
                </div>
            </div>
        </div>
        <div className="text-green-400 font-bold animate-pulse text-right text-sm">
            {message}
        </div>
      </div>

      {/* Game Viewport */}
      <div className="relative border-2 border-zinc-800 rounded shadow-2xl bg-black mb-2 overflow-hidden">
        <canvas
            ref={canvasRef}
            width={GAME_WIDTH}
            height={GAME_HEIGHT}
            onClick={handleCanvasClick}
            onMouseMove={handleMouseMove}
            className="block cursor-crosshair max-w-full h-auto"
        />

        {/* --- OVERLAYS --- */}

        {gameState === 'START' && (
            <div className="absolute inset-0 bg-black/90 flex flex-col items-center justify-center">
                <h1 className="text-4xl md:text-6xl font-black text-green-500 tracking-tighter mb-4" style={{textShadow: '0 0 15px #0f0'}}>VECTOR DEFENSE</h1>
                <p className="text-green-700 mb-8 tracking-widest text-center">SECURE THE VALLEYS</p>
                <button onClick={initGame} className="px-8 py-3 border border-green-500 text-green-500 hover:bg-green-500 hover:text-black font-bold uppercase tracking-widest transition-all">
                    Initialize
                </button>
            </div>
        )}

        {/* LEVEL COMPLETE */}
        {gameState === 'LEVEL_COMPLETE' && bonusReport && (
             <div className="absolute inset-0 bg-black flex flex-col items-center justify-center font-mono">
                <h2 className="text-4xl text-green-500 font-bold mb-8 blink">WAVE {bonusReport.wave} CLEARED</h2>

                <div className="w-64 space-y-4 mb-8 text-green-400">
                    <div className="flex justify-between border-b border-green-900 pb-1">
                        <span>BASE BONUS</span>
                        <span>{bonusReport.base}</span>
                    </div>
                    <div className="flex justify-between border-b border-green-900 pb-1">
                        <span>CITIES SECURE ({bonusReport.cityCount})</span>
                        <span>{bonusReport.cityBonus}</span>
                    </div>
                    {bonusReport.evolvedCount > 0 && (
                    <div className="flex justify-between border-b border-cyan-900 pb-1 text-cyan-400">
                        <span>CITIES EVOLVED</span>
                        <span>{bonusReport.evolvedCount}</span>
                    </div>
                    )}
                    <div className="flex justify-between text-yellow-400 font-bold pt-2">
                        <span>TOTAL FUNDS</span>
                        <span>+{bonusReport.total}</span>
                    </div>
                </div>

                <button
                    onClick={advanceLevel}
                    className="px-8 py-3 bg-green-900 text-white font-bold hover:bg-green-700 animate-pulse border border-green-500"
                >
                    PROCEED TO NEXT SECTOR
                </button>
             </div>
        )}

        {/* LEVEL START */}
        {gameState === 'LEVEL_START' && (
            <div className="absolute inset-0 bg-black flex flex-col items-center justify-center">
                <h2 className="text-6xl font-black text-transparent bg-clip-text bg-gradient-to-b from-green-300 to-green-800 animate-pulse">
                    LEVEL {level}
                </h2>
                <div className="mt-4 text-green-600 tracking-[0.5em] text-sm">
                    GENERATING TERRAIN...
                </div>
            </div>
        )}

        {/* GAME OVER */}
        {gameState === 'GAME_OVER' && (
            <div className="absolute inset-0 bg-black/95 flex flex-col items-center justify-center">
                <h2 className="text-5xl text-red-500 font-bold mb-2 glitch-effect">SECTOR LOST</h2>
                <div className="text-2xl mb-8 border border-green-900 px-6 py-2 text-white">FINAL SCORE: {score}</div>
                <button onClick={initGame} className="flex items-center gap-2 px-6 py-3 border border-red-500 text-red-500 hover:bg-red-900/30 font-bold transition-all">
                    <RotateCcw size={18} /> REBOOT SYSTEM
                </button>
            </div>
        )}
      </div>

      {/* Armory */}
      <div className={`w-full max-w-[800px] transition-all duration-300 ${gameState === 'PLACEMENT' ? 'opacity-100 translate-y-0' : 'opacity-30 grayscale pointer-events-none'}`}>
          <div className="grid grid-cols-2 md:grid-cols-[1fr_auto] gap-2">

              <div className="bg-black border border-green-900 p-2 rounded flex flex-wrap gap-2 justify-center md:justify-start">

                  {Object.keys(TURRET_TYPES).map(key => {
                      const t = TURRET_TYPES[key];
                      const Icon = t.icon;
                      return (
                        <button
                            key={key}
                            onClick={() => setSelectedAction(key)}
                            className={`flex flex-col items-center justify-center w-20 h-20 border rounded transition-all ${selectedAction === key ? 'bg-green-900/40 border-green-400' : 'border-zinc-800 hover:border-zinc-600'}`}
                        >
                            <Icon size={20} style={{color: t.color}} className="mb-1" />
                            <span className="text-[10px] font-bold text-zinc-300">{t.name}</span>
                            <span className="text-[10px] text-green-600">${t.cost}</span>
                        </button>
                      );
                  })}

                  <div className="w-px bg-zinc-800 mx-1"></div>

                   <button
                        onClick={fortifyCity}
                        className="flex flex-col items-center justify-center w-20 h-20 border border-zinc-800 rounded hover:border-cyan-500 group transition-all"
                    >
                        <Wifi size={20} className="text-cyan-400 mb-1 group-hover:animate-pulse" />
                        <span className="text-[10px] font-bold text-zinc-300">FORTIFY</span>
                        <span className="text-[10px] text-cyan-400">${FORTIFY_COST}</span>
                    </button>
              </div>

              <button
                onClick={startWave}
                className="col-span-2 md:col-span-1 bg-green-900/20 border border-green-600 text-green-400 hover:bg-green-500 hover:text-black transition-all px-6 rounded font-bold text-lg flex items-center justify-center uppercase tracking-wider"
              >
                  <Play size={24} className="mr-2" /> ENGAGE
              </button>
          </div>
          <div className="text-center text-xs text-zinc-600 mt-2">
            Click Unit to Upgrade (cost scales per level)
          </div>
      </div>

      <style>{`
        @keyframes blink { 50% { opacity: 0; } }
        .blink { animation: blink 1s step-end infinite; }
      `}</style>
    </div>
  );
};

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
