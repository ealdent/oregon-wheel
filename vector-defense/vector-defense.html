<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Defense</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        html, body { margin: 0; padding: 0; background: #09090b; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
const { useState, useEffect, useRef, useCallback } = React;

// --- Inline SVG Icon Components (replacing lucide-react) ---
const SvgIcon = ({ children, size = 24, className = '', style = {}, ...props }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24"
         fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round"
         strokeLinejoin="round" className={className} style={style} {...props}>
        {children}
    </svg>
);

const Play = (props) => <SvgIcon {...props}><polygon points="5 3 19 12 5 21 5 3"/></SvgIcon>;
const RotateCcw = (props) => <SvgIcon {...props}><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></SvgIcon>;
const Shield = (props) => <SvgIcon {...props}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></SvgIcon>;
const DollarSign = (props) => <SvgIcon {...props}><line x1="12" y1="1" x2="12" y2="23"/><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/></SvgIcon>;
const Crosshair = (props) => <SvgIcon {...props}><circle cx="12" cy="12" r="10"/><line x1="22" y1="12" x2="18" y2="12"/><line x1="6" y1="12" x2="2" y2="12"/><line x1="12" y1="6" x2="12" y2="2"/><line x1="12" y1="22" x2="12" y2="18"/></SvgIcon>;
const Trophy = (props) => <SvgIcon {...props}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></SvgIcon>;
const AlertTriangle = (props) => <SvgIcon {...props}><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></SvgIcon>;
const Zap = (props) => <SvgIcon {...props}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></SvgIcon>;
const Target = (props) => <SvgIcon {...props}><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></SvgIcon>;
const Wifi = (props) => <SvgIcon {...props}><path d="M5 12.55a11 11 0 0 1 14.08 0"/><path d="M1.42 9a16 16 0 0 1 21.16 0"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><line x1="12" y1="20" x2="12.01" y2="20"/></SvgIcon>;
const Users = (props) => <SvgIcon {...props}><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></SvgIcon>;
const ShieldPlus = (props) => <SvgIcon {...props}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/><line x1="12" y1="9" x2="12" y2="15"/><line x1="9" y1="12" x2="15" y2="12"/></SvgIcon>;

// --- Constants ---
const GAME_WIDTH = 800;
const GAME_HEIGHT = 600;
const PLAYER_PROJECTILE_SPEED = 15;
const SAM_SPEED = 7;
const ARTILLERY_SHELL_SPEED = 28;
const EXPLOSION_GROWTH = 1.5;

// Balance Constants
const FLAK_COST = 800;
const SAM_COST = 1800;
const ARTILLERY_COST = 2800;
const LASER_COST = 4500;
const SWARM_COST = 3500;
const SWARM_SPEED = 5;
const UPGRADE_BASE_COST = 500;
const SHIELD_BASE_COST = 800;
const CITY_REPAIR_PENALTY = 300;
const WAVE_COMPLETE_BONUS = 2500;

// Two-tier terrain layout
const CITY_ZONE_TOP = 530;        // Above this = turret zone, below = city zone
const LOWER_TERRAIN_Y = 580;      // City foreground baseline (lowered & flattened)

// Enemy Stats (HP values)
const HP_NORMAL = 10;
const HP_FAST = 15;
const HP_ARMORED = 40;
const HP_BOSS_BASE = 200;

// HP scales up after every boss wave (every 5 levels)
const getHpScale = (lvl) => 1 + Math.floor(lvl / 5) * 0.5; // 1x, 1.5x, 2x, 2.5x...

// Turret Stats
const TURRET_TYPES = {
  FLAK: {
    name: 'FLAK',
    desc: 'Suppression',
    color: '#00ff00',
    range: 600,
    fireRate: 12,
    explosionRadius: 8,
    projectileColor: '#0f0',
    damage: 3,
    cost: FLAK_COST,
    icon: Crosshair
  },
  SAM: {
    name: 'SAM',
    desc: 'High Impact',
    color: '#00ffff',
    range: 400,
    fireRate: 45,
    explosionRadius: 20,
    projectileColor: '#0ff',
    damage: 40,
    cost: SAM_COST,
    icon: Target
  },
  ARTILLERY: {
    name: 'ARTILLERY',
    desc: 'Heavy Cannon',
    color: '#ff00ff',
    range: 500,
    fireRate: 100,
    explosionRadius: 0,
    projectileColor: '#f0f',
    damage: 80,
    cost: ARTILLERY_COST,
    icon: Shield,
    trackingSpeed: 0.03
  },
  LASER: {
    name: 'LASER',
    desc: 'Focused Beam',
    color: '#ffff00',
    range: 500,
    fireRate: 8,
    explosionRadius: 10,
    projectileColor: '#ff0',
    damage: 3,
    cost: LASER_COST,
    icon: Zap
  },
  SWARM: {
    name: 'SWARM',
    desc: 'Missile Barrage',
    color: '#ff8800',
    range: 650,
    fireRate: 150,
    explosionRadius: 12,
    projectileColor: '#ff8800',
    damage: 15,
    cost: SWARM_COST,
    icon: AlertTriangle
  }
};

// --- Helper Functions ---
const distance = (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);

// --- Audio Engine ---
let audioCtx = null;
let masterGain = null;
const initAudio = () => {
    if (audioCtx) return;
    audioCtx = new AudioContext();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.3;
    masterGain.connect(audioCtx.destination);
};

let lastEnemyHitFrame = 0;

const Sound = {
    turretFire(type) {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        if (type === 'FLAK') {
            // Short white noise burst, bandpass ~2kHz
            const bufferSize = audioCtx.sampleRate * 0.08;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
            const src = audioCtx.createBufferSource();
            src.buffer = buffer;
            const bp = audioCtx.createBiquadFilter();
            bp.type = 'bandpass';
            bp.frequency.value = 2000;
            bp.Q.value = 1.5;
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0.4, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
            src.connect(bp).connect(g).connect(masterGain);
            src.start(t);
            src.stop(t + 0.08);
        } else if (type === 'SAM') {
            // Rising sine sweep 200->800Hz
            const osc = audioCtx.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(200, t);
            osc.frequency.exponentialRampToValueAtTime(800, t + 0.12);
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0.3, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
            osc.connect(g).connect(masterGain);
            osc.start(t);
            osc.stop(t + 0.12);
        } else if (type === 'ARTILLERY') {
            // Heavy cannon boom: low sine 50Hz + sharp crack + rumble
            const osc = audioCtx.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = 50;
            const g1 = audioCtx.createGain();
            g1.gain.setValueAtTime(0.6, t);
            g1.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
            osc.connect(g1).connect(masterGain);
            osc.start(t);
            osc.stop(t + 0.25);
            // Sharp crack
            const bufferSize = audioCtx.sampleRate * 0.05;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
            const src = audioCtx.createBufferSource();
            src.buffer = buffer;
            const hp = audioCtx.createBiquadFilter();
            hp.type = 'highpass';
            hp.frequency.value = 800;
            const g2 = audioCtx.createGain();
            g2.gain.setValueAtTime(0.5, t);
            g2.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
            src.connect(hp).connect(g2).connect(masterGain);
            src.start(t);
            src.stop(t + 0.05);
        } else if (type === 'SWARM') {
            // 4 rapid staccato sawtooth chirps
            for (let i = 0; i < 4; i++) {
                const osc = audioCtx.createOscillator();
                osc.type = 'sawtooth';
                const chirpStart = t + i * 0.04;
                osc.frequency.setValueAtTime(600 + i * 100, chirpStart);
                osc.frequency.exponentialRampToValueAtTime(1200 + i * 100, chirpStart + 0.03);
                const g = audioCtx.createGain();
                g.gain.setValueAtTime(0.2, chirpStart);
                g.gain.exponentialRampToValueAtTime(0.001, chirpStart + 0.03);
                osc.connect(g).connect(masterGain);
                osc.start(chirpStart);
                osc.stop(chirpStart + 0.03);
            }
        }
    },

    laserBeam(dwellTime) {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        const dwell = dwellTime || 0;
        const osc = audioCtx.createOscillator();
        osc.type = 'sine';
        // Low base pitch that rises slightly with dwell
        const baseFreq = 180 + Math.min(dwell, 60) * 2;
        osc.frequency.setValueAtTime(baseFreq, t);
        osc.frequency.linearRampToValueAtTime(baseFreq + 40, t + 0.06);
        // Subtle slow vibrato
        const lfo = audioCtx.createOscillator();
        lfo.frequency.value = 8;
        const lfoGain = audioCtx.createGain();
        lfoGain.gain.value = 6;
        lfo.connect(lfoGain).connect(osc.frequency);
        const g = audioCtx.createGain();
        const vol = Math.min(0.06 + dwell / 500, 0.15);
        g.gain.setValueAtTime(vol, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.06);
        osc.connect(g).connect(masterGain);
        osc.start(t);
        lfo.start(t);
        osc.stop(t + 0.06);
        lfo.stop(t + 0.06);
    },

    explosion(maxRadius) {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        const large = maxRadius > 50;
        const dur = large ? 0.4 : 0.2;
        const bufferSize = audioCtx.sampleRate * dur;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        const lp = audioCtx.createBiquadFilter();
        lp.type = 'lowpass';
        lp.frequency.setValueAtTime(large ? 800 : 1200, t);
        lp.frequency.exponentialRampToValueAtTime(100, t + dur);
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(large ? 0.5 : 0.3, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + dur);
        src.connect(lp).connect(g).connect(masterGain);
        src.start(t);
        src.stop(t + dur);
    },

    enemyHit() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        osc.type = 'triangle';
        osc.frequency.value = 600;
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.15, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.03);
        osc.connect(g).connect(masterGain);
        osc.start(t);
        osc.stop(t + 0.03);
    },

    cityDestroyed() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        // Low descending tone + noise
        const osc = audioCtx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, t);
        osc.frequency.exponentialRampToValueAtTime(100, t + 0.5);
        const g1 = audioCtx.createGain();
        g1.gain.setValueAtTime(0.4, t);
        g1.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
        osc.connect(g1).connect(masterGain);
        osc.start(t);
        osc.stop(t + 0.5);
        const bufferSize = audioCtx.sampleRate * 0.3;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        const lp = audioCtx.createBiquadFilter();
        lp.type = 'lowpass';
        lp.frequency.value = 400;
        const g2 = audioCtx.createGain();
        g2.gain.setValueAtTime(0.3, t);
        g2.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        src.connect(lp).connect(g2).connect(masterGain);
        src.start(t);
        src.stop(t + 0.3);
    },

    waveStart() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(300, t);
        osc.frequency.exponentialRampToValueAtTime(600, t + 0.3);
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.2, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        osc.connect(g).connect(masterGain);
        osc.start(t);
        osc.stop(t + 0.3);
    },

    bossWarning() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        // Two alternating low alarm tones
        for (let i = 0; i < 3; i++) {
            const osc = audioCtx.createOscillator();
            osc.type = 'square';
            osc.frequency.value = i % 2 === 0 ? 150 : 120;
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0, t + i * 0.2);
            g.gain.linearRampToValueAtTime(0.3, t + i * 0.2 + 0.02);
            g.gain.setValueAtTime(0.3, t + i * 0.2 + 0.15);
            g.gain.linearRampToValueAtTime(0, t + i * 0.2 + 0.19);
            osc.connect(g).connect(masterGain);
            osc.start(t + i * 0.2);
            osc.stop(t + i * 0.2 + 0.2);
        }
    },

    gameOver() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        // Descending 3-note sequence
        const notes = [440, 330, 220];
        notes.forEach((freq, i) => {
            const osc = audioCtx.createOscillator();
            osc.type = 'square';
            osc.frequency.value = freq;
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0.25, t + i * 0.25);
            g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.25 + 0.22);
            osc.connect(g).connect(masterGain);
            osc.start(t + i * 0.25);
            osc.stop(t + i * 0.25 + 0.25);
        });
    },

    upgrade() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        // Quick ascending 2-note chirp
        const notes = [500, 750];
        notes.forEach((freq, i) => {
            const osc = audioCtx.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = freq;
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0.25, t + i * 0.07);
            g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.07 + 0.06);
            osc.connect(g).connect(masterGain);
            osc.start(t + i * 0.07);
            osc.stop(t + i * 0.07 + 0.07);
        });
    },

    empFire() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        // Descending sweep with electric crackle
        const osc = audioCtx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(1200, t);
        osc.frequency.exponentialRampToValueAtTime(60, t + 0.5);
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.35, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
        osc.connect(g).connect(masterGain);
        osc.start(t);
        osc.stop(t + 0.5);
        // Noise crackle layer
        const bufferSize = audioCtx.sampleRate * 0.3;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        const bp = audioCtx.createBiquadFilter();
        bp.type = 'bandpass';
        bp.frequency.setValueAtTime(800, t);
        bp.frequency.exponentialRampToValueAtTime(200, t + 0.3);
        bp.Q.value = 2;
        const g2 = audioCtx.createGain();
        g2.gain.setValueAtTime(0.3, t);
        g2.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        src.connect(bp).connect(g2).connect(masterGain);
        src.start(t);
        src.stop(t + 0.3);
    },

    pdcFire() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        // Short high-pass noise burst
        const bufferSize = audioCtx.sampleRate * 0.05;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        const hp = audioCtx.createBiquadFilter();
        hp.type = 'highpass';
        hp.frequency.value = 3000;
        hp.Q.value = 1;
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.25, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
        src.connect(hp).connect(g).connect(masterGain);
        src.start(t);
        src.stop(t + 0.05);
    },

    pointDefense() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        // Quick zap sound
        const osc = audioCtx.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(2000, t);
        osc.frequency.exponentialRampToValueAtTime(500, t + 0.06);
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.2, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.06);
        osc.connect(g).connect(masterGain);
        osc.start(t);
        osc.stop(t + 0.06);
    },

    placeTurret() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        // Short click + confirmation beep
        const bufferSize = audioCtx.sampleRate * 0.02;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        const g1 = audioCtx.createGain();
        g1.gain.setValueAtTime(0.2, t);
        g1.gain.exponentialRampToValueAtTime(0.001, t + 0.02);
        src.connect(g1).connect(masterGain);
        src.start(t);
        src.stop(t + 0.02);
        // Confirmation beep
        const osc = audioCtx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = 880;
        const g2 = audioCtx.createGain();
        g2.gain.setValueAtTime(0, t + 0.03);
        g2.gain.linearRampToValueAtTime(0.2, t + 0.04);
        g2.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
        osc.connect(g2).connect(masterGain);
        osc.start(t + 0.03);
        osc.stop(t + 0.1);
    }
};

// --- Pre-create scanline overlay canvas ---
const scanlineCanvas = document.createElement('canvas');
scanlineCanvas.width = GAME_WIDTH;
scanlineCanvas.height = GAME_HEIGHT;
const scanlineCtx = scanlineCanvas.getContext('2d');
scanlineCtx.fillStyle = 'rgba(0, 0, 0, 0.12)';
for (let i = 0; i < GAME_HEIGHT; i += 4) {
    scanlineCtx.fillRect(0, i, GAME_WIDTH, 1);
}

// ============================================================
// MODULAR DRAW HELPERS (Phase 1-5)
// ============================================================

// Population per building: ~50 people per floor (w*h as proxy for floor area)
const getBuildingPop = (b) => Math.round(b.w * b.h * 0.3);

const lerpColor = (a, b, t) => {
    // a, b are [r, g, b] arrays, t is 0-1
    return [
        Math.round(a[0] + (b[0] - a[0]) * t),
        Math.round(a[1] + (b[1] - a[1]) * t),
        Math.round(a[2] + (b[2] - a[2]) * t)
    ];
};

const rgbStr = (c) => `rgb(${c[0]},${c[1]},${c[2]})`;

const getSkyColors = (level) => {
    const hour = (6 + (level - 1) * 3) % 24;

    // Sun elevation: sine curve from sunrise (6) to sunset (18), 0 at night
    let sunElevation = 0;
    if (hour >= 6 && hour <= 18) {
        sunElevation = Math.sin(((hour - 6) / 12) * Math.PI);
    }

    // Dawn/dusk intensity: peaks at exactly hour 6 and 18, fades within ±2 hours
    const dawnProx = Math.max(0, 1 - Math.abs(hour - 6) / 2);
    const duskProx = Math.max(0, 1 - Math.abs(hour - 18) / 2);
    const twilight = Math.max(dawnProx, duskProx);

    // Base night colors
    const nightZenith  = [5, 5, 16];
    const nightMid     = [5, 5, 16];
    const nightHorizon = [10, 10, 26];

    // Day colors (at full sun elevation)
    const dayZenith  = [15, 35, 80];
    const dayMid     = [40, 90, 160];
    const dayHorizon = [70, 130, 190];

    // Twilight warm tint (dawn/dusk)
    const twilightZenith  = [20, 10, 40];
    const twilightMid     = [50, 25, 60];
    const twilightHorizon = [204, 102, 51];

    // Blend night → day based on sun elevation
    let zenith  = lerpColor(nightZenith, dayZenith, sunElevation);
    let mid     = lerpColor(nightMid, dayMid, sunElevation);
    let horizon = lerpColor(nightHorizon, dayHorizon, sunElevation);

    // Overlay twilight warmth
    if (twilight > 0) {
        zenith  = lerpColor(zenith, twilightZenith, twilight * 0.6);
        mid     = lerpColor(mid, twilightMid, twilight * 0.7);
        horizon = lerpColor(horizon, twilightHorizon, twilight * 0.8);
    }

    // Star visibility: bright at night, faded at dawn/dusk, hidden at noon
    const starAlpha = Math.max(0, 1 - sunElevation * 1.5 - twilight * 0.3);

    return { zenith, mid, horizon, starAlpha };
};

const SPACE_BOUNDARY = GAME_HEIGHT * 0.2; // Y=120, 80% from bottom

const drawBackground = (ctx, mapData, frameCount, level) => {
    const sky = getSkyColors(level);

    // Sky gradient: space at top, atmosphere below
    const grad = ctx.createLinearGradient(0, 0, 0, 400);
    grad.addColorStop(0.0,  '#050510');            // pure space
    grad.addColorStop(0.2,  '#050510');            // still space
    grad.addColorStop(0.3,  rgbStr(sky.zenith));   // top of atmosphere
    grad.addColorStop(0.65, rgbStr(sky.mid));       // mid atmosphere
    grad.addColorStop(1.0,  rgbStr(sky.horizon));   // horizon
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    // Stars
    if (mapData.stars) {
        mapData.stars.forEach(s => {
            const twinkle = 0.4 + 0.6 * Math.abs(Math.sin(frameCount * 0.02 + s.twinklePhase));
            const skyFade = s.y < SPACE_BOUNDARY ? 1.0 : sky.starAlpha;
            ctx.globalAlpha = s.brightness * twinkle * skyFade;
            ctx.fillStyle = s.color;
            ctx.fillRect(s.x, s.y, s.size, s.size);
        });
        ctx.globalAlpha = 1.0;
    }

    // Scanlines via offscreen canvas
    ctx.drawImage(scanlineCanvas, 0, 0);

    // Grid
    ctx.strokeStyle = '#0a0a0a';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let i = 0; i < GAME_WIDTH; i += 50) { ctx.moveTo(i, 0); ctx.lineTo(i, GAME_HEIGHT); }
    for (let i = 0; i < GAME_HEIGHT; i += 50) { ctx.moveTo(0, i); ctx.lineTo(GAME_WIDTH, i); }
    ctx.stroke();
};

const drawUpperTerrain = (ctx, points, mapData) => {
    if (!points || points.length === 0) return;

    // Background mountains (behind upper terrain)
    if (mapData.bgTerrain && mapData.bgTerrain.length > 0) {
        ctx.beginPath();
        ctx.moveTo(0, GAME_HEIGHT);
        ctx.lineTo(0, mapData.bgTerrain[0].y);
        mapData.bgTerrain.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.lineTo(GAME_WIDTH, mapData.bgTerrain[mapData.bgTerrain.length - 1].y);
        ctx.lineTo(GAME_WIDTH, GAME_HEIGHT);
        ctx.fillStyle = '#000d00';
        ctx.fill();
        ctx.strokeStyle = '#002200';
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    // Upper terrain fill — full depth background layer
    ctx.beginPath();
    ctx.moveTo(0, GAME_HEIGHT);
    ctx.lineTo(0, points[0].y);
    points.forEach(p => ctx.lineTo(p.x, p.y));
    ctx.lineTo(GAME_WIDTH, points[points.length - 1].y);
    ctx.lineTo(GAME_WIDTH, GAME_HEIGHT);
    ctx.fillStyle = '#001a00';
    ctx.fill();

    // Rock face hatching on steep slopes
    for (let i = 0; i < points.length - 1; i++) {
        const p1 = points[i];
        const p2 = points[i + 1];
        const slope = Math.abs(p2.y - p1.y) / (p2.x - p1.x || 1);
        if (slope > 1.2) {
            ctx.strokeStyle = '#002200';
            ctx.lineWidth = 1;
            const steps = 3;
            for (let s = 0; s < steps; s++) {
                const t = (s + 0.5) / steps;
                const hx = p1.x + (p2.x - p1.x) * t;
                const hy = p1.y + (p2.y - p1.y) * t;
                ctx.beginPath();
                ctx.moveTo(hx, hy);
                ctx.lineTo(hx + 4, hy + 6);
                ctx.stroke();
            }
        }
    }

    // Snow caps on highest peaks
    for (let i = 1; i < points.length - 1; i++) {
        const p = points[i];
        if (p.y < 430 && p.y < points[i - 1].y && p.y < points[i + 1].y) {
            ctx.fillStyle = 'rgba(200, 220, 255, 0.15)';
            ctx.beginPath();
            ctx.moveTo(p.x - 6, p.y);
            ctx.lineTo(p.x, p.y - 5);
            ctx.lineTo(p.x + 6, p.y);
            ctx.fill();
        }
    }

    // Upper terrain outline with CRT glow
    ctx.save();
    ctx.shadowColor = '#00ff00';
    ctx.shadowBlur = 6;
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, points[0].y);
    points.forEach(p => ctx.lineTo(p.x, p.y));
    ctx.lineTo(GAME_WIDTH, points[points.length - 1].y);
    ctx.stroke();
    ctx.restore();

    // Vegetation on gentle slopes
    if (mapData.vegetation) {
        mapData.vegetation.forEach(v => {
            ctx.strokeStyle = v.color;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(v.x, v.y);
            ctx.lineTo(v.x, v.y - v.h);
            ctx.stroke();
        });
    }
};

const drawLowerTerrain = (ctx, points) => {
    if (!points || points.length === 0) return;

    // Extend beyond edges to survive foreground zoom-out scaling
    const pad = 200;

    // Lower terrain fill
    ctx.beginPath();
    ctx.moveTo(-pad, GAME_HEIGHT);
    ctx.lineTo(-pad, points[0].y);
    points.forEach(p => ctx.lineTo(p.x, p.y));
    ctx.lineTo(GAME_WIDTH + pad, points[points.length - 1].y);
    ctx.lineTo(GAME_WIDTH + pad, GAME_HEIGHT);
    ctx.fillStyle = '#0a0a05';
    ctx.fill();

    // Dimmer outline glow (amber tint)
    ctx.save();
    ctx.shadowColor = '#886600';
    ctx.shadowBlur = 4;
    ctx.strokeStyle = '#665500';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(-pad, points[0].y);
    points.forEach(p => ctx.lineTo(p.x, p.y));
    ctx.lineTo(GAME_WIDTH + pad, points[points.length - 1].y);
    ctx.stroke();
    ctx.restore();

    // Atmospheric haze at bottom
    const hazeGrad = ctx.createLinearGradient(0, GAME_HEIGHT * 0.85, 0, GAME_HEIGHT);
    hazeGrad.addColorStop(0, 'rgba(5, 10, 0, 0)');
    hazeGrad.addColorStop(1, 'rgba(5, 10, 0, 0.3)');
    ctx.fillStyle = hazeGrad;
    ctx.fillRect(0, GAME_HEIGHT * 0.85, GAME_WIDTH, GAME_HEIGHT * 0.15);
};

const TIER_COLORS = [
    { gradTop: '#009999', gradBot: '#004444', outline: '#005555', winLit: '#88dddd', winDark: '#003333', antenna: '#005555' },
    { gradTop: '#00cccc', gradBot: '#005566', outline: '#006677', winLit: '#aaffff', winDark: '#003344', antenna: '#006666' },
    { gradTop: '#00eeff', gradBot: '#006677', outline: '#007788', winLit: '#bbffff', winDark: '#004455', antenna: '#008888' },
    { gradTop: '#aaddff', gradBot: '#2255aa', outline: '#3366bb', winLit: '#ddeeff', winDark: '#113366', antenna: '#4488cc' },
    { gradTop: '#cc88ff', gradBot: '#3322aa', outline: '#5533cc', winLit: '#ddaaff', winDark: '#221166', antenna: '#7744dd' },
    { gradTop: '#ffdd66', gradBot: '#aa6600', outline: '#cc8800', winLit: '#ffeeaa', winDark: '#554400', antenna: '#ddaa44' },
];

// --- Population Tracking ---
const TIER_POP_MULT = [0.3, 1, 1.5, 2.5, 4, 6]; // village through tier 5
const getCityPopulation = (city) => {
    if (!city.active) return 0;
    const mult = TIER_POP_MULT[Math.min(city.tier ?? 1, 5)];
    return city.buildings.reduce((sum, b) => {
        const alive = 1 - (b.damage || 0);
        return sum + Math.floor(b.w * b.h * mult * alive / 10);
    }, 0);
};
const formatNumber = (n) => {
    if (n >= 1e6) return (n / 1e6).toFixed(1) + 'M';
    if (n >= 10000) return (n / 1e3).toFixed(1) + 'k';
    return n.toLocaleString();
};

const drawCity = (ctx, city, frameCount) => {
    if (!city.active) return;
    const tier = city.tier != null ? city.tier : 1;
    const tc = TIER_COLORS[Math.min(tier, 5)];

    // Light pollution glow — scales with tier
    ctx.save();
    const glowR = 50 + tier * 10;
    const glowA = 0.06 + tier * 0.02;
    const gc = TIER_COLORS[Math.min(tier, 5)];
    const glowGrad = ctx.createRadialGradient(city.x, city.y, 5, city.x, city.y, glowR);
    glowGrad.addColorStop(0, `rgba(${gc.winLit === '#ffeeaa' ? '255,220,100' : gc.winLit === '#ddaaff' ? '180,120,255' : gc.winLit === '#ddeeff' ? '150,200,255' : '0,200,200'}, ${glowA})`);
    glowGrad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = glowGrad;
    ctx.fillRect(city.x - glowR, city.y - glowR, glowR * 2, glowR);
    ctx.restore();

    city.buildings.forEach(b => {
        const dmg = b.damage || 0;
        // Deterministic hash from xOffset for consistent damage patch positions
        const hash = Math.abs(b.xOffset * 1000) | 0;

        // Rubble: only draw bottom stump
        if (dmg >= 0.8) {
            const stumpH = b.h * (0.15 + (hash % 10) * 0.01);
            const bx = city.x + b.xOffset - (b.w / 2);
            const by = city.y - stumpH;
            ctx.fillStyle = '#333';
            ctx.fillRect(bx, by, b.w, stumpH);
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            ctx.strokeRect(bx, by, b.w, stumpH);
            // Smoke: light gray pixel drifting up
            const smokeX = bx + b.w * 0.5 + Math.sin(frameCount * 0.05 + hash) * 2;
            const smokeY = by - 2 - Math.abs(Math.sin(frameCount * 0.03 + hash)) * 4;
            ctx.fillStyle = 'rgba(150,150,150,0.4)';
            ctx.fillRect(smokeX, smokeY, 2, 2);
            return;
        }

        // Heavy damage: truncate height
        let visibleH = b.h;
        if (dmg > 0.5) {
            visibleH = b.h * (1 - (dmg - 0.3) * 0.5);
        }

        const bx = city.x + b.xOffset - (b.w / 2);
        const by = city.y - visibleH;

        // Building gradient fill — tier colored
        const bGrad = ctx.createLinearGradient(bx, by, bx, city.y);
        bGrad.addColorStop(0, tc.gradTop);
        bGrad.addColorStop(1, tc.gradBot);
        ctx.fillStyle = bGrad;

        // Building shape
        if (dmg > 0.5) {
            // Heavy damage: jagged flat top, no fancy shapes
            ctx.fillRect(bx, by, b.w, visibleH);
        } else if (b.style === 'pointed') {
            ctx.beginPath();
            ctx.moveTo(bx, city.y);
            ctx.lineTo(bx, by + 4);
            ctx.lineTo(bx + b.w / 2, by);
            ctx.lineTo(bx + b.w, by + 4);
            ctx.lineTo(bx + b.w, city.y);
            ctx.fill();
        } else if (b.style === 'dome') {
            ctx.fillRect(bx, by + 4, b.w, visibleH - 4);
            ctx.beginPath();
            ctx.arc(bx + b.w / 2, by + 4, b.w / 2, Math.PI, 0);
            ctx.fill();
        } else if (b.style === 'stepped') {
            ctx.fillRect(bx + 2, by, b.w - 4, visibleH);
            ctx.fillRect(bx, by + visibleH * 0.3, b.w, visibleH * 0.7);
        } else {
            // flat with parapet lip
            ctx.fillRect(bx, by, b.w, visibleH);
            ctx.fillRect(bx - 1, by, b.w + 2, 2);
        }

        // Building outline
        ctx.strokeStyle = tc.outline;
        ctx.lineWidth = 1;
        ctx.strokeRect(bx, by, b.w, visibleH);

        // Damage patches (dark marks)
        if (dmg > 0.2) {
            const patchCount = dmg > 0.5 ? 2 + (hash % 2) : 1 + (hash % 2);
            ctx.fillStyle = '#111';
            for (let p = 0; p < patchCount; p++) {
                const px = bx + ((hash * (p + 1) * 7) % Math.max(1, Math.floor(b.w - 4))) + 2;
                const py = by + ((hash * (p + 1) * 13) % Math.max(1, Math.floor(visibleH * 0.6))) + visibleH * 0.2;
                const pw = 2 + (hash + p) % 3;
                const ph = 3 + (hash + p * 2) % 4;
                ctx.fillRect(px, py, pw, ph);
            }
        }

        // Fire pixels for heavy damage
        if (dmg > 0.5) {
            const fireCount = 1 + (hash % 2);
            for (let f = 0; f < fireCount; f++) {
                const fx = bx + ((hash * (f + 1) * 11) % Math.max(1, Math.floor(b.w - 2))) + 1;
                const fy = by + ((hash * (f + 1) * 7) % Math.max(1, Math.floor(visibleH * 0.4)));
                // Flickering orange/red
                if ((frameCount + hash + f) % 3 !== 0) {
                    ctx.fillStyle = (frameCount + f) % 2 === 0 ? '#ff6600' : '#ff3300';
                    ctx.fillRect(fx, fy, 2, 2);
                }
                // Smoke above fire
                const smokeY = fy - 3 - Math.abs(Math.sin(frameCount * 0.05 + hash + f)) * 3;
                ctx.fillStyle = 'rgba(150,150,150,0.3)';
                ctx.fillRect(fx, smokeY, 1, 1);
            }
        }

        // Windows (only if not heavily damaged)
        if (dmg < 0.5 && b.windows) {
            b.windows.forEach(win => {
                if (win.oy < visibleH - 2) {
                    const lit = ((frameCount >> 6) + win.phase) % 3 !== 0;
                    ctx.fillStyle = lit ? tc.winLit : tc.winDark;
                    ctx.fillRect(bx + win.ox, by + win.oy, 2, 2);
                }
            });
        }

        // Antenna (only if low damage)
        if (dmg < 0.3 && b.hasAntenna) {
            ctx.strokeStyle = tc.antenna;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(bx + b.w / 2, by);
            ctx.lineTo(bx + b.w / 2, by - 8);
            ctx.stroke();
            if ((frameCount >> 5) % 2 === 0) {
                ctx.fillStyle = tier >= 5 ? '#ffdd00' : tier >= 4 ? '#cc66ff' : '#ff0000';
                ctx.fillRect(bx + b.w / 2 - 1, by - 9, 2, 2);
            }
        }
    });

    // --- Shield Generators ---
    if (city.shields && city.shields.length > 0) {
        city.shields.forEach(s => {
            const cx = city.x + s.x;
            const hw = s.halfWidth;
            // Compute arc height: float above tallest building under this shield
            let maxH = 20;
            city.buildings.forEach(bl => {
                if ((bl.damage || 0) < 0.8 && Math.abs(bl.xOffset - s.x) <= hw + bl.w / 2) {
                    maxH = Math.max(maxH, bl.h);
                }
            });
            const clearance = 10;
            const sag = 6; // shallow curve: 6px droop from center to edges
            const edgeY = city.y - maxH - clearance; // Y at arc edges
            // Arc formula: py = edgeY - sag*(1 - t*t), center is highest

            // Underground generator bunker (below terrain line)
            const shieldColor = tc.gradTop;
            const r = parseInt(shieldColor.slice(1, 3), 16) || 0;
            const g = parseInt(shieldColor.slice(3, 5), 16) || 200;
            const bv = parseInt(shieldColor.slice(5, 7), 16) || 200;

            ctx.save();
            if (s.damaged) {
                // Damaged bunker
                ctx.fillStyle = '#222';
                ctx.fillRect(cx - 6, city.y + 1, 12, 10);
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 1;
                ctx.strokeRect(cx - 6, city.y + 1, 12, 10);
                // Sparks
                if ((frameCount + Math.abs(s.x * 100 | 0)) % 8 < 3) {
                    ctx.fillStyle = '#ff8800';
                    ctx.fillRect(cx - 2 + (frameCount % 4), city.y - 1, 2, 2);
                }
                // Damaged arc outline
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                for (let i = 0; i <= 20; i++) {
                    const t = (i / 20) * 2 - 1;
                    const px = cx + t * hw;
                    const py = edgeY - sag * (1 - t * t);
                    if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            } else {
                // Active underground bunker
                const shimmer = 0.15 + 0.08 * Math.sin(frameCount * 0.04 + s.x * 0.1);
                const hpFrac = s.hp / s.maxHp;

                // Bunker body (underground)
                ctx.fillStyle = '#111';
                ctx.fillRect(cx - 7, city.y + 1, 14, 11);
                ctx.strokeStyle = `rgba(${r}, ${g}, ${bv}, 0.5)`;
                ctx.lineWidth = 1;
                ctx.strokeRect(cx - 7, city.y + 1, 14, 11);
                // Emitter nub poking through terrain
                ctx.fillStyle = `rgb(${r}, ${g}, ${bv})`;
                ctx.fillRect(cx - 2, city.y - 2, 4, 4);
                // Glow on emitter
                ctx.fillStyle = `rgba(${r}, ${g}, ${bv}, ${0.3 + shimmer * 0.4})`;
                ctx.fillRect(cx - 1, city.y - 1, 2, 2);
                // Level indicator pips inside bunker
                for (let l = 0; l <= s.level; l++) {
                    ctx.fillStyle = `rgba(${r}, ${g}, ${bv}, ${l < s.level ? 0.9 : 0.3})`;
                    ctx.fillRect(cx - 5 + l * 4, city.y + 7, 2, 2);
                }

                // Shield arc (floating above buildings) — phosphor burn glow
                const lvlBoost = s.level * 0.12; // 0, 0.12, 0.24, 0.36

                // Outer bloom pass (wide soft glow)
                ctx.beginPath();
                for (let i = 0; i <= 30; i++) {
                    const t = (i / 30) * 2 - 1;
                    const px = cx + t * hw;
                    const py = edgeY - sag * (1 - t * t);
                    if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                }
                ctx.shadowColor = `rgba(${r}, ${g}, ${bv}, ${0.7 + lvlBoost})`;
                ctx.shadowBlur = 14 + s.level * 4;
                ctx.strokeStyle = `rgba(${r}, ${g}, ${bv}, ${0.15 + shimmer * 0.2})`;
                ctx.lineWidth = 4 + s.level;
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Mid glow pass
                ctx.beginPath();
                for (let i = 0; i <= 30; i++) {
                    const t = (i / 30) * 2 - 1;
                    const px = cx + t * hw;
                    const py = edgeY - sag * (1 - t * t);
                    if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                }
                ctx.shadowColor = `rgba(${Math.min(255, r + 60)}, ${Math.min(255, g + 60)}, ${Math.min(255, bv + 60)}, ${0.8 + lvlBoost})`;
                ctx.shadowBlur = 6 + s.level * 2;
                ctx.strokeStyle = `rgba(${r}, ${g}, ${bv}, ${0.35 + shimmer * 0.4 + lvlBoost * 0.3})`;
                ctx.lineWidth = 2 + s.level * 0.5;
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Core bright line — intensifies toward center with level
                // Draw segment by segment for center-weighted brightness
                for (let i = 0; i < 30; i++) {
                    const t0 = (i / 30) * 2 - 1;
                    const t1 = ((i + 1) / 30) * 2 - 1;
                    const tMid = (t0 + t1) / 2;
                    // Center weight: 1.0 at center, falls off toward edges
                    const centerW = 1 - tMid * tMid;
                    const coreAlpha = (0.5 + shimmer * 0.3 + centerW * lvlBoost * 0.8) * hpFrac;
                    const coreWidth = (1.5 + centerW * lvlBoost * 2) * (hpFrac > 0.5 ? 1 : 0.7);
                    // Brighten core color toward white at center with level
                    const cr = Math.min(255, r + Math.floor(centerW * lvlBoost * 200));
                    const cg = Math.min(255, g + Math.floor(centerW * lvlBoost * 200));
                    const cb = Math.min(255, bv + Math.floor(centerW * lvlBoost * 200));
                    ctx.beginPath();
                    ctx.moveTo(cx + t0 * hw, edgeY - sag * (1 - t0 * t0));
                    ctx.lineTo(cx + t1 * hw, edgeY - sag * (1 - t1 * t1));
                    ctx.strokeStyle = `rgba(${cr}, ${cg}, ${cb}, ${coreAlpha})`;
                    ctx.lineWidth = coreWidth;
                    ctx.stroke();
                }

                // Phosphor bloom fill band (subtle)
                ctx.beginPath();
                for (let i = 0; i <= 30; i++) {
                    const t = (i / 30) * 2 - 1;
                    ctx.lineTo(cx + t * hw, edgeY - sag * (1 - t * t) - 2);
                }
                for (let i = 30; i >= 0; i--) {
                    const t = (i / 30) * 2 - 1;
                    ctx.lineTo(cx + t * hw, edgeY - sag * (1 - t * t) + 3);
                }
                ctx.closePath();
                ctx.fillStyle = `rgba(${r}, ${g}, ${bv}, ${shimmer * hpFrac * 0.2 + lvlBoost * 0.1})`;
                ctx.fill();

                // Shimmer highlight sliding along arc
                const highlightX = cx + Math.sin(frameCount * 0.05 + s.x) * hw * 0.6;
                const highlightT = (highlightX - cx) / hw;
                const highlightY = edgeY - sag * (1 - highlightT * highlightT);
                ctx.fillStyle = `rgba(255, 255, 255, ${shimmer * 0.6 + lvlBoost * 0.15})`;
                ctx.fillRect(highlightX - 2, highlightY - 2, 4, 3);
            }
            ctx.restore();
        });
    }
};

const drawTurret = (ctx, t, isHovered, gameState, frameCount) => {
    const color = isHovered ? '#ffff00' : t.stats.color;

    // Range circle
    if (gameState === 'PLACEMENT' && isHovered) {
        const rangeGrad = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, t.stats.range);
        rangeGrad.addColorStop(0, 'rgba(0, 255, 0, 0.03)');
        rangeGrad.addColorStop(0.8, 'rgba(0, 255, 0, 0.02)');
        rangeGrad.addColorStop(1, 'rgba(0, 255, 0, 0)');
        ctx.fillStyle = rangeGrad;
        ctx.beginPath();
        ctx.arc(t.x, t.y, t.stats.range, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
        ctx.setLineDash([5, 5]);
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(t.x, t.y, t.stats.range, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    const angle = t.angle ?? Math.PI / 2;
    const recoil = t.recoilOffset || 0;

    if (t.type === 'FLAK') {
        // Concentric circles base
        ctx.fillStyle = '#000';
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(t.x, t.y, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(t.x, t.y, 6, 0, Math.PI * 2);
        ctx.stroke();

        // Dual barrels
        ctx.save();
        ctx.translate(t.x, t.y);
        ctx.rotate(angle + Math.PI / 2);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-2, recoil);
        ctx.lineTo(-2, 14 - recoil);
        ctx.moveTo(2, recoil);
        ctx.lineTo(2, 14 - recoil);
        ctx.stroke();
        ctx.restore();

    } else if (t.type === 'SAM') {
        // Triangle base
        ctx.fillStyle = '#000';
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(t.x - 10, t.y);
        ctx.lineTo(t.x, t.y - 8);
        ctx.lineTo(t.x + 10, t.y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Gradient fill
        const samGrad = ctx.createLinearGradient(t.x, t.y, t.x, t.y - 8);
        samGrad.addColorStop(0, 'rgba(0, 255, 255, 0.1)');
        samGrad.addColorStop(1, 'rgba(0, 255, 255, 0.3)');
        ctx.fillStyle = samGrad;
        ctx.beginPath();
        ctx.moveTo(t.x - 10, t.y);
        ctx.lineTo(t.x, t.y - 8);
        ctx.lineTo(t.x + 10, t.y);
        ctx.closePath();
        ctx.fill();

        // Launcher rail
        ctx.save();
        ctx.translate(t.x, t.y - 4);
        ctx.rotate(angle + Math.PI / 2);
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, recoil);
        ctx.lineTo(0, 14 - recoil);
        ctx.stroke();
        // Rail tick marks
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-2, 4);
        ctx.lineTo(2, 4);
        ctx.moveTo(-2, 8);
        ctx.lineTo(2, 8);
        ctx.stroke();
        ctx.restore();

    } else if (t.type === 'ARTILLERY') {
        // Heavy reinforced base
        ctx.fillStyle = '#000';
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(t.x - 16, t.y + 6);
        ctx.lineTo(t.x - 12, t.y - 6);
        ctx.lineTo(t.x + 12, t.y - 6);
        ctx.lineTo(t.x + 16, t.y + 6);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Pivot housing (circle where barrel mounts)
        ctx.fillStyle = '#000';
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(t.x, t.y - 4, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Long heavy cannon barrel
        ctx.save();
        ctx.translate(t.x, t.y - 4);
        ctx.rotate(angle + Math.PI / 2);
        // Barrel body — tapered
        ctx.fillStyle = '#000';
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(-3, recoil);
        ctx.lineTo(-2.5, 24 - recoil);
        ctx.lineTo(2.5, 24 - recoil);
        ctx.lineTo(3, recoil);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        // Muzzle brake
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-4.5, 22 - recoil);
        ctx.lineTo(-4.5, 25 - recoil);
        ctx.moveTo(4.5, 22 - recoil);
        ctx.lineTo(4.5, 25 - recoil);
        ctx.stroke();
        // Barrel ring
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-3, 10 - recoil);
        ctx.lineTo(3, 10 - recoil);
        ctx.stroke();
        ctx.restore();

    } else if (t.type === 'LASER') {
        // Octagon base
        ctx.fillStyle = '#000';
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            const a = (i / 8) * Math.PI * 2 - Math.PI / 8;
            const px = t.x + Math.cos(a) * 10;
            const py = t.y + Math.sin(a) * 10;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Pulsing inner ring
        const pulseAlpha = 0.3 + 0.7 * Math.abs(Math.sin(frameCount * 0.1 + (t.dwellTime || 0) * 0.05));
        ctx.strokeStyle = `rgba(255, 255, 0, ${pulseAlpha})`;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(t.x, t.y, 5, 0, Math.PI * 2);
        ctx.stroke();

        // Emitter stalk
        ctx.save();
        ctx.translate(t.x, t.y);
        ctx.rotate(angle + Math.PI / 2);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, 12);
        ctx.stroke();
        // Emitter tip dot
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(0, 13, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Heat bar
        const heat = t.laserHeat || 0;
        if (heat > 0) {
            const barW = 16;
            const barH = 2;
            const barX = t.x - barW / 2;
            const barY = t.y + 12;
            ctx.fillStyle = '#333';
            ctx.fillRect(barX, barY, barW, barH);
            const r = Math.min(255, Math.floor(heat * 2 * 255));
            const g = Math.max(0, Math.floor((1 - heat) * 200));
            ctx.fillStyle = t.laserOverheat
                ? (Math.floor(frameCount / 4) % 2 === 0 ? '#ff2200' : '#ff6600')
                : `rgb(${r}, ${g}, 0)`;
            ctx.fillRect(barX, barY, barW * heat, barH);
        }
    } else if (t.type === 'SWARM') {
        // Hexagonal base
        ctx.fillStyle = '#000';
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const a = (i / 6) * Math.PI * 2 - Math.PI / 6;
            const px = t.x + Math.cos(a) * 10;
            const py = t.y + Math.sin(a) * 10;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // 3 angled launcher tubes with missile tips
        ctx.save();
        ctx.translate(t.x, t.y);
        const tubeAngles = [Math.PI / 2 - 0.4, Math.PI / 2, Math.PI / 2 + 0.4];
        tubeAngles.forEach(ta => {
            ctx.save();
            ctx.rotate(ta + Math.PI / 2);
            // Tube
            ctx.strokeStyle = color;
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(0, 2 - recoil);
            ctx.lineTo(0, 12 - recoil);
            ctx.stroke();
            // Missile tip
            ctx.fillStyle = '#ff8800';
            ctx.beginPath();
            ctx.moveTo(0, 13 - recoil);
            ctx.lineTo(-1.5, 10 - recoil);
            ctx.lineTo(1.5, 10 - recoil);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        });
        ctx.restore();
    }

    // Muzzle flash
    if (t.muzzleFlashTimer > 0) {
        const flashMax = t.type === 'ARTILLERY' ? 10 : 8;
        const flashAlpha = t.muzzleFlashTimer / flashMax;
        ctx.save();
        ctx.translate(t.x, t.y);
        ctx.rotate(angle + Math.PI / 2);
        const barrelLen = t.type === 'ARTILLERY' ? 25 : t.type === 'SAM' ? 14 : 14;
        ctx.fillStyle = `rgba(255, 255, 200, ${flashAlpha})`;
        ctx.beginPath();
        ctx.arc(0, barrelLen, 4 + t.muzzleFlashTimer, 0, Math.PI * 2);
        ctx.fill();
        // Starburst
        ctx.strokeStyle = `rgba(255, 255, 255, ${flashAlpha * 0.7})`;
        ctx.lineWidth = 1;
        for (let i = 0; i < 4; i++) {
            const sa = (i / 4) * Math.PI * 2;
            ctx.beginPath();
            ctx.moveTo(Math.cos(sa) * 2 + 0, barrelLen + Math.sin(sa) * 2);
            ctx.lineTo(Math.cos(sa) * (5 + t.muzzleFlashTimer), barrelLen + Math.sin(sa) * (5 + t.muzzleFlashTimer));
            ctx.stroke();
        }
        ctx.restore();
    }

    // Level pips - chevrons
    ctx.fillStyle = color;
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    for (let i = 0; i < t.level; i++) {
        const pipX = t.x - ((t.level - 1) * 4) / 2 + (i * 4);
        const pipY = t.y + 14;
        ctx.beginPath();
        ctx.moveTo(pipX, pipY + 3);
        ctx.lineTo(pipX + 2, pipY);
        ctx.lineTo(pipX + 4, pipY + 3);
        ctx.stroke();
    }

    // Glowing ring at level 3+
    if (t.level >= 3) {
        ctx.strokeStyle = `rgba(${color === '#00ff00' ? '0,255,0' : color === '#00ffff' ? '0,255,255' : color === '#ff00ff' ? '255,0,255' : '255,255,0'}, ${0.2 + 0.15 * Math.sin(frameCount * 0.08)})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(t.x, t.y, 14, 0, Math.PI * 2);
        ctx.stroke();
    }

    // EMP disabled overlay
    if (t.empDisabled > 0) {
        // Flickering opacity
        const flickerOn = Math.floor(frameCount / 3) % 2 === 0;
        ctx.save();
        ctx.globalAlpha = flickerOn ? 0.6 : 0.3;
        ctx.fillStyle = '#004466';
        ctx.beginPath();
        ctx.arc(t.x, t.y, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        // Cyan sparks around base
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 1;
        for (let i = 0; i < 3; i++) {
            const a = frameCount * 0.2 + (i / 3) * Math.PI * 2;
            const r = 10 + Math.random() * 4;
            ctx.beginPath();
            ctx.moveTo(t.x + Math.cos(a) * 8, t.y + Math.sin(a) * 8);
            ctx.lineTo(t.x + Math.cos(a + 0.3) * r, t.y + Math.sin(a + 0.3) * r);
            ctx.stroke();
        }

        // "EMP" text
        const textAlpha = t.empDisabled > 30 ? 0.8 : t.empDisabled / 30 * 0.8;
        ctx.fillStyle = `rgba(0, 255, 255, ${textAlpha})`;
        ctx.font = '8px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('EMP', t.x, t.y - 16);
        ctx.restore();
    }
};

const drawBomber = (ctx, b, frameCount) => {
    const dir = b.vx > 0 ? 1 : -1;

    // Fuselage - hexagonal
    ctx.save();
    ctx.translate(b.x, b.y);

    // Swept-back wings
    ctx.fillStyle = '#cccc00';
    ctx.beginPath();
    ctx.moveTo(dir * -4, 0);
    ctx.lineTo(dir * -12, -10);
    ctx.lineTo(dir * -8, 0);
    ctx.moveTo(dir * -4, 0);
    ctx.lineTo(dir * -12, 10);
    ctx.lineTo(dir * -8, 0);
    ctx.fill();

    // Fuselage gradient
    const fuseGrad = ctx.createLinearGradient(0, -5, 0, 5);
    fuseGrad.addColorStop(0, '#ffff44');
    fuseGrad.addColorStop(0.5, '#cccc00');
    fuseGrad.addColorStop(1, '#888800');
    ctx.fillStyle = fuseGrad;
    ctx.beginPath();
    ctx.moveTo(dir * 12, 0);
    ctx.lineTo(dir * 6, -5);
    ctx.lineTo(dir * -6, -5);
    ctx.lineTo(dir * -10, 0);
    ctx.lineTo(dir * -6, 5);
    ctx.lineTo(dir * 6, 5);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = '#aaaa00';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Cockpit
    ctx.fillStyle = '#aaffaa';
    ctx.fillRect(dir * 6, -2, dir * 4, 4);

    // Engine glow
    const enginePulse = 0.5 + 0.5 * Math.sin(frameCount * 0.3);
    ctx.fillStyle = `rgba(255, 150, 0, ${0.4 + enginePulse * 0.4})`;
    ctx.beginPath();
    ctx.ellipse(dir * -11, 0, 3 + enginePulse * 2, 2 + enginePulse, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();

    // HP bar
    if (b.hp < b.maxHp) {
        drawHPBar(ctx, b.x - 12, b.y - 16, 24, 3, b.hp / b.maxHp);
    }
};

const drawBossShip = (ctx, b, frameCount) => {
    // Don't draw while off-screen
    if (b.reentryTimer > 0) return;

    const dir = b.vx > 0 ? 1 : -1;
    const scale = b.bossTier >= 2 ? 7.5 : 5.4;
    const isMega = b.bossTier >= 2;
    const hpRatio = b.hp / b.maxHp;

    ctx.save();
    ctx.translate(b.x, b.y);

    // Shield visual (drawn behind ship)
    if (b.shieldActive && b.shield > 0) {
        const shieldAlpha = 0.15 + 0.1 * Math.sin(frameCount * 0.08);
        const shieldRadius = 20 * scale;
        ctx.save();
        ctx.strokeStyle = `rgba(0, 255, 255, ${shieldAlpha + 0.3})`;
        ctx.lineWidth = 2;
        // Hexagonal shield outline
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const a = (i / 6) * Math.PI * 2 + frameCount * 0.01;
            const px = Math.cos(a) * shieldRadius;
            const py = Math.sin(a) * shieldRadius * 0.7;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.stroke();
        ctx.fillStyle = `rgba(0, 255, 255, ${shieldAlpha})`;
        ctx.fill();
        ctx.restore();
    }

    // EMP charge glow (cyan, intensifies as charge builds)
    if (b.empCharge > 0 && b.empWindup <= 0) {
        const chargeRatio = b.empCharge / b.empMaxCharge;
        ctx.save();
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = chargeRatio * 15;
        ctx.fillStyle = `rgba(0, 255, 255, ${chargeRatio * 0.3})`;
        ctx.beginPath();
        ctx.arc(0, 0, 12 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    // EMP windup - blue arcs crackling
    if (b.empWindup > 0) {
        ctx.save();
        ctx.strokeStyle = `rgba(100, 150, 255, ${0.5 + 0.5 * Math.sin(frameCount * 0.5)})`;
        ctx.lineWidth = 2;
        for (let i = 0; i < 4; i++) {
            const a = (i / 4) * Math.PI * 2 + frameCount * 0.3;
            const r = 10 * scale;
            ctx.beginPath();
            ctx.moveTo(Math.cos(a) * r * 0.5, Math.sin(a) * r * 0.5);
            const mid1x = Math.cos(a + 0.3) * r * 0.75 + (Math.random() - 0.5) * 6;
            const mid1y = Math.sin(a + 0.3) * r * 0.75 + (Math.random() - 0.5) * 6;
            ctx.lineTo(mid1x, mid1y);
            ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
            ctx.stroke();
        }
        ctx.restore();
    }

    // Cluster bomb windup - orange glow
    if (b.clusterWindup > 0) {
        ctx.save();
        ctx.shadowColor = '#ff8800';
        ctx.shadowBlur = 12;
        ctx.fillStyle = `rgba(255, 136, 0, ${0.2 + 0.2 * Math.sin(frameCount * 0.4)})`;
        ctx.beginPath();
        ctx.arc(0, 0, 10 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    // Pulsing red glow
    ctx.save();
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 10 + 6 * Math.sin(frameCount * 0.12);

    // Swept-back wings (scaled)
    ctx.fillStyle = isMega ? '#880000' : '#993300';
    ctx.beginPath();
    ctx.moveTo(dir * -4 * scale, 0);
    ctx.lineTo(dir * -12 * scale, -10 * scale);
    ctx.lineTo(dir * -8 * scale, 0);
    ctx.moveTo(dir * -4 * scale, 0);
    ctx.lineTo(dir * -12 * scale, 10 * scale);
    ctx.lineTo(dir * -8 * scale, 0);
    ctx.fill();

    // Mega-boss: spiky wing protrusions
    if (isMega) {
        ctx.fillStyle = '#aa0000';
        ctx.beginPath();
        ctx.moveTo(dir * -8 * scale, -8 * scale);
        ctx.lineTo(dir * -14 * scale, -14 * scale);
        ctx.lineTo(dir * -10 * scale, -6 * scale);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(dir * -8 * scale, 8 * scale);
        ctx.lineTo(dir * -14 * scale, 14 * scale);
        ctx.lineTo(dir * -10 * scale, 6 * scale);
        ctx.fill();
    }

    // Fuselage gradient (red-orange)
    const fuseGrad = ctx.createLinearGradient(0, -5 * scale, 0, 5 * scale);
    fuseGrad.addColorStop(0, isMega ? '#ff2200' : '#ff6633');
    fuseGrad.addColorStop(0.5, isMega ? '#cc0000' : '#cc4400');
    fuseGrad.addColorStop(1, isMega ? '#880000' : '#882200');
    ctx.fillStyle = fuseGrad;
    ctx.beginPath();
    ctx.moveTo(dir * 12 * scale, 0);
    ctx.lineTo(dir * 6 * scale, -5 * scale);
    ctx.lineTo(dir * -6 * scale, -5 * scale);
    ctx.lineTo(dir * -10 * scale, 0);
    ctx.lineTo(dir * -6 * scale, 5 * scale);
    ctx.lineTo(dir * 6 * scale, 5 * scale);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = isMega ? '#ff4444' : '#cc6633';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.restore(); // end shadowBlur

    // Cockpit
    ctx.fillStyle = '#ff8866';
    ctx.fillRect(dir * 6 * scale, -2 * scale, dir * 4 * scale, 4 * scale);

    // --- Damage effects based on HP ---
    if (hpRatio < 0.75) {
        // Light smoke puffs
        const smokeCount = hpRatio < 0.25 ? 4 : hpRatio < 0.5 ? 3 : 1;
        for (let i = 0; i < smokeCount; i++) {
            const hash = (frameCount * 3 + i * 137) & 0xFF;
            const sx = (hash % 20 - 10) * scale * 0.5;
            const sy = (hash % 14 - 7) * scale * 0.4;
            const smokeAlpha = (0.15 + (hash % 10) * 0.02) * (1 - hpRatio);
            ctx.fillStyle = `rgba(80, 80, 80, ${smokeAlpha})`;
            const drift = Math.sin(frameCount * 0.04 + i) * 3;
            ctx.beginPath();
            ctx.arc(sx + drift, sy - Math.abs(Math.sin(frameCount * 0.02 + i)) * 8, 3 + (1 - hpRatio) * 4, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    if (hpRatio < 0.5) {
        // Hull breach gashes
        ctx.strokeStyle = `rgba(40, 10, 0, ${0.8 - hpRatio})`;
        ctx.lineWidth = 2;
        const gashCount = hpRatio < 0.25 ? 4 : 2;
        for (let i = 0; i < gashCount; i++) {
            const gx = ((i * 97 + 31) % 16 - 8) * scale * 0.4;
            const gy = ((i * 53 + 17) % 10 - 5) * scale * 0.3;
            ctx.beginPath();
            ctx.moveTo(gx - 3, gy - 2);
            ctx.lineTo(gx + 3, gy + 2);
            ctx.stroke();
        }
        // Fire at breach points
        if (hpRatio < 0.5) {
            for (let i = 0; i < (hpRatio < 0.25 ? 3 : 1); i++) {
                const fx = ((i * 97 + 31) % 16 - 8) * scale * 0.4;
                const fy = ((i * 53 + 17) % 10 - 5) * scale * 0.3;
                const flicker = (frameCount + i * 7) % 3;
                ctx.fillStyle = flicker === 0 ? '#ff6600' : flicker === 1 ? '#ff3300' : '#ffaa00';
                ctx.fillRect(fx - 2, fy - 3 - Math.random() * 3, 4, 4);
            }
        }
    }
    if (hpRatio < 0.25) {
        // Critical: sparking electrical arcs
        ctx.strokeStyle = `rgba(100, 200, 255, ${0.5 + 0.5 * Math.sin(frameCount * 0.8)})`;
        ctx.lineWidth = 1;
        for (let i = 0; i < 3; i++) {
            const ax = (Math.sin(frameCount * 0.3 + i * 2) * 6) * scale * 0.3;
            const ay = (Math.cos(frameCount * 0.4 + i * 3) * 4) * scale * 0.3;
            ctx.beginPath();
            ctx.moveTo(ax, ay);
            ctx.lineTo(ax + (Math.random() - 0.5) * 12, ay + (Math.random() - 0.5) * 8);
            ctx.stroke();
        }
    }

    // Dual engine glows
    const enginePulse = 0.5 + 0.5 * Math.sin(frameCount * 0.25);
    const bombRunBoost = b.bombRunning > 0 ? 1.5 : 1;
    ctx.fillStyle = `rgba(255, ${b.bombRunning > 0 ? 200 : 80}, 0, ${(0.5 + enginePulse * 0.4) * bombRunBoost})`;
    ctx.beginPath();
    ctx.ellipse(dir * -11 * scale, -2.5 * scale, (3 + enginePulse * 2) * scale * bombRunBoost, (1.5 + enginePulse) * scale * 0.7, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(dir * -11 * scale, 2.5 * scale, (3 + enginePulse * 2) * scale * bombRunBoost, (1.5 + enginePulse) * scale * 0.7, 0, 0, Math.PI * 2);
    ctx.fill();

    // Bombing run afterburner trail
    if (b.bombRunning > 0) {
        ctx.fillStyle = `rgba(255, 150, 50, ${0.3 + enginePulse * 0.3})`;
        ctx.beginPath();
        ctx.ellipse(dir * -16 * scale, 0, (6 + enginePulse * 4) * scale, (3 + enginePulse * 2) * scale * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    // Mega-boss: center engine
    if (isMega) {
        ctx.fillStyle = `rgba(255, 200, 50, ${(0.4 + enginePulse * 0.5) * bombRunBoost})`;
        ctx.beginPath();
        ctx.ellipse(dir * -12 * scale, 0, (4 + enginePulse * 3) * scale * bombRunBoost, (2 + enginePulse) * scale * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    // Point defense flash
    if (b.pdFlash > 0) {
        ctx.save();
        ctx.fillStyle = `rgba(255, 50, 50, ${b.pdFlash / 10 * 0.4})`;
        ctx.beginPath();
        ctx.arc(0, 0, 15 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    ctx.restore();

    // HP bar (below the ship so it's always visible)
    const barW = isMega ? 60 : 40;
    const barY = b.y + 12 * scale + 4;
    drawHPBar(ctx, b.x - barW / 2, barY, barW, 4, b.hp / b.maxHp);

    // EMP charge bar (below HP bar)
    if (b.empCharge > 0 || b.empWindup > 0) {
        const empRatio = b.empWindup > 0 ? 1 : b.empCharge / b.empMaxCharge;
        ctx.fillStyle = '#333';
        ctx.fillRect(b.x - barW / 2, barY + 6, barW, 2);
        ctx.fillStyle = b.empWindup > 0 ? '#6699ff' : '#00cccc';
        ctx.fillRect(b.x - barW / 2, barY + 6, barW * empRatio, 2);
    }

    // Shield HP bar (below EMP bar, only when active)
    if (b.shieldActive && b.shield > 0) {
        ctx.fillStyle = '#333';
        ctx.fillRect(b.x - barW / 2, barY + 10, barW, 2);
        ctx.fillStyle = '#00ffff';
        ctx.fillRect(b.x - barW / 2, barY + 10, barW * (b.shield / 200), 2);
    }
};

const drawEnemyMissile = (ctx, m, frameCount) => {
    const isBoss = m.type === 'BOSS';
    const angle = Math.atan2(m.vy, m.vx);
    const speed = Math.sqrt(m.vx * m.vx + m.vy * m.vy);

    // Exhaust trail
    if (m.trailHistory && m.trailHistory.length > 1) {
        for (let i = 0; i < m.trailHistory.length - 1; i++) {
            const t = m.trailHistory[i];
            const alpha = (i / m.trailHistory.length) * 0.5;
            const width = (i / m.trailHistory.length) * (isBoss ? 4 : 2);
            ctx.strokeStyle = m.color;
            ctx.globalAlpha = alpha;
            ctx.lineWidth = width;
            ctx.beginPath();
            ctx.moveTo(t.x, t.y);
            ctx.lineTo(m.trailHistory[i + 1].x, m.trailHistory[i + 1].y);
            ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
    }

    ctx.save();
    ctx.translate(m.x, m.y);
    ctx.rotate(angle);

    if (m.type === 'NORMAL') {
        // Dart/arrowhead
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.moveTo(6, 0);
        ctx.lineTo(-4, -3);
        ctx.lineTo(-2, 0);
        ctx.lineTo(-4, 3);
        ctx.closePath();
        ctx.fill();
        // Glow dot at tail
        ctx.fillStyle = '#ffaa00';
        ctx.beginPath();
        ctx.arc(-3, 0, 1.5, 0, Math.PI * 2);
        ctx.fill();

    } else if (m.type === 'FAST') {
        // Elongated dart
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.moveTo(8, 0);
        ctx.lineTo(-5, -2.5);
        ctx.lineTo(-3, 0);
        ctx.lineTo(-5, 2.5);
        ctx.closePath();
        ctx.fill();
        // Speed lines
        ctx.strokeStyle = m.color;
        ctx.globalAlpha = 0.4;
        ctx.lineWidth = 1;
        for (let i = 0; i < 3; i++) {
            const y = -3 + i * 3;
            ctx.beginPath();
            ctx.moveTo(-8 - i * 4, y);
            ctx.lineTo(-14 - i * 4, y);
            ctx.stroke();
        }
        ctx.globalAlpha = 1.0;

    } else if (m.type === 'ARMORED') {
        // Larger diamond with inner diamond
        ctx.fillStyle = '#aaaaaa';
        ctx.beginPath();
        ctx.moveTo(7, 0);
        ctx.lineTo(0, -5);
        ctx.lineTo(-7, 0);
        ctx.lineTo(0, 5);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.stroke();
        // Inner diamond
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.moveTo(3, 0);
        ctx.lineTo(0, -2);
        ctx.lineTo(-3, 0);
        ctx.lineTo(0, 2);
        ctx.closePath();
        ctx.fill();
        // Partial shield arc
        ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(0, 0, 7, -0.8, 0.8);
        ctx.stroke();

    } else if (m.type === 'BOSS') {
        // Hexagonal head with pulsing glow
        ctx.save();
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 8 + 4 * Math.sin(frameCount * 0.15);
        ctx.fillStyle = '#cc0000';
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const a = (i / 6) * Math.PI * 2;
            const px = Math.cos(a) * 8;
            const py = Math.sin(a) * 8;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
        // Inner detail
        ctx.fillStyle = '#ff4444';
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const a = (i / 6) * Math.PI * 2;
            const px = Math.cos(a) * 4;
            const py = Math.sin(a) * 4;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();

    } else if (m.type === 'MIRV') {
        // Body
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.moveTo(5, 0);
        ctx.lineTo(-4, -3);
        ctx.lineTo(-4, 3);
        ctx.closePath();
        ctx.fill();
        // 3 warhead circles at nose
        ctx.fillStyle = '#ffcc00';
        const wobble = Math.sin(frameCount * 0.2) * 0.3;
        ctx.beginPath();
        ctx.arc(6, wobble - 2, 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(6, wobble + 2, 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(7, wobble, 1.5, 0, Math.PI * 2);
        ctx.fill();

    } else {
        // Fallback
        ctx.fillStyle = m.color;
        const s = m.size || 4;
        ctx.fillRect(-s / 2, -s / 2, s, s);
    }

    ctx.restore();

    // Boss ember particles spawned in update, not draw

    // HP bar
    if (m.hp < m.maxHp || isBoss) {
        const barW = isBoss ? 40 : 16;
        const barOff = isBoss ? 22 : 12;
        drawHPBar(ctx, m.x - barW / 2, m.y - barOff, barW, isBoss ? 4 : 2, m.hp / m.maxHp);
    }
};

const drawPlayerMissile = (ctx, m) => {
    const angle = Math.atan2(m.vy, m.vx);

    if (m.type === 'FLAK') {
        // Bright dot + trailing circles
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.arc(m.x, m.y, 2.5, 0, Math.PI * 2);
        ctx.fill();
        for (let i = 1; i <= 3; i++) {
            ctx.globalAlpha = 0.6 - i * 0.15;
            ctx.beginPath();
            ctx.arc(m.x - m.vx * i * 0.3, m.y - m.vy * i * 0.3, 2 - i * 0.4, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1.0;

    } else if (m.type === 'SAM') {
        // Elongated diamond oriented along velocity
        ctx.save();
        ctx.translate(m.x, m.y);
        ctx.rotate(angle);
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.moveTo(5, 0);
        ctx.lineTo(0, -2);
        ctx.lineTo(-3, 0);
        ctx.lineTo(0, 2);
        ctx.closePath();
        ctx.fill();
        // Orange exhaust
        ctx.fillStyle = '#ff8800';
        ctx.beginPath();
        ctx.arc(-4, 0, 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Occasional smoke particle (faint)
        if (Math.random() < 0.3) {
            ctx.globalAlpha = 0.2;
            ctx.fillStyle = '#888';
            ctx.beginPath();
            ctx.arc(m.x - m.vx * 2 + (Math.random() - 0.5) * 3, m.y - m.vy * 2 + (Math.random() - 0.5) * 3, 1, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }

    } else if (m.type === 'ARTILLERY') {
        // High-velocity shell — bright elongated tracer
        const speed = Math.sqrt(m.vx * m.vx + m.vy * m.vy);
        const nx = m.vx / speed;
        const ny = m.vy / speed;
        // Hot white core streak
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.moveTo(m.x, m.y);
        ctx.lineTo(m.x - nx * 12, m.y - ny * 12);
        ctx.stroke();
        // Magenta outer glow
        ctx.strokeStyle = 'rgba(255, 0, 255, 0.6)';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(m.x, m.y);
        ctx.lineTo(m.x - nx * 10, m.y - ny * 10);
        ctx.stroke();
        // Bright tip
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(m.x, m.y, 1.5, 0, Math.PI * 2);
        ctx.fill();

    } else if (m.type === 'SWARM') {
        // Small orange triangle, flashes yellow when dodging
        ctx.save();
        ctx.translate(m.x, m.y);
        ctx.rotate(angle);
        ctx.fillStyle = m.dodging ? '#ffff00' : '#ff8800';
        ctx.beginPath();
        ctx.moveTo(4, 0);
        ctx.lineTo(-2, -2);
        ctx.lineTo(-2, 2);
        ctx.closePath();
        ctx.fill();
        // Tiny exhaust dot
        ctx.fillStyle = '#ff4400';
        ctx.beginPath();
        ctx.arc(-3, 0, 1, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

    } else {
        // Default
        ctx.fillStyle = m.color;
        ctx.beginPath();
        ctx.arc(m.x, m.y, 2, 0, Math.PI * 2);
        ctx.fill();
    }
};

const drawPdcProjectile = (ctx, p) => {
    const alpha = 1 - p.life / p.maxLife;
    // Long tracer line (velocity trail)
    ctx.save();
    ctx.globalAlpha = alpha * 0.5;
    ctx.strokeStyle = '#ff6644';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(p.x, p.y);
    ctx.lineTo(p.x - p.vx * 1.2, p.y - p.vy * 1.2);
    ctx.stroke();
    // Hot core tracer
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = '#ffcc88';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(p.x, p.y);
    ctx.lineTo(p.x - p.vx * 0.6, p.y - p.vy * 0.6);
    ctx.stroke();
    // Bright tip
    ctx.fillStyle = '#ffffff';
    ctx.globalAlpha = alpha * 0.9;
    ctx.fillRect(p.x - 0.5, p.y - 0.5, 1.5, 1.5);
    ctx.restore();
};

const drawLaserBeam = (ctx, l) => {
    const w = l.width || 2;
    const alpha = Math.min(1, l.life / 3);

    // Outer glow
    ctx.save();
    ctx.shadowColor = l.color;
    ctx.shadowBlur = 8;
    ctx.strokeStyle = l.color;
    ctx.lineWidth = w + 2;
    ctx.globalAlpha = alpha * 0.6;
    ctx.beginPath();
    ctx.moveTo(l.x1, l.y1);
    ctx.lineTo(l.x2, l.y2);
    ctx.stroke();
    ctx.restore();

    // Main beam
    ctx.strokeStyle = l.color;
    ctx.lineWidth = w + 1;
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.moveTo(l.x1, l.y1);
    ctx.lineTo(l.x2, l.y2);
    ctx.stroke();

    // Core white
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = Math.max(1, w - 1);
    ctx.beginPath();
    ctx.moveTo(l.x1, l.y1);
    ctx.lineTo(l.x2, l.y2);
    ctx.stroke();

    // Energy crackle - 3 random fork lines
    if (w > 2) {
        ctx.strokeStyle = l.color;
        ctx.lineWidth = 1;
        ctx.globalAlpha = alpha * 0.5;
        const dx = l.x2 - l.x1;
        const dy = l.y2 - l.y1;
        const len = Math.sqrt(dx * dx + dy * dy);
        const nx = -dy / len;
        const ny = dx / len;
        for (let i = 0; i < 3; i++) {
            const t = 0.2 + Math.random() * 0.6;
            const mx = l.x1 + dx * t;
            const my = l.y1 + dy * t;
            const forkLen = (4 + Math.random() * 8) * (Math.random() > 0.5 ? 1 : -1);
            ctx.beginPath();
            ctx.moveTo(mx, my);
            ctx.lineTo(mx + nx * forkLen, my + ny * forkLen);
            ctx.stroke();
        }
    }

    // Impact point glow
    ctx.globalAlpha = alpha * 0.8;
    const impactGrad = ctx.createRadialGradient(l.x2, l.y2, 0, l.x2, l.y2, 6 + w);
    impactGrad.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
    impactGrad.addColorStop(0.5, l.color);
    impactGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = impactGrad;
    ctx.beginPath();
    ctx.arc(l.x2, l.y2, 6 + w, 0, Math.PI * 2);
    ctx.fill();

    ctx.globalAlpha = 1.0;
};

const drawExplosion = (ctx, ex) => {
    if (ex.radius < 1) return;

    // Filled radial gradient
    const pct = ex.growing ? (ex.radius / ex.maxRadius) : (ex.radius / ex.maxRadius);
    const grad = ctx.createRadialGradient(ex.x, ex.y, 0, ex.x, ex.y, ex.radius);

    // Parse color for secondary
    const isWhite = ex.color === '#fff' || ex.color === '#ffffff';
    const primaryColor = ex.color;

    if (ex.growing) {
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.3, primaryColor);
        grad.addColorStop(0.7, isWhite ? 'rgba(255, 200, 100, 0.4)' : primaryColor);
        grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    } else {
        const fadeAlpha = Math.max(0, ex.radius / ex.maxRadius);
        grad.addColorStop(0, primaryColor);
        grad.addColorStop(0.5, `rgba(255, 100, 0, ${fadeAlpha * 0.5})`);
        grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    }

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(ex.x, ex.y, ex.radius, 0, Math.PI * 2);
    ctx.fill();

    // Hot white core during growing
    if (ex.growing && ex.radius > 3) {
        ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * (1 - ex.radius / ex.maxRadius)})`;
        ctx.beginPath();
        ctx.arc(ex.x, ex.y, ex.radius * 0.3, 0, Math.PI * 2);
        ctx.fill();
    }

    // Shockwave ring
    if (ex.shockwaveRadius > 0 && ex.shockwaveRadius < ex.maxRadius * 2.5) {
        ctx.strokeStyle = `rgba(255, 255, 255, ${0.15 * (1 - ex.shockwaveRadius / (ex.maxRadius * 2.5))})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(ex.x, ex.y, ex.shockwaveRadius, 0, Math.PI * 2);
        ctx.stroke();
    }

    // Outline ring
    ctx.strokeStyle = primaryColor;
    ctx.globalAlpha = 0.4;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(ex.x, ex.y, ex.radius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1.0;
};

const drawMushroomCloud = (ctx, mc) => {
    const t = mc.age / mc.maxAge; // 0 to 1
    if (t >= 1) return;

    const alpha = 1 - t * t; // fade out
    // Stem rises quickly then slows
    const rise = Math.min(t * 2.5, 1); // 0→1 over first 40% of life
    const stemH = rise * mc.maxHeight;
    const capY = mc.y - stemH;
    // Cap expands after stem has risen partway
    const capT = Math.max(0, (t - 0.1) / 0.5); // starts at t=0.1, full at t=0.6
    const capW = mc.capSize * Math.min(capT, 1); // horizontal radius
    const capH = capW * 0.35; // flattened ellipse

    ctx.save();
    ctx.globalAlpha = alpha;

    // Stem — wider at base, narrow at top
    const stemW = 5 + t * 10;
    if (stemH > 3) {
        const stemGrad = ctx.createLinearGradient(mc.x, mc.y, mc.x, capY);
        stemGrad.addColorStop(0, 'rgba(180, 120, 60, 0.7)');
        stemGrad.addColorStop(0.5, 'rgba(200, 150, 80, 0.6)');
        stemGrad.addColorStop(1, 'rgba(220, 180, 120, 0.4)');
        ctx.fillStyle = stemGrad;
        ctx.beginPath();
        ctx.moveTo(mc.x - stemW * 0.7, mc.y);
        ctx.lineTo(mc.x - stemW * 0.25, capY + capH * 0.5);
        ctx.lineTo(mc.x + stemW * 0.25, capY + capH * 0.5);
        ctx.lineTo(mc.x + stemW * 0.7, mc.y);
        ctx.closePath();
        ctx.fill();
    }

    // Cap — wide flat mushroom dome rising with stem
    if (capW > 2) {
        const capGrad = ctx.createRadialGradient(mc.x, capY, 0, mc.x, capY, capW);
        capGrad.addColorStop(0, `rgba(255, 240, 180, ${0.9 * alpha})`);
        capGrad.addColorStop(0.3, `rgba(255, 180, 80, ${0.8 * alpha})`);
        capGrad.addColorStop(0.6, `rgba(220, 120, 50, ${0.6 * alpha})`);
        capGrad.addColorStop(1, `rgba(150, 70, 30, ${0.25 * alpha})`);
        ctx.fillStyle = capGrad;
        ctx.beginPath();
        ctx.ellipse(mc.x, capY, capW, capH, 0, 0, Math.PI * 2);
        ctx.fill();

        // Hot core
        ctx.fillStyle = `rgba(255, 255, 200, ${0.6 * alpha * (1 - t)})`;
        ctx.beginPath();
        ctx.ellipse(mc.x, capY, capW * 0.3, capH * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.restore();
};

const drawGroundFire = (ctx, fire, frameCount) => {
    const flicker = Math.sin(frameCount * 0.15 + fire.x * 7) * 0.3 + 0.7;
    const s = fire.size;

    // Fire glow
    ctx.fillStyle = `rgba(255, 100, 0, ${0.3 * flicker})`;
    ctx.beginPath();
    ctx.arc(fire.x, fire.y - s, s * 2, 0, Math.PI * 2);
    ctx.fill();

    // Flame tongues
    for (let i = 0; i < 3; i++) {
        const fx = fire.x + Math.sin(frameCount * 0.1 + i * 2 + fire.x) * s * 0.6;
        const fh = s * (0.8 + Math.sin(frameCount * 0.2 + i * 3) * 0.4);
        ctx.fillStyle = i === 0 ? `rgba(255, 200, 50, ${0.8 * flicker})`
                       : `rgba(255, 80, 0, ${0.6 * flicker})`;
        ctx.fillRect(fx - 1, fire.y - fh, 2, fh);
    }

    // Rising smoke column
    const smokeAge = (frameCount + fire.x * 100) % 60;
    const smokeY = fire.y - s * 2 - smokeAge * 0.5;
    const smokeAlpha = Math.max(0, 0.3 - smokeAge * 0.005);
    ctx.fillStyle = `rgba(80, 80, 80, ${smokeAlpha})`;
    ctx.beginPath();
    ctx.arc(fire.x + Math.sin(smokeAge * 0.1) * 3, smokeY, 2 + smokeAge * 0.08, 0, Math.PI * 2);
    ctx.fill();
};

const drawParticle = (ctx, p) => {
    const lifeRatio = p.life / p.maxLife;
    const alpha = lifeRatio;
    const size = (p.size || 2) * lifeRatio;
    if (size < 0.3) return;

    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;

    // Trail: dim copy at previous position
    if (p.vx !== 0 || p.vy !== 0) {
        ctx.globalAlpha = alpha * 0.3;
        const prevSize = size * 0.7;
        if (p.shape === 'circle') {
            ctx.beginPath();
            ctx.arc(p.x - p.vx, p.y - p.vy, prevSize / 2, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.fillRect(p.x - p.vx - prevSize / 2, p.y - p.vy - prevSize / 2, prevSize, prevSize);
        }
        ctx.globalAlpha = alpha;
    }

    if (p.shape === 'circle') {
        ctx.beginPath();
        ctx.arc(p.x, p.y, size / 2, 0, Math.PI * 2);
        ctx.fill();
    } else {
        ctx.fillRect(p.x - size / 2, p.y - size / 2, size, size);
    }

    ctx.globalAlpha = 1.0;
};

const drawHPBar = (ctx, x, y, w, h, pct) => {
    pct = Math.max(0, Math.min(1, pct));
    // Border
    ctx.fillStyle = '#111';
    ctx.fillRect(x - 1, y - 1, w + 2, h + 2);
    // Background
    ctx.fillStyle = '#330000';
    ctx.fillRect(x, y, w, h);
    // Fill - color shifts green->yellow->red
    let barColor;
    if (pct > 0.6) barColor = '#00ff00';
    else if (pct > 0.3) barColor = '#ffff00';
    else barColor = '#ff0000';
    ctx.fillStyle = barColor;
    ctx.fillRect(x, y, w * pct, h);
};

// ============================================================

const App = () => {
  const canvasRef = useRef(null);
  const requestRef = useRef();

  // Game State
  const [gameState, setGameState] = useState('START');
  const [money, setMoney] = useState(3500);
  const [score, setScore] = useState(0);
  const [level, setLevel] = useState(1);
  const [message, setMessage] = useState('');
  const [bonusReport, setBonusReport] = useState(null);

  // Entities
  const [cities, setCities] = useState([]);
  const turrets = useRef([]);

  // Refs
  const enemyMissiles = useRef([]);
  const bombers = useRef([]);
  const playerMissiles = useRef([]);
  const lasers = useRef([]);
  const explosions = useRef([]);
  const particles = useRef([]);
  const empPulses = useRef([]);
  const pdcProjectiles = useRef([]);
  const terrain = useRef([]);
  const upperTerrain = useRef([]);
  const lowerTerrain = useRef([]);
  const mousePos = useRef({ x: 0, y: 0 });
  const blinkTimer = useRef(0);
  const frameCount = useRef(0);
  const screenShake = useRef(0);
  const screenFlash = useRef(0);
  const mushroomClouds = useRef([]);
  const groundFires = useRef([]);
  const mapData = useRef({ stars: [], bgTerrain: [], vegetation: [] });
  const shieldCount = useRef(0);

  // Placement State
  const [selectedAction, setSelectedAction] = useState(null);
  const [hoveredTurret, setHoveredTurret] = useState(null);

  // Level Config
  const levelConfig = useRef({
    spawnTimer: 0,
    spawnInterval: 100,
    totalToSpawn: 0,
    bomberTimer: 0
  });
  const waveCompleted = useRef(false);

  // --- City Building Generator ---
  const TIER_CONFIG = [
      { buildings: [1, 3], heightScale: 0.6, spread: 15, antennaChance: 0, gradTop: '#009999', gradBot: '#004444', glowColor: [0, 120, 120], glowRadius: 30, glowAlpha: 0.04, styles: ['flat'] },
      { buildings: [4, 8], heightScale: 1.0, spread: 35, antennaChance: 0.2, gradTop: '#00cccc', gradBot: '#005566', glowColor: [0, 180, 180], glowRadius: 60, glowAlpha: 0.08, styles: ['flat', 'pointed'] },
      { buildings: [6, 10], heightScale: 1.3, spread: 40, antennaChance: 0.3, gradTop: '#00eeff', gradBot: '#006677', glowColor: [0, 220, 220], glowRadius: 70, glowAlpha: 0.10, styles: ['flat', 'pointed', 'stepped'] },
      { buildings: [8, 12], heightScale: 1.6, spread: 45, antennaChance: 0.4, gradTop: '#aaddff', gradBot: '#2255aa', glowColor: [100, 180, 255], glowRadius: 80, glowAlpha: 0.12, styles: ['flat', 'pointed', 'stepped', 'dome'] },
      { buildings: [10, 14], heightScale: 1.9, spread: 50, antennaChance: 0.5, gradTop: '#cc88ff', gradBot: '#3322aa', glowColor: [160, 100, 255], glowRadius: 90, glowAlpha: 0.14, styles: ['pointed', 'stepped', 'dome'] },
      { buildings: [12, 16], heightScale: 2.2, spread: 55, antennaChance: 0.6, gradTop: '#ffdd66', gradBot: '#aa6600', glowColor: [255, 200, 80], glowRadius: 100, glowAlpha: 0.16, styles: ['pointed', 'stepped', 'dome'] },
  ];

  const generateCityBuildings = (tier) => {
      const cfg = TIER_CONFIG[Math.min(tier, 5)];
      const buildings = [];
      const count = cfg.buildings[0] + Math.floor(Math.random() * (cfg.buildings[1] - cfg.buildings[0]));
      for (let b = 0; b < count; b++) {
          const bw = (6 + Math.random() * 12) * cfg.heightScale;
          const bh = (15 + Math.random() * 25) * cfg.heightScale;
          const style = cfg.styles[Math.floor(Math.random() * cfg.styles.length)];
          const windows = [];
          const cols = Math.max(1, Math.floor(bw / 4));
          const rows = Math.max(1, Math.floor(bh / 6));
          for (let wy = 0; wy < rows; wy++) {
              for (let wx = 0; wx < cols; wx++) {
                  windows.push({
                      ox: 2 + wx * (bw / cols),
                      oy: 3 + wy * (bh / rows),
                      phase: Math.floor(Math.random() * 10)
                  });
              }
          }
          buildings.push({
              w: bw,
              h: bh,
              xOffset: (Math.random() - 0.5) * cfg.spread,
              style,
              windows,
              hasAntenna: bh > 20 && Math.random() < cfg.antennaChance,
              damage: 0
          });
      }
      return buildings;
  };

  // --- Map Generation ---
  const generateMap = useCallback((numCities) => {
    const segments = 80;
    const segmentWidth = GAME_WIDTH / segments;

    // === Upper terrain (turret zone): gentle rolling hills with plateaus ===
    const upperPoints = [];
    for (let i = 0; i <= segments; i++) {
        const x = i * segmentWidth;
        const base = 460;
        const y = base - Math.sin(i * 0.15) * 50 - Math.cos(i * 0.08) * 35 + (Math.random() - 0.5) * 12;
        upperPoints.push({ x, y: Math.max(340, Math.min(520, y)) });
    }
    // Post-process: create plateaus by flattening local minima (highest elevation = lowest y)
    for (let i = 2; i < upperPoints.length - 2; i++) {
        if (upperPoints[i].y < upperPoints[i - 1].y && upperPoints[i].y < upperPoints[i + 1].y) {
            const flatY = upperPoints[i].y;
            upperPoints[i - 1].y = flatY;
            upperPoints[i + 1].y = flatY;
        }
    }
    // Additional plateaus every ~150-200px for turret placement
    for (let x = 100; x < GAME_WIDTH - 100; x += 150 + Math.random() * 50) {
        const idx = Math.round(x / segmentWidth);
        if (idx > 1 && idx < upperPoints.length - 2) {
            const flatY = Math.min(upperPoints[idx - 1].y, upperPoints[idx].y, upperPoints[idx + 1].y);
            for (let d = -1; d <= 1; d++) {
                upperPoints[idx + d].y = flatY;
            }
        }
    }

    // === Lower terrain (city zone): very flat ground plane ===
    const lowerPoints = [];
    const citySlots = [];
    // Place cities at 1/3 and 2/3 (or evenly spaced for other counts)
    for (let i = 0; i < numCities; i++) {
        const cx = GAME_WIDTH * ((i + 1) / (numCities + 1));
        citySlots.push({ x: cx, w: 40 });
    }
    for (let i = 0; i <= segments; i++) {
        const x = i * segmentWidth;
        // Very flat terrain with minimal undulation
        const undulation = Math.sin(i * 0.12) * 2 + (Math.random() - 0.5) * 1;
        const y = LOWER_TERRAIN_Y + undulation;
        lowerPoints.push({ x, y: Math.max(LOWER_TERRAIN_Y - 5, Math.min(LOWER_TERRAIN_Y + 5, y)) });
    }

    // Store both terrain arrays
    upperTerrain.current = upperPoints;
    lowerTerrain.current = lowerPoints;
    terrain.current = upperPoints; // backward compat for player missiles

    // Generate stars
    const stars = [];
    for (let i = 0; i < 100; i++) {
        stars.push({
            x: Math.random() * GAME_WIDTH,
            y: Math.random() * (GAME_HEIGHT * 0.6),
            brightness: 0.3 + Math.random() * 0.7,
            twinklePhase: Math.random() * Math.PI * 2,
            size: Math.random() > 0.7 ? 2 : 1,
            color: Math.random() > 0.8 ? '#aaccff' : '#ffffff'
        });
    }

    // Background mountains (behind upper terrain)
    const bgTerrain = [];
    for (let i = 0; i <= segments; i++) {
        const x = i * segmentWidth;
        const noise = Math.random() * 15;
        const bgY = 280 + Math.sin(i * 0.12 + 1) * 40 + Math.cos(i * 0.06 + 2) * 30 + noise;
        bgTerrain.push({ x, y: bgY });
    }

    // Vegetation on upper terrain gentle slopes
    const vegetation = [];
    for (let i = 0; i < upperPoints.length - 1; i++) {
        const p1 = upperPoints[i];
        const p2 = upperPoints[i + 1];
        const slope = Math.abs(p2.y - p1.y) / (p2.x - p1.x || 1);
        if (slope < 0.3) {
            const count = Math.floor(Math.random() * 3);
            for (let v = 0; v < count; v++) {
                const vx = p1.x + (p2.x - p1.x) * Math.random();
                const vy = p1.y + (p2.y - p1.y) * Math.random();
                vegetation.push({
                    x: vx, y: vy,
                    h: 2 + Math.random() * 4,
                    color: ['#004400', '#006600', '#003300', '#005500'][Math.floor(Math.random() * 4)]
                });
            }
        }
    }

    mapData.current = { stars, bgTerrain, vegetation };

    // Cities on lower terrain — start small (tier 1, reduced building count)
    const newCities = citySlots.map(slot => {
        const cy = getTerrainHeight(slot.x, lowerPoints);
        const buildings = generateCityBuildings(1);
        // Start with fewer buildings (reduce by ~40%)
        const reduced = buildings.slice(0, Math.max(2, Math.ceil(buildings.length * 0.6)));
        return { x: slot.x, y: cy, active: true, hp: 3, maxHp: 3, tier: 1, wavesSurvived: 0, growthLevel: 0, buildings: reduced, shields: [], casualties: 0 };
    });
    setCities(newCities);
    return upperPoints;
  }, []);

  const getTerrainHeight = (x, terrainPoints) => {
      if (!terrainPoints || terrainPoints.length === 0) return GAME_HEIGHT;
      if (typeof x !== 'number' || isNaN(x)) return GAME_HEIGHT;
      const segmentWidth = GAME_WIDTH / (terrainPoints.length - 1);
      const index = Math.floor(x / segmentWidth);
      if (index < 0 || index >= terrainPoints.length - 1) return GAME_HEIGHT;
      const p1 = terrainPoints[index];
      const p2 = terrainPoints[index+1];
      if (!p1 || !p2) return GAME_HEIGHT;
      const ratio = (x - p1.x) / (p2.x - p1.x);
      return p1.y + (p2.y - p1.y) * ratio;
  };

  const getCityTerrainHeight = (x) => {
      return getTerrainHeight(x, lowerTerrain.current);
  };

  // Check if line from (x1,y1) to (x2,y2) is clear of upper terrain
  const hasLineOfSight = (x1, y1, x2, y2) => {
      const pts = terrain.current;
      if (!pts || pts.length === 0) return true;
      const steps = Math.max(8, Math.ceil(Math.abs(x2 - x1) / 15));
      for (let i = 1; i < steps; i++) {
          const t = i / steps;
          const sx = x1 + (x2 - x1) * t;
          const sy = y1 + (y2 - y1) * t;
          const terrainY = getTerrainHeight(sx, pts);
          if (sy > terrainY) return false;
      }
      return true;
  };

  // --- Save / Load ---
  const SAVE_KEY = 'vectorDefenseSave';

  const saveGame = (lvl, m, s, c) => {
      try {
          const data = {
              level: lvl,
              money: m,
              score: s,
              cities: c,
              turrets: turrets.current.map(t => {
                  const { icon, ...savedStats } = t.stats;
                  return { id: t.id, x: t.x, y: t.y, type: t.type,
                      stats: savedStats, level: t.level, angle: t.angle };
              }),
              upperTerrain: upperTerrain.current,
              lowerTerrain: lowerTerrain.current,
              mapData: mapData.current,
              shieldCount: shieldCount.current
          };
          localStorage.setItem(SAVE_KEY, JSON.stringify(data));
      } catch (e) { /* storage full or unavailable */ }
  };

  const loadGame = () => {
      try {
          const raw = localStorage.getItem(SAVE_KEY);
          return raw ? JSON.parse(raw) : null;
      } catch (e) { return null; }
  };

  const clearSave = () => {
      try { localStorage.removeItem(SAVE_KEY); } catch (e) {}
  };

  const hasSave = () => {
      try { return !!localStorage.getItem(SAVE_KEY); } catch (e) { return false; }
  };

  const resumeGame = useCallback(() => {
      const save = loadGame();
      if (!save) return;
      initAudio();
      setLevel(save.level);
      setMoney(save.money);
      setScore(save.score);
      setCities(save.cities);
      turrets.current = save.turrets.map(t => ({
          ...t,
          stats: { ...TURRET_TYPES[t.type], ...t.stats },
          lastFired: 0, recoilOffset: 0, muzzleFlashTimer: 0
      }));
      upperTerrain.current = save.upperTerrain;
      lowerTerrain.current = save.lowerTerrain;
      terrain.current = save.upperTerrain;
      mapData.current = save.mapData;
      shieldCount.current = save.shieldCount || 0;
      resetEntities();
      setupLevel(save.level);
      setGameState('PLACEMENT');
      setMessage(`SYSTEMS RESTORED. WAVE ${save.level} STANDING BY.`);
  }, []);

  // --- Initialization ---
  const initGame = useCallback(() => {
    initAudio();
    clearSave();
    setMoney(3500);
    setScore(0);
    setLevel(1);
    setGameState('PLACEMENT');
    setMessage('Commander, hostile forces inbound.');
    turrets.current = [];
    shieldCount.current = 0;
    resetEntities();
    generateMap(2);
    setupLevel(1);
  }, [generateMap]);

  const setupLevel = (lvl) => {
    const tier = Math.floor(lvl / 5); // jumps at 5, 10, 15...
    levelConfig.current = {
        spawnTimer: 0,
        spawnInterval: Math.max(12, 80 - (lvl * 4)),
        totalToSpawn: 10 + (lvl * 4) + tier * 10,
        bomberTimer: 0,
        isBossWave: lvl % 5 === 0 && lvl > 0,
        isMegaBossWave: lvl % 10 === 0 && lvl > 0
    };
  };

  const resetEntities = () => {
    enemyMissiles.current = [];
    bombers.current = [];
    playerMissiles.current = [];
    lasers.current = [];
    explosions.current = [];
    particles.current = [];
    empPulses.current = [];
    pdcProjectiles.current = [];
    mushroomClouds.current = [];
    groundFires.current = [];
    screenFlash.current = 0;
  };

  const startWave = () => {
      const cfg = levelConfig.current;
      if (turrets.current.length === 0) {
          setMessage("WARNING: NO DEFENSES PLACED");
          setTimeout(() => setMessage(`WAVE ${level} INBOUND`), 2000);
      } else if (cfg.isMegaBossWave) {
          setMessage(`ALERT: MEGA BOSS INBOUND`);
          Sound.bossWarning();
      } else if (cfg.isBossWave) {
          setMessage(`WARNING: BOSS INBOUND`);
          Sound.bossWarning();
      } else {
          setMessage(`WAVE ${level} ENGAGING`);
          Sound.waveStart();
      }
      // Spawn boss ship on boss waves
      if (cfg.isMegaBossWave) {
          spawnBossShip(2);
      } else if (cfg.isBossWave) {
          spawnBossShip(1);
      }
      waveCompleted.current = false;
      setGameState('PLAYING');
      setSelectedAction(null);
  };

  // --- Game Loop ---
  const update = useCallback(() => {
    frameCount.current++;

    if (gameState === 'PLAYING') {
        const cfg = levelConfig.current;
        cfg.spawnTimer++;
        cfg.bomberTimer++;

        // Spawn Logic
        if (cfg.totalToSpawn > 0 && cfg.spawnTimer > cfg.spawnInterval) {
            spawnEnemyMissile();
            cfg.spawnTimer = 0;
            cfg.totalToSpawn--;
        }

        const bomberDelay = Math.max(200, 500 - Math.floor(level / 5) * 60);
        if (level >= 3 && cfg.bomberTimer > bomberDelay && Math.random() < 0.25) {
            spawnBomber();
            cfg.bomberTimer = 0;
        }

        // Turret Logic
        turrets.current.forEach(turret => {
            turret.lastFired++;

            // EMP disable countdown
            if (turret.empDisabled > 0) {
                turret.empDisabled--;
                // Still decay recoil/flash while disabled
                if (turret.recoilOffset > 0) turret.recoilOffset *= 0.7;
                if (turret.recoilOffset < 0.1) turret.recoilOffset = 0;
                if (turret.muzzleFlashTimer > 0) turret.muzzleFlashTimer--;
                return; // Skip targeting/firing
            }

            // Decay recoil
            if (turret.recoilOffset > 0) turret.recoilOffset *= 0.7;
            if (turret.recoilOffset < 0.1) turret.recoilOffset = 0;

            // Decay FLAK heat
            if (turret.type === 'FLAK' && turret.heat > 0) {
                turret.heat = Math.max(0, turret.heat - 0.3);
            }

            // Decay muzzle flash
            if (turret.muzzleFlashTimer > 0) turret.muzzleFlashTimer--;

            let target = null;
            let minDist = turret.stats.range;

            const allTargets = [...bombers.current.filter(b => !b.reentryTimer || b.reentryTimer <= 0), ...enemyMissiles.current];

            // Line-of-sight needed for direct-fire weapons (not homing missiles)
            const needsLOS = turret.type !== 'SAM' && turret.type !== 'SWARM';

            // Laser turrets prefer their current target for beam continuity
            if (turret.type === 'LASER' && turret.laserTarget) {
                const cur = allTargets.find(m => m.id === turret.laserTarget);
                if (cur && cur.active && distance(turret.x, turret.y, cur.x, cur.y) < turret.stats.range
                    && hasLineOfSight(turret.x, turret.y, cur.x, cur.y)) {
                    target = cur;
                }
            }

            // SWARM turrets prefer high-value targets
            if (!target && turret.type === 'SWARM') {
                let bestPriority = -1;
                let bestDist = turret.stats.range;
                const swarmPriority = (t) => {
                    if (t.type === 'BOSS_SHIP') return 4;
                    if (t.type === 'BOSS') return 3;
                    if (t.type === 'BOMBER') return 2;
                    if (t.type === 'ARMORED') return 1;
                    return 0;
                };
                allTargets.forEach(m => {
                    if (!m.active) return;
                    let d = distance(turret.x, turret.y, m.x, m.y);
                    if (d >= turret.stats.range) return;
                    const pri = swarmPriority(m);
                    if (pri > bestPriority || (pri === bestPriority && d < bestDist)) {
                        bestPriority = pri;
                        bestDist = d;
                        target = m;
                    }
                });
            }

            // Artillery targets the most powerful enemy (highest HP)
            if (!target && turret.type === 'ARTILLERY') {
                let bestHp = 0;
                allTargets.forEach(m => {
                    if (!m.active) return;
                    let d = distance(turret.x, turret.y, m.x, m.y);
                    if (d >= turret.stats.range) return;
                    if (!hasLineOfSight(turret.x, turret.y, m.x, m.y)) return;
                    if (m.hp > bestHp) {
                        bestHp = m.hp;
                        target = m;
                    }
                });
            }

            if (!target) {
                allTargets.forEach(m => {
                    if (!m.active) return;
                    let d = distance(turret.x, turret.y, m.x, m.y);
                    if (d >= minDist) return;
                    if (needsLOS && !hasLineOfSight(turret.x, turret.y, m.x, m.y)) return;
                    minDist = d;
                    target = m;
                });
            }

            // Smooth barrel tracking — only for turrets that need it
            // ARTILLERY: slow tracking IS the aiming mechanic
            // LASER: beam needs to follow target continuously
            // Others: barrel snaps to firing direction on each shot
            if (target && (turret.type === 'ARTILLERY' || turret.type === 'LASER')) {
                const dx = target.x - turret.x;
                const dy = target.y - turret.y;
                const targetAngle = Math.atan2(-dx, dy) - Math.PI / 2;
                let angleDiff = targetAngle - (turret.angle ?? Math.PI / 2);
                // Normalize to [-PI, PI]
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                const trackSpeed = turret.stats.trackingSpeed || 0.15;
                turret.angle = (turret.angle ?? Math.PI / 2) + angleDiff * trackSpeed;
            }

            if (turret.type === 'LASER') {
                // Heat mechanic: 1s firing = overheat, 3s cooldown
                if (turret.laserOverheat) {
                    turret.laserHeat = Math.max(0, (turret.laserHeat || 0) - (1 / 3)); // 180 frames to fully cool
                    if (turret.laserHeat <= 0) {
                        turret.laserOverheat = false;
                        turret.laserHeat = 0;
                    }
                    turret.laserTarget = null;
                    turret.dwellTime = 0;
                } else if (target) {
                    if (turret.laserTarget === target.id) {
                        turret.dwellTime = (turret.dwellTime || 0) + 1;
                    } else {
                        turret.laserTarget = target.id;
                        turret.dwellTime = 0;
                    }
                    if (turret.lastFired >= turret.stats.fireRate) {
                        fireTurret(turret, target);
                        turret.lastFired = 0;
                        turret.laserHeat = (turret.laserHeat || 0) + (1 / 60) * turret.stats.fireRate; // 60 frames of firing = 1.0
                        if (turret.laserHeat >= 1) {
                            turret.laserOverheat = true;
                            turret.laserHeat = 1;
                        }
                    }
                } else {
                    turret.laserTarget = null;
                    turret.dwellTime = 0;
                    // Cool down slowly when idle (same rate as overheat recovery)
                    if (turret.laserHeat > 0) {
                        turret.laserHeat = Math.max(0, turret.laserHeat - (1 / 3) / 60);
                    }
                }
            } else if (target && turret.lastFired >= turret.stats.fireRate) {
                // Artillery: only fire when barrel is aimed close to target
                if (turret.type === 'ARTILLERY') {
                    const aDx = target.x - turret.x;
                    const aDy = target.y - turret.y;
                    const targetAngle = Math.atan2(-aDx, aDy) - Math.PI / 2;
                    let aimDiff = targetAngle - (turret.angle ?? Math.PI / 2);
                    while (aimDiff > Math.PI) aimDiff -= Math.PI * 2;
                    while (aimDiff < -Math.PI) aimDiff += Math.PI * 2;
                    if (Math.abs(aimDiff) < 0.1) {
                        fireTurret(turret, target);
                        turret.lastFired = 0;
                    }
                } else {
                    fireTurret(turret, target);
                    turret.lastFired = 0;
                }
            }
        });

        updateEnemyMissiles();
        updateBombers();
        updatePlayerMissiles();
        updatePdcProjectiles();
        updateLasers();
        updateExplosions();
        updateParticles();

        // Update EMP pulses
        empPulses.current.forEach(p => {
            p.radius += p.maxRadius / 60; // constant expansion rate
            p.life--;
        });
        empPulses.current = empPulses.current.filter(p => p.life > 0);

        // Decay screen shake and flash
        if (screenShake.current > 0) screenShake.current *= 0.85;
        if (screenShake.current < 0.2) screenShake.current = 0;
        if (screenFlash.current > 0) screenFlash.current *= 0.8;
        if (screenFlash.current < 0.02) screenFlash.current = 0;

        // Update mushroom clouds
        mushroomClouds.current.forEach(mc => mc.age++);
        mushroomClouds.current = mushroomClouds.current.filter(mc => mc.age < mc.maxAge);

        // Fire casualties: every 5 seconds, burning buildings kill survivors slowly
        if (groundFires.current.length > 0 && frameCount.current % 300 === 0) {
            let casualtyChange = false;
            const newCities = cities.map(c => {
                if (!c.active) return c;
                const burning = c.buildings.filter(b => (b.damage || 0) >= 0.6);
                if (burning.length === 0) return c;
                // Remaining survivors in burning buildings die slowly (~2-5% per tick)
                let fireCasualties = 0;
                burning.forEach(b => {
                    const pop = getBuildingPop(b);
                    const alreadyDead = Math.round(pop * (b.damage || 0) * 0.7);
                    const survivors = pop - alreadyDead;
                    if (survivors > 0) {
                        fireCasualties += Math.max(1, Math.round(survivors * (0.02 + Math.random() * 0.03)));
                    }
                });
                if (fireCasualties === 0) return c;
                casualtyChange = true;
                return { ...c, casualties: (c.casualties || 0) + fireCasualties };
            });
            if (casualtyChange) setCities(newCities);
        }

        // Fire spread: every 30 seconds, burning buildings ignite 1 neighbor
        if (groundFires.current.length > 0 && frameCount.current % 1800 === 0) {
            let fireSpread = false;
            const newCities = cities.map(c => {
                if (!c.active) return c;
                // Find buildings on fire (damage >= 0.6)
                const burning = c.buildings.filter(b => (b.damage || 0) >= 0.6);
                if (burning.length === 0) return c;
                // Find closest non-burning neighbor for each burning building, pick one
                let bestTarget = null;
                let bestDist = Infinity;
                burning.forEach(fb => {
                    c.buildings.forEach((b, i) => {
                        if ((b.damage || 0) >= 0.6) return; // already burning
                        const gap = Math.abs(b.xOffset - fb.xOffset);
                        if (gap < bestDist) {
                            bestDist = gap;
                            bestTarget = i;
                        }
                    });
                });
                if (bestTarget === null) return c;
                fireSpread = true;
                const newBuildings = [...c.buildings];
                const b = { ...newBuildings[bestTarget] };
                const prevDmg = b.damage || 0;
                b.damage = Math.min(1.0, prevDmg + 0.6);
                // Spread casualties: 20-30% of newly burning building's population
                const pop = getBuildingPop(b);
                const spreadCasualties = Math.round(pop * (b.damage - prevDmg) * 0.25);
                newBuildings[bestTarget] = b;
                // Spawn fire on newly burning building
                groundFires.current.push({
                    x: c.x + b.xOffset + (Math.random() - 0.5) * b.w,
                    y: c.y,
                    age: 0, maxAge: 999999,
                    size: 3 + Math.random() * 4
                });
                return { ...c, buildings: newBuildings, casualties: (c.casualties || 0) + spreadCasualties };
            });
            if (fireSpread) setCities(newCities);
        }

        if (!waveCompleted.current && cfg.totalToSpawn === 0 && enemyMissiles.current.length === 0 && bombers.current.length === 0 && explosions.current.length === 0) {
            waveCompleted.current = true;
            handleWaveComplete();
        }

        if (cities.filter(c => c.active).length === 0) {
            setGameState('GAME_OVER');
            clearSave();
            Sound.gameOver();
        }
    } else {
        updateParticles();
        updateExplosions();
        blinkTimer.current++;
        frameCount.current++;
    }
  }, [gameState, cities, level]);

  const handleWaveComplete = () => {
      const levelMult = 1 + (level - 1) * 0.15;
      const baseBonus = Math.round(WAVE_COMPLETE_BONUS * levelMult);
      const cityBonus = cities.filter(c => c.active).length * Math.round(500 * levelMult);
      const totalBonus = baseBonus + cityBonus;

      let repairedCount = 0;
      let growingCount = 0;
      const updatedCities = cities.map(c => {
          if (!c.active) return c;
          const ws = (c.wavesSurvived || 0) + 1;
          const tier = c.tier != null ? c.tier : 1;
          const maxHp = c.maxHp || 3;

          if (c.hp < maxHp) {
              // Damaged city: heal HP and repair buildings
              repairedCount++;
              const healAmount = Math.ceil(maxHp * 0.20) + Math.ceil(maxHp * 0.03 * tier);
              const newHp = Math.min(c.hp + healAmount, maxHp);
              const repairRate = 0.15 + 0.03 * tier;
              const repairedBuildings = c.buildings.map(b => ({
                  ...b,
                  damage: Math.max(0, (b.damage || 0) - repairRate)
              }));
              createParticles(c.x, c.y, '#00ff88', 6);
              return { ...c, wavesSurvived: ws, hp: newHp, buildings: repairedBuildings };
          } else {
              // Undamaged city: organic growth
              growingCount++;
              const gl = (c.growthLevel || 0) + 1;
              const cfg = TIER_CONFIG[Math.min(tier, 5)];
              const isMetropolis = c.buildings.length > 15 || gl > 15;

              // Building growth: strong horizontal sprawl, slower vertical
              const driftRate = 1.5 + tier * 0.4 + gl * 0.15;
              const grownBuildings = c.buildings.map(b => {
                  const tall = isMetropolis && b.h > 30;
                  return {
                      ...b,
                      h: b.h * (tall ? 1.04 : 1.015),
                      w: b.w * 1.03,
                      xOffset: isMetropolis
                          ? b.xOffset * 0.999 // slight densification
                          : b.xOffset + (b.xOffset > 0 ? driftRate : -driftRate)
                  };
              });

              // Every wave: spawn 1-3 suburban buildings at city edges
              if (!isMetropolis) {
                  const suburbCount = 1 + (gl >= 5 ? 1 : 0) + (gl >= 12 ? 1 : 0);
                  const currentMaxOffset = Math.max(...grownBuildings.map(b => Math.abs(b.xOffset)), cfg.spread);
                  for (let s = 0; s < suburbCount; s++) {
                      const side = Math.random() > 0.5 ? 1 : -1;
                      const subOffset = side * (currentMaxOffset + 5 + Math.random() * 10);
                      const bw = 4 + Math.random() * 6;
                      const bh = 8 + Math.random() * 12;
                      const windows = [];
                      const cols = Math.max(1, Math.floor(bw / 4));
                      const rows = Math.max(1, Math.floor(bh / 6));
                      for (let wy = 0; wy < rows; wy++) {
                          for (let wx = 0; wx < cols; wx++) {
                              windows.push({ ox: 2 + wx * (bw / cols), oy: 3 + wy * (bh / rows), phase: Math.floor(Math.random() * 10) });
                          }
                      }
                      grownBuildings.push({
                          w: bw, h: bh,
                          xOffset: subOffset,
                          style: 'flat', windows,
                          hasAntenna: false,
                          damage: 0
                      });
                  }
              }

              // Every 5 growth levels: add a core building
              if (gl % 5 === 0) {
                  const bw = (6 + Math.random() * 12) * cfg.heightScale;
                  const bh = (15 + Math.random() * 25) * cfg.heightScale;
                  const style = cfg.styles[Math.floor(Math.random() * cfg.styles.length)];
                  const windows = [];
                  const cols = Math.max(1, Math.floor(bw / 4));
                  const rows = Math.max(1, Math.floor(bh / 6));
                  for (let wy = 0; wy < rows; wy++) {
                      for (let wx = 0; wx < cols; wx++) {
                          windows.push({ ox: 2 + wx * (bw / cols), oy: 3 + wy * (bh / rows), phase: Math.floor(Math.random() * 10) });
                      }
                  }
                  grownBuildings.push({
                      w: bw, h: bh,
                      xOffset: (Math.random() - 0.5) * (cfg.spread + gl * 3),
                      style, windows,
                      hasAntenna: bh > 20 && Math.random() < cfg.antennaChance,
                      damage: 0
                  });
              }

              // Upgrade flat buildings to futuristic styles
              const upgradeChance = isMetropolis ? 0.30 : 0.15;
              if (Math.random() < upgradeChance) {
                  const flatIdx = grownBuildings.findIndex(b => b.style === 'flat');
                  if (flatIdx >= 0) {
                      const newStyle = isMetropolis
                          ? ['pointed', 'stepped', 'dome'][Math.floor(Math.random() * 3)]
                          : (Math.random() > 0.5 ? 'stepped' : 'dome');
                      grownBuildings[flatIdx] = {
                          ...grownBuildings[flatIdx],
                          style: newStyle,
                          hasAntenna: isMetropolis ? Math.random() < 0.5 : grownBuildings[flatIdx].hasAntenna
                      };
                  }
              }

              // Village promotion: after 4 waves undamaged, promote to tier 1 town
              if (c.isVillage && ws >= 4) {
                  createParticles(c.x, c.y, '#00ffcc', 6);
                  return { ...c, wavesSurvived: ws, growthLevel: gl, buildings: grownBuildings,
                      tier: 1, maxHp: 2, hp: 2, isVillage: false };
              }

              createParticles(c.x, c.y, '#00ffcc', 4);
              return { ...c, wavesSurvived: ws, growthLevel: gl, buildings: grownBuildings };
          }
      });
      // Repair shields: damaged shields come back online after 1 wave
      const shieldRepaired = updatedCities.map(c => {
          if (!c.active || !c.shields || c.shields.length === 0) return c;
          const repairedShields = c.shields.map(s => {
              if (s.damaged) return { ...s, damaged: false, hp: s.maxHp };
              return s;
          });
          return { ...c, shields: repairedShields };
      });
      // Spawn villages in gaps between cities
      const withVillages = spawnVillages(shieldRepaired, level);
      // Check for city merges after growth
      const mergedCities = checkCityMerges(withVillages);
      setCities(mergedCities);

      const villageCount = mergedCities.filter(c => c.active && c.isVillage).length;
      setBonusReport({
          wave: level,
          base: baseBonus,
          cityCount: cities.filter(c => c.active).length,
          cityBonus: cityBonus,
          total: totalBonus,
          repairedCount,
          growingCount,
          villageCount
      });

      setMoney(prev => prev + totalBonus);
      saveGame(level, money + totalBonus, score, mergedCities);
      setGameState('LEVEL_COMPLETE');
  };

  const spawnVillages = (cityList, currentLevel) => {
      const active = cityList.filter(c => c.active);
      const destroyed = cityList.filter(c => !c.active);
      const result = [...cityList];

      const addVillage = (midX) => {
          const tooClose = result.filter(c => c.active).some(c => Math.abs(c.x - midX) < 40);
          if (tooClose) return;
          const vy = getCityTerrainHeight(midX);
          const villageBuildings = generateCityBuildings(0);
          const reduced = villageBuildings.slice(0, Math.max(1, Math.ceil(villageBuildings.length * 0.5)));
          result.push({
              x: midX, y: vy, active: true,
              hp: 1, maxHp: 1,
              tier: 0, wavesSurvived: 0, growthLevel: 0,
              buildings: reduced, shields: [], casualties: 0,
              isVillage: true
          });
          createParticles(midX, vy, '#88dddd', 4);
      };

      // Spawn near destroyed cities (high probability - resettlement)
      destroyed.forEach(d => {
          if (Math.random() < 0.7) {
              const offset = (Math.random() - 0.5) * 60;
              addVillage(Math.max(30, Math.min(GAME_WIDTH - 30, d.x + offset)));
          }
      });

      // Spawn in gaps between active cities (starts wave 2)
      if (active.length >= 1 && currentLevel >= 2) {
          // Also consider edges of the map as spawn zones
          const sorted = [...active].sort((a, b) => a.x - b.x);
          const positions = [];

          // Left edge gap
          if (sorted[0].x > 100) {
              positions.push({ left: 30, right: sorted[0].x });
          }
          // Gaps between cities
          for (let i = 0; i < sorted.length - 1; i++) {
              positions.push({ left: sorted[i].x, right: sorted[i + 1].x });
          }
          // Right edge gap
          if (sorted[sorted.length - 1].x < GAME_WIDTH - 100) {
              positions.push({ left: sorted[sorted.length - 1].x, right: GAME_WIDTH - 30 });
          }

          positions.forEach(({ left, right }) => {
              const gap = right - left;
              if (gap < 60) return;

              // Spawn chance scales with gap size and wave - much more aggressive
              const spawnChance = Math.min(0.8, 0.25 + (gap / 300) + (currentLevel - 1) * 0.05);
              if (Math.random() > spawnChance) return;

              const midX = left + gap * (0.3 + Math.random() * 0.4);
              addVillage(Math.max(30, Math.min(GAME_WIDTH - 30, midX)));

              // Large gaps can spawn multiple villages
              if (gap > 200 && Math.random() < 0.5) {
                  const midX2 = left + gap * (Math.random() > 0.5 ? 0.2 : 0.8);
                  addVillage(Math.max(30, Math.min(GAME_WIDTH - 30, midX2)));
              }
          });
      }

      return result;
  };

  const checkCityMerges = (cityList) => {
      const result = [...cityList];
      let merged = true;
      while (merged) {
          merged = false;
          const active = result.filter(c => c.active);
          for (let i = 0; i < active.length && !merged; i++) {
              for (let j = i + 1; j < active.length && !merged; j++) {
                  const a = active[i];
                  const b = active[j];
                  if (!a.active || !b.active) continue;
                  const tierA = a.tier != null ? a.tier : 1;
                  const tierB = b.tier != null ? b.tier : 1;
                  const cfgA = TIER_CONFIG[Math.min(tierA, 5)];
                  const cfgB = TIER_CONFIG[Math.min(tierB, 5)];
                  // Use the greater of tier formula OR actual building extent
                  const formulaSpreadA = cfgA.spread + (a.growthLevel || 0) * 2.5;
                  const buildingSpreadA = a.buildings.length > 0
                      ? Math.max(...a.buildings.map(bl => Math.abs(bl.xOffset) + bl.w / 2))
                      : 0;
                  const spreadA = Math.max(formulaSpreadA, buildingSpreadA);
                  const formulaSpreadB = cfgB.spread + (b.growthLevel || 0) * 2.5;
                  const buildingSpreadB = b.buildings.length > 0
                      ? Math.max(...b.buildings.map(bl => Math.abs(bl.xOffset) + bl.w / 2))
                      : 0;
                  const spreadB = Math.max(formulaSpreadB, buildingSpreadB);
                  const gap = Math.abs(a.x - b.x) - spreadA - spreadB;
                  if (gap < 35) {
                      const midX = (a.x + b.x) / 2;
                      const midY = getCityTerrainHeight(midX);
                      const offsetA = a.x - midX;
                      const offsetB = b.x - midX;
                      const combinedBuildings = [
                          ...a.buildings.map(bl => ({ ...bl, xOffset: bl.xOffset + offsetA })),
                          ...b.buildings.map(bl => ({ ...bl, xOffset: bl.xOffset + offsetB }))
                      ];
                      // Infill buildings to connect the gap
                      const infillCount = 2 + Math.floor(Math.random() * 3);
                      for (let f = 0; f < infillCount; f++) {
                          const t = (f + 0.5) / infillCount;
                          const fx = offsetA + (offsetB - offsetA) * t;
                          const bw = 5 + Math.random() * 8;
                          const bh = 10 + Math.random() * 15;
                          const windows = [];
                          const cols = Math.max(1, Math.floor(bw / 4));
                          const rows = Math.max(1, Math.floor(bh / 6));
                          for (let wy = 0; wy < rows; wy++) {
                              for (let wx = 0; wx < cols; wx++) {
                                  windows.push({ ox: 2 + wx * (bw / cols), oy: 3 + wy * (bh / rows), phase: Math.floor(Math.random() * 10) });
                              }
                          }
                          combinedBuildings.push({
                              w: bw, h: bh, xOffset: fx,
                              style: 'flat', windows,
                              hasAntenna: false, damage: 0
                          });
                      }
                      // Combine shields, adjusting offsets to new city center
                      const combinedShields = [
                          ...(a.shields || []).map(s => ({ ...s, x: s.x + offsetA })),
                          ...(b.shields || []).map(s => ({ ...s, x: s.x + offsetB }))
                      ];
                      // Tier boost when merging same-tier cities
                      const mergedTier = (tierA === tierB && tierA < 5)
                          ? tierA + 1
                          : Math.max(tierA, tierB);
                      const idxA = result.indexOf(a);
                      const idxB = result.indexOf(b);
                      result[idxA] = {
                          ...a,
                          x: midX,
                          y: midY,
                          hp: a.hp + b.hp,
                          maxHp: a.maxHp + b.maxHp,
                          tier: mergedTier,
                          growthLevel: Math.max(a.growthLevel || 0, b.growthLevel || 0),
                          buildings: combinedBuildings,
                          shields: combinedShields,
                          casualties: (a.casualties || 0) + (b.casualties || 0),
                          isVillage: false
                      };
                      result[idxB] = { ...b, active: false };
                      createParticles(midX, midY, '#ffff00', 12);
                      merged = true; // restart to check for cascade merges
                  }
              }
          }
      }
      return result;
  };

  const advanceLevel = () => {
      const nextLvl = level + 1;
      setLevel(nextLvl);
      resetEntities();
      setupLevel(nextLvl);
      saveGame(nextLvl, money, score, cities);
      setGameState('PLACEMENT');
      setMessage('PREPARE DEFENSES. HOSTILES INBOUND.');
  };

  // --- Logic Helpers ---
  const applyDamage = (enemy, damage) => {
      if (!enemy.active || enemy.hp <= 0) return;
      // Boss shield absorbs damage first
      if (enemy.shieldActive && enemy.shield > 0) {
          const absorbed = Math.min(damage, enemy.shield);
          enemy.shield -= absorbed;
          damage -= absorbed;
          if (damage <= 0) {
              createParticles(enemy.x, enemy.y, '#00ffff', 2);
              return;
          }
      }
      enemy.hp -= damage;
      if (enemy.hp <= 0) {
          enemy.active = false;
          const levelMult = 1 + (level - 1) * 0.15;
          let reward = Math.round(50 * levelMult);
          let scoreReward = Math.round(100 * levelMult);
          if (enemy.type === 'BOSS_SHIP') {
              const isMega = enemy.bossTier >= 2;
              reward = Math.round((isMega ? 10000 : 5000) * levelMult);
              scoreReward = Math.round((isMega ? 30000 : 15000) * levelMult);
          }
          else if (enemy.type === 'BOSS') { reward = Math.round(800 * levelMult); scoreReward = Math.round(2000 * levelMult); }
          if (enemy.type === 'ARMORED') { reward = Math.round(100 * levelMult); scoreReward = Math.round(300 * levelMult); }

          setMoney(m => m + reward);
          setScore(s => s + scoreReward);

          const deathRadius = enemy.type === 'BOSS_SHIP' ? (enemy.bossTier >= 2 ? 150 : 100) : (enemy.type === 'BOSS' ? 80 : 30);
          createExplosion(enemy.x, enemy.y, true, deathRadius);
          createParticles(enemy.x, enemy.y, enemy.color);
      } else {
          if (frameCount.current - lastEnemyHitFrame >= 5) {
              Sound.enemyHit();
              lastEnemyHitFrame = frameCount.current;
          }
          createParticles(enemy.x, enemy.y, '#fff', 2);
      }
  };

  const fireTurret = (turret, target) => {
      if (turret.type === 'LASER') {
          const dist = distance(turret.x, turret.y, target.x, target.y);
          const distFalloff = Math.max(0.2, 1 - (dist / turret.stats.range) * 0.8);
          const dwellBonus = 1 + Math.min((turret.dwellTime || 0) / 30, 5);
          const finalDamage = turret.stats.damage * distFalloff * dwellBonus;
          const beamWidth = Math.min(1 + (turret.dwellTime || 0) / 15, 6);
          lasers.current.push({
              x1: turret.x, y1: turret.y,
              x2: target.x, y2: target.y,
              color: turret.stats.projectileColor,
              life: turret.stats.fireRate,
              width: beamWidth
          });
          if ((turret.dwellTime || 0) > 10) {
              createParticles(target.x, target.y, '#ff00ff', 1);
          }
          Sound.laserBeam(turret.dwellTime);
          applyDamage(target, finalDamage);
          return;
      }

      // Trigger recoil and muzzle flash
      turret.recoilOffset = turret.type === 'ARTILLERY' ? 8 : 4;
      turret.muzzleFlashTimer = turret.type === 'ARTILLERY' ? 10 : 5;
      Sound.turretFire(turret.type);

      if (turret.type === 'ARTILLERY') {
          // Fire along barrel direction — no lead prediction
          const rot = (turret.angle ?? Math.PI / 2) + Math.PI / 2;
          playerMissiles.current.push({
              x: turret.x,
              y: turret.y,
              vx: -Math.sin(rot) * ARTILLERY_SHELL_SPEED,
              vy: Math.cos(rot) * ARTILLERY_SHELL_SPEED,
              active: true,
              type: 'ARTILLERY',
              color: turret.stats.projectileColor,
              damage: turret.stats.damage,
              explosionRadius: 0
          });
          return;
      }

      if (turret.type === 'SAM') {
           playerMissiles.current.push({
              x: turret.x,
              y: turret.y,
              vx: 0,
              vy: -SAM_SPEED,
              targetId: target.id,
              active: true,
              type: 'SAM',
              color: turret.stats.projectileColor,
              damage: turret.stats.damage,
              explosionRadius: turret.stats.explosionRadius
          });
          return;
      }

      if (turret.type === 'SWARM') {
          const count = 4 + Math.floor(Math.random() * 3); // 4-6 missiles
          for (let i = 0; i < count; i++) {
              const spreadAngle = -Math.PI / 2 + (i / (count - 1) - 0.5) * (Math.PI / 3);
              playerMissiles.current.push({
                  x: turret.x,
                  y: turret.y,
                  vx: Math.cos(spreadAngle) * SWARM_SPEED,
                  vy: Math.sin(spreadAngle) * SWARM_SPEED,
                  targetId: target.id,
                  active: true,
                  type: 'SWARM',
                  color: turret.stats.projectileColor,
                  damage: turret.stats.damage,
                  explosionRadius: turret.stats.explosionRadius,
                  dodging: false,
                  dodgeTimer: 0,
                  dodgeVx: 0,
                  dodgeVy: 0,
                  age: 0
              });
          }
          return;
      }

      const dist = distance(turret.x, turret.y, target.x, target.y);
      const timeToHit = dist / PLAYER_PROJECTILE_SPEED;
      const predX = target.x + (target.vx * timeToHit);
      const predY = target.y + (target.vy * timeToHit);
      let angle = Math.atan2(predY - turret.y, predX - turret.x);

      // FLAK: inaccuracy that worsens with heat
      if (turret.type === 'FLAK') {
          const heat = turret.heat || 0;
          const spread = 0.12 + heat * 0.006;
          angle += (Math.random() - 0.5) * spread;
          turret.heat = Math.min((turret.heat || 0) + 2, 30);
      }

      // Snap barrel to firing direction
      turret.angle = angle - Math.PI;

      const missile = {
          x: turret.x,
          y: turret.y,
          vx: Math.cos(angle) * PLAYER_PROJECTILE_SPEED,
          vy: Math.sin(angle) * PLAYER_PROJECTILE_SPEED,
          targetX: predX,
          targetY: predY,
          active: true,
          type: turret.type,
          color: turret.stats.projectileColor,
          damage: turret.stats.damage,
          explosionRadius: turret.stats.explosionRadius
      };
      // FLAK detonates at target altitude with random perturbation
      if (turret.type === 'FLAK') {
          missile.detonateY = predY + (Math.random() - 0.5) * 60;
      }
      playerMissiles.current.push(missile);
  };

  const spawnEnemyMissile = (originX = null, originY = null, isBomblet = false) => {
    const startX = originX ?? Math.random() * GAME_WIDTH;
    const startY = originY ?? 0;

    const validCities = cities.filter(c => c.active);
    if (validCities.length === 0) return;
    const targetCity = validCities[Math.floor(Math.random() * validCities.length)];

    const angle = Math.atan2(targetCity.y - startY, targetCity.x - startX);

    let type = 'NORMAL';
    let speed = 0.8 + (level * 0.08);
    let color = '#ff0000';
    const hpScale = getHpScale(level);
    let maxHp = Math.round(HP_NORMAL * hpScale);
    let size = 4;
    let canSplit = false;

    if (!isBomblet) {
        const rand = Math.random();
        // Composition shifts harder each tier
        const tierShift = Math.min(Math.floor(level / 5) * 0.03, 0.15);

        if (level >= 5 && rand < 0.05 + tierShift) {
            type = 'BOSS';
            speed = 0.4;
            maxHp = Math.round((HP_BOSS_BASE + (level * 50)) * hpScale);
            size = 15;
            color = '#ff0000';
        }
        else if (level >= 7 && rand < 0.2 + tierShift * 2) {
            type = 'MIRV'; canSplit = true; color = '#ffaa00';
            maxHp = Math.round(HP_NORMAL * 2 * hpScale);
        }
        else if (level >= 4 && rand < 0.3 + tierShift * 2) {
            type = 'ARMORED';
            speed *= 1.1;
            maxHp = Math.round(HP_ARMORED * hpScale);
            size = 6;
            color = '#ffffff';
        }
        else if (level >= 3 && rand < 0.45 + tierShift) {
            type = 'FAST';
            speed = 2.2 + (level * 0.1);
            color = '#bd00ff';
            maxHp = Math.round(HP_FAST * hpScale);
        }
    }

    enemyMissiles.current.push({
        id: Math.random().toString(36),
        x: startX,
        y: startY,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        active: true,
        type,
        color,
        maxHp,
        hp: maxHp,
        size,
        canSplit,
        trailHistory: []
    });
  };

  const spawnBomber = () => {
      const fromLeft = Math.random() > 0.5;
      const y = 50 + Math.random() * 80;
      const hpScale = getHpScale(level);
      const bomberHp = Math.round(60 * hpScale + level * 5);
      bombers.current.push({
          id: Math.random().toString(36),
          x: fromLeft ? -50 : GAME_WIDTH + 50,
          y: y,
          vx: fromLeft ? 1.2 : -1.2,
          active: true,
          type: 'BOMBER',
          maxHp: bomberHp,
          hp: bomberHp,
          color: '#ffff00',
          size: 10,
          lastDrop: 0,
          dropInterval: 50,
          dropChance: 0.03
      });
  };

  const spawnBossShip = (tier) => {
      const fromLeft = Math.random() > 0.5;
      const y = 40 + Math.random() * 50;
      const isMega = tier >= 2;
      const bossHp = (isMega ? 1500 + level * 100 : 750 + level * 60) * 20;
      bombers.current.push({
          id: Math.random().toString(36),
          x: fromLeft ? -80 : GAME_WIDTH + 80,
          y: y,
          baseSpeed: isMega ? 0.48 : 0.64,
          vx: fromLeft ? (isMega ? 0.48 : 0.64) : (isMega ? -0.48 : -0.64),
          active: true,
          type: 'BOSS_SHIP',
          maxHp: bossHp,
          hp: bossHp,
          color: '#ff4400',
          size: isMega ? 75 : 54,
          lastDrop: 0,
          dropInterval: isMega ? 18 : 25,
          dropChance: isMega ? 0.10 : 0.06,
          isBossShip: true,
          bossTier: tier,
          escortsSpawned: false,
          // Looping & descent
          passCount: 0,
          reentryTimer: 0,
          // Point defense (rapid-fire tracers)
          pdCooldown: 0,
          pdFlash: 0,
          // EMP
          empCharge: 0,
          empMaxCharge: isMega ? 400 : 600,
          empWindup: 0,
          // Cluster bomb
          clusterTimer: 0,
          clusterWindup: 0,
          // Shield (mega only)
          shield: 0,
          shieldTimer: isMega ? 0 : -1,
          shieldActive: false,
          shieldDuration: 0,
          // Bombing run
          bombRunTimer: 0,
          bombRunning: 0
      });
  };

  const updateBombers = () => {
      bombers.current.forEach(b => {
          if (!b.active) return;

          // --- Boss ship special movement: fly across, exit, reappear lower ---
          if (b.isBossShip) {
              const isMega = b.bossTier >= 2;
              const onScreen = b.x > -80 && b.x < GAME_WIDTH + 80;

              // Reentry delay: boss is off-screen waiting to reappear
              if (b.reentryTimer > 0) {
                  b.reentryTimer--;
                  if (b.reentryTimer <= 0) {
                      // Reappear from the side it exited, heading back
                      b.passCount++;
                      const minAlt = CITY_ZONE_TOP - 50;
                      const descent = isMega ? (10 + Math.random() * 10) : (15 + Math.random() * 10);
                      b.y = Math.min(b.y + descent, minAlt);
                      // Reverse direction: reappear from exit side
                      b.vx = -b.vx;
                      b.x = b.vx > 0 ? -79 : GAME_WIDTH + 79;
                  }
                  return; // skip all logic while off-screen
              }

              // Movement
              const speed = b.bombRunning > 0 ? b.baseSpeed * 3 : b.baseSpeed;
              b.vx = b.vx > 0 ? speed : -speed;
              b.x += b.vx;

              // Check if boss has exited the screen
              if (b.x < -80 || b.x > GAME_WIDTH + 80) {
                  b.reentryTimer = 300; // 5 second delay before reappearing
                  return;
              }

              // Trailing smoke/fire particles when damaged
              const hpRatio = b.hp / b.maxHp;
              if (hpRatio < 0.75 && Math.random() < (1 - hpRatio) * 0.5) {
                  const room = 500 - particles.current.length;
                  if (room > 0) {
                      particles.current.push({
                          x: b.x - b.vx * 8 + (Math.random() - 0.5) * 10,
                          y: b.y + (Math.random() - 0.5) * 6,
                          vx: -b.vx * 0.3 + (Math.random() - 0.5) * 0.5,
                          vy: -0.5 - Math.random() * 0.5,
                          color: hpRatio < 0.35 ? (Math.random() > 0.4 ? '#ff4400' : '#ff8800') : '#666666',
                          life: 15 + Math.random() * 15,
                          maxLife: 30,
                          size: 2 + Math.random() * 3,
                          shape: 'circle'
                      });
                  }
              }

              // --- Altitude-scaled drop chance: lower = more aggressive ---
              const altRatio = 1 - Math.max(0, Math.min(1, (b.y - 40) / (CITY_ZONE_TOP - 90)));
              // altRatio: 1 at top (y=40), 0 at lowest altitude
              const dropMult = 1 + (1 - altRatio) * 3; // 1x at top, 4x at lowest

              // --- Bombing run ---
              if (b.bombRunning > 0) {
                  b.bombRunning--;
                  if (b.bombRunning % 8 === 0) {
                      spawnEnemyMissile(b.x, b.y, true);
                  }
                  if (b.bombRunning <= 0) {
                      b.bombRunTimer = 0;
                  }
              } else {
                  b.bombRunTimer++;
                  if (b.bombRunTimer >= 600) {
                      b.bombRunning = 90;
                  }
              }

              // --- Normal bomb drops (scaled by altitude) ---
              b.lastDrop++;
              if (b.bombRunning <= 0 && b.lastDrop > (b.dropInterval || 50) && Math.random() < (b.dropChance || 0.03) * dropMult) {
                  spawnEnemyMissile(b.x, b.y, true);
                  b.lastDrop = 0;
              }

              // --- EMP system ---
              if (b.empWindup > 0) {
                  b.empWindup--;
                  if (b.empWindup <= 0) {
                      Sound.empFire();
                      empPulses.current.push({ x: b.x, y: b.y, radius: 0, maxRadius: 450, life: 60 });
                      turrets.current.forEach(t => {
                          const d = distance(b.x, b.y, t.x, t.y);
                          if (d < 150) t.empDisabled = 180;
                          else if (d < 300) t.empDisabled = Math.max(t.empDisabled || 0, 120);
                          else if (d < 450) t.empDisabled = Math.max(t.empDisabled || 0, 60);
                      });
                      b.empCharge = 0;
                  }
              } else {
                  b.empCharge++;
                  if (b.empCharge >= b.empMaxCharge) {
                      b.empWindup = 30;
                  }
              }

              // --- Point Defense Cannons: rapid-fire tracers at incoming missiles ---
              b.pdCooldown = Math.max(0, b.pdCooldown - 1);
              if (b.pdFlash > 0) b.pdFlash--;
              if (b.pdCooldown <= 0) {
                  // Find nearest player missile within detection range
                  const pdRange = isMega ? 280 : 220;
                  let nearest = null;
                  let nearestDist = pdRange;
                  for (let pm of playerMissiles.current) {
                      if (!pm.active) continue;
                      const d = distance(b.x, b.y, pm.x, pm.y);
                      if (d < nearestDist) {
                          nearestDist = d;
                          nearest = pm;
                      }
                  }
                  if (nearest) {
                      // Fire single high-velocity tracer directly at target
                      const a = Math.atan2(nearest.y - b.y, nearest.x - b.x);
                      const jitter = (Math.random() - 0.5) * 0.06; // slight inaccuracy
                      const spd = 14;
                      pdcProjectiles.current.push({
                          x: b.x, y: b.y,
                          vx: Math.cos(a + jitter) * spd,
                          vy: Math.sin(a + jitter) * spd,
                          active: true,
                          life: 0,
                          maxLife: 18
                      });
                      b.pdFlash = 3;
                      b.pdCooldown = isMega ? 4 : 6; // rapid fire
                      Sound.pdcFire();
                  }
              }

              // --- Cluster Bomb ---
              b.clusterTimer++;
              if (b.clusterWindup > 0) {
                  b.clusterWindup--;
                  if (b.clusterWindup <= 0) {
                      const count = 5 + Math.floor(Math.random() * 3);
                      const spreadAngle = Math.PI / 6;
                      for (let i = 0; i < count; i++) {
                          const angle = (Math.PI / 2) + (i / (count - 1) - 0.5) * 2 * spreadAngle;
                          const spd = 1.8 + Math.random() * 0.4;
                          enemyMissiles.current.push({
                              id: Math.random().toString(36),
                              x: b.x, y: b.y,
                              vx: Math.cos(angle) * spd,
                              vy: Math.sin(angle) * spd,
                              active: true,
                              type: 'FAST',
                              color: '#ff8800',
                              maxHp: HP_FAST,
                              hp: HP_FAST,
                              size: 4,
                              canSplit: false,
                              trailHistory: []
                          });
                      }
                      b.clusterTimer = 0;
                  }
              } else if (b.clusterTimer >= 400) {
                  b.clusterWindup = 20;
              }

              // --- Shield Regen (mega-boss only) ---
              if (b.shieldTimer >= 0) {
                  if (b.shieldActive) {
                      b.shieldDuration--;
                      if (b.shieldDuration <= 0 || b.shield <= 0) {
                          b.shieldActive = false;
                          b.shield = 0;
                          b.shieldTimer = 0;
                      }
                  } else {
                      b.shieldTimer++;
                      if (b.shieldTimer >= 500) {
                          b.shield = 200;
                          b.shieldActive = true;
                          b.shieldDuration = 300;
                      }
                  }
              }

              // Mega-boss escort spawning
              if (isMega && !b.escortsSpawned && b.x > 200 && b.x < 600) {
                  b.escortsSpawned = true;
                  spawnBomber();
                  spawnBomber();
              }

          } else {
              // Non-boss bomber: original behavior
              b.x += b.vx;
              b.lastDrop++;
              if (b.lastDrop > (b.dropInterval || 50) && Math.random() < (b.dropChance || 0.03)) {
                  spawnEnemyMissile(b.x, b.y, true);
                  b.lastDrop = 0;
              }
              if (b.x < -100 || b.x > GAME_WIDTH + 100) b.active = false;
          }

          // Explosion damage (all bombers)
          for (let ex of explosions.current) {
            if (!b.active) break;
            if (distance(b.x, b.y, ex.x, ex.y) < ex.radius) {
                applyDamage(b, 2);
            }
          }
      });
      bombers.current = bombers.current.filter(b => b.active);
  };

  const updateEnemyMissiles = () => {
    enemyMissiles.current.forEach(m => {
        if (!m.active) return;
        m.x += m.vx;
        m.y += m.vy;

        // Update trail history
        if (m.trailHistory) {
            m.trailHistory.push({ x: m.x, y: m.y });
            if (m.trailHistory.length > 8) m.trailHistory.shift();
        }

        // Boss ember particles
        if (m.type === 'BOSS' && Math.random() < 0.3) {
            const room = 500 - particles.current.length;
            if (room > 0) {
                particles.current.push({
                    x: m.x - m.vx * 5 + (Math.random() - 0.5) * 8,
                    y: m.y - m.vy * 5 + (Math.random() - 0.5) * 8,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    color: Math.random() > 0.5 ? '#ff4400' : '#ff8800',
                    life: 10 + Math.random() * 10,
                    maxLife: 20,
                    size: 1 + Math.random() * 2,
                    shape: Math.random() > 0.5 ? 'circle' : 'square'
                });
            }
        }

        if (m.type === 'MIRV' && m.canSplit && m.y > 150 && Math.random() < 0.02) {
            m.active = false;
            createExplosion(m.x, m.y);
            spawnEnemyMissile(m.x, m.y, true);
            spawnEnemyMissile(m.x, m.y, true);
            spawnEnemyMissile(m.x, m.y, true);
            return;
        }

        // Shield collision — check before ground impact
        let shieldBlocked = false;
        if (m.active) {
            for (const c of cities) {
                if (!c.active || !c.shields) continue;
                for (const s of c.shields) {
                    if (s.damaged || s.hp <= 0) continue;
                    const scx = c.x + s.x;
                    if (m.x >= scx - s.halfWidth && m.x <= scx + s.halfWidth) {
                        // Compute floating arc Y (matches drawing formula)
                        let maxH = 20;
                        for (const bl of c.buildings) {
                            if ((bl.damage || 0) < 0.8 && Math.abs(bl.xOffset - s.x) <= s.halfWidth + bl.w / 2) {
                                maxH = Math.max(maxH, bl.h);
                            }
                        }
                        const edgeY = c.y - maxH - 10;
                        const sag = 6;
                        const t = (m.x - scx) / s.halfWidth;
                        const shieldY = edgeY - sag * (1 - t * t);
                        if (m.y >= shieldY) {
                            s.hp -= 1;
                            if (s.hp <= 0) s.damaged = true;
                            m.active = false;
                            shieldBlocked = true;
                            createParticles(m.x, shieldY, '#00ffff', 6);
                            break;
                        }
                    }
                }
                if (shieldBlocked) break;
            }
        }

        const groundY = getTerrainHeight(m.x, lowerTerrain.current);
        if (m.active && m.y >= groundY) {
            m.active = false;
            if (m.type === 'BOSS') {
                // Devastating ground impact
                createExplosion(m.x, m.y, false, 25, '#ff4400');
                screenFlash.current = 1.0;
                screenShake.current = Math.max(screenShake.current, 10);
                mushroomClouds.current.push({
                    x: m.x, y: m.y,
                    age: 0, maxAge: 120,
                    maxHeight: 70 + Math.random() * 25,
                    capSize: 40 + Math.random() * 15
                });
                // Debris shower
                createParticles(m.x, m.y, '#ff6600', 12);
                createParticles(m.x, m.y, '#884400', 8);
                // Heavy damage — wider radius, more hits
                checkCityDamage(m.x, m.y, true);
                Sound.explosion(60);
            } else {
                createExplosion(m.x, m.y);
                checkCityDamage(m.x, m.y);
            }
        }

        for (let ex of explosions.current) {
            if (!m.active) break;
            if (distance(m.x, m.y, ex.x, ex.y) < ex.radius) {
                applyDamage(m, 2);
            }
        }
    });
    enemyMissiles.current = enemyMissiles.current.filter(m => m.active);
  };

  const updatePlayerMissiles = () => {
    playerMissiles.current.forEach(m => {
        if (!m.active) return;

        if (m.type === 'SAM' && m.targetId) {
             const target = [...enemyMissiles.current, ...bombers.current].find(e => e.id === m.targetId && !e.reentryTimer);
             if (target && target.active) {
                 const angle = Math.atan2(target.y - m.y, target.x - m.x);
                 m.vx = Math.cos(angle) * SAM_SPEED;
                 m.vy = Math.sin(angle) * SAM_SPEED;
             }
        }

        // SWARM homing + evasion AI
        if (m.type === 'SWARM' && m.targetId) {
            m.age = (m.age || 0) + 1;
            // Age limit: self-destruct after 130 frames
            if (m.age > 130) {
                m.active = false;
                createExplosion(m.x, m.y, false, m.explosionRadius, m.color);
                const targets = [...enemyMissiles.current, ...bombers.current];
                targets.forEach(t => {
                    if (t.active && distance(m.x, m.y, t.x, t.y) < m.explosionRadius) {
                        applyDamage(t, m.damage);
                    }
                });
                return;
            }

            // Evasion: scan for nearby PDC projectiles
            if (m.dodgeTimer > 0) {
                m.dodgeTimer--;
                // Blend dodge impulse 50/50 with current velocity
                m.vx = m.vx * 0.5 + m.dodgeVx * 0.5;
                m.vy = m.vy * 0.5 + m.dodgeVy * 0.5;
                m.dodging = true;
            } else {
                m.dodging = false;
                // Check for nearby PDC projectiles
                for (let p of pdcProjectiles.current) {
                    if (!p.active) continue;
                    if (distance(m.x, m.y, p.x, p.y) < 40) {
                        // Compute perpendicular dodge direction
                        const dx = p.x - m.x;
                        const dy = p.y - m.y;
                        // Perpendicular (pick the side away from projectile path)
                        const cross = m.vx * dy - m.vy * dx;
                        m.dodgeVx = cross > 0 ? -dy : dy;
                        m.dodgeVy = cross > 0 ? dx : -dx;
                        // Normalize dodge impulse
                        const dLen = Math.sqrt(m.dodgeVx * m.dodgeVx + m.dodgeVy * m.dodgeVy);
                        if (dLen > 0) {
                            m.dodgeVx = (m.dodgeVx / dLen) * SWARM_SPEED;
                            m.dodgeVy = (m.dodgeVy / dLen) * SWARM_SPEED;
                        }
                        m.dodgeTimer = 8;
                        m.dodging = true;
                        break;
                    }
                }

                // Homing: turn toward target at 0.08 rad/frame
                let target = [...enemyMissiles.current, ...bombers.current].find(e => e.id === m.targetId && e.active && !e.reentryTimer);
                // Retarget if original target is dead — prefer high-value nearby enemies
                if (!target) {
                    const retargetRange = 200;
                    let bestPriority = -1;
                    let bestDist = retargetRange;
                    const swarmPriority = (t) => {
                        if (t.type === 'BOSS_SHIP') return 4;
                        if (t.type === 'BOSS') return 3;
                        if (t.type === 'BOMBER') return 2;
                        if (t.type === 'ARMORED') return 1;
                        return 0;
                    };
                    [...enemyMissiles.current, ...bombers.current].forEach(e => {
                        if (!e.active || e.reentryTimer > 0) return;
                        const d = distance(m.x, m.y, e.x, e.y);
                        if (d >= retargetRange) return;
                        const pri = swarmPriority(e);
                        if (pri > bestPriority || (pri === bestPriority && d < bestDist)) {
                            bestPriority = pri;
                            bestDist = d;
                            target = e;
                        }
                    });
                    if (target) m.targetId = target.id;
                }
                if (target) {
                    const desiredAngle = Math.atan2(target.y - m.y, target.x - m.x);
                    let currentAngle = Math.atan2(m.vy, m.vx);
                    let diff = desiredAngle - currentAngle;
                    // Normalize to [-PI, PI]
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    const turnRate = 0.08;
                    currentAngle += Math.max(-turnRate, Math.min(turnRate, diff));
                    m.vx = Math.cos(currentAngle) * SWARM_SPEED;
                    m.vy = Math.sin(currentAngle) * SWARM_SPEED;
                }
            }

            // Subtle sine-wave weave for organic look
            const weave = Math.sin(m.age * 0.3) * 0.3;
            const moveAngle = Math.atan2(m.vy, m.vx);
            m.vx += Math.cos(moveAngle + Math.PI / 2) * weave;
            m.vy += Math.sin(moveAngle + Math.PI / 2) * weave;

            // Renormalize speed
            const spd = Math.sqrt(m.vx * m.vx + m.vy * m.vy);
            if (spd > 0) {
                m.vx = (m.vx / spd) * SWARM_SPEED;
                m.vy = (m.vy / spd) * SWARM_SPEED;
            }
        }

        m.x += m.vx;
        m.y += m.vy;

        // Artillery: kinetic round with per-frame direct hit detection, no AOE
        if (m.type === 'ARTILLERY') {
            const allEnemies = [...enemyMissiles.current, ...bombers.current];
            let hit = false;
            for (let e of allEnemies) {
                if (!e.active) continue;
                const hitRadius = (e.type === 'BOSS_SHIP' || e.type === 'BOMBER') ? 18 : 10;
                if (distance(m.x, m.y, e.x, e.y) < hitRadius) {
                    m.active = false;
                    applyDamage(e, m.damage);
                    // Impact flash — small bright particles, no explosion circle
                    createParticles(m.x, m.y, '#ffffff', 4);
                    createParticles(m.x, m.y, '#ff00ff', 3);
                    Sound.explosion(5);
                    hit = true;
                    break;
                }
            }
            if (!hit) {
                const groundY = getTerrainHeight(m.x, terrain.current);
                if (m.y > groundY || m.y < 0 || m.x < 0 || m.x > GAME_WIDTH) {
                    m.active = false;
                    // Terrain impact spark
                    if (m.y > 0 && m.x > 0 && m.x < GAME_WIDTH) {
                        createParticles(m.x, m.y, '#ff00ff', 2);
                    }
                }
            }
        } else {

        let detonated = false;

        if (m.type === 'SAM') {
             const target = [...enemyMissiles.current, ...bombers.current].find(e => e.id === m.targetId);
             if (target && target.active && distance(m.x, m.y, target.x, target.y) < 15) {
                 detonated = true;
             }
        }
        else if (m.type === 'SWARM') {
            const target = [...enemyMissiles.current, ...bombers.current].find(e => e.id === m.targetId);
            if (target && target.active && distance(m.x, m.y, target.x, target.y) < 12) {
                detonated = true;
            }
        }
        else if (m.type === 'FLAK') {
            // Detonate at target altitude (y decreases going up)
            if (m.y <= m.detonateY) {
                detonated = true;
            }
        }
        else {
            const dist = distance(m.x, m.y, m.targetX, m.targetY);
            if (dist < PLAYER_PROJECTILE_SPEED) {
                detonated = true;
            }
        }

        const groundY = getTerrainHeight(m.x, terrain.current);
        if (m.y > groundY || m.y < 0 || m.x < 0 || m.x > GAME_WIDTH) {
            detonated = true;
        }

        if (detonated) {
            m.active = false;
            createExplosion(m.x, m.y, false, m.explosionRadius, m.color);

            const targets = [...enemyMissiles.current, ...bombers.current];
            targets.forEach(t => {
                if (t.active && distance(m.x, m.y, t.x, t.y) < m.explosionRadius) {
                    applyDamage(t, m.damage);
                }
            });
        }

        } // end non-artillery
    });
    playerMissiles.current = playerMissiles.current.filter(m => m.active);
  };

  const updatePdcProjectiles = () => {
      pdcProjectiles.current.forEach(p => {
          if (!p.active) return;
          p.x += p.vx;
          p.y += p.vy;
          p.life++;
          // Kill at maxLife or screen edge
          if (p.life >= p.maxLife || p.x < 0 || p.x > GAME_WIDTH || p.y < 0 || p.y > GAME_HEIGHT) {
              p.active = false;
              return;
          }
          // Check collision with player missiles (8px hit radius)
          for (let pm of playerMissiles.current) {
              if (!pm.active) continue;
              if (distance(p.x, p.y, pm.x, pm.y) < 8) {
                  p.active = false;
                  pm.active = false;
                  Sound.pointDefense();
                  for (let i = 0; i < 6; i++) {
                      particles.current.push({
                          x: pm.x, y: pm.y,
                          vx: (Math.random() - 0.5) * 4,
                          vy: (Math.random() - 0.5) * 4,
                          color: '#ff3333',
                          life: 15 + Math.random() * 10,
                          maxLife: 25,
                          size: 1.5 + Math.random() * 2,
                          shape: 'circle'
                      });
                  }
                  break;
              }
          }
      });
      pdcProjectiles.current = pdcProjectiles.current.filter(p => p.active);
  };

  const updateLasers = () => {
      lasers.current.forEach(l => l.life--);
      lasers.current = lasers.current.filter(l => l.life > 0);
  };

  const checkCityDamage = (x, y, heavy = false) => {
      const blastRadius = heavy ? 100 : 55;
      const hpDamage = heavy ? 3 : 1;
      let changed = false;
      let destroyed = false;
      let impactCasualties = 0;
      let hitCity = null;
      const newCities = cities.map(c => {
          if (!c.active) return c;

          // Check each building's absolute position against blast
          const buildingsInBlast = [];
          c.buildings.forEach((b, i) => {
              const bx = c.x + b.xOffset;
              const by = c.y;
              const dist = distance(x, y, bx, by);
              if (dist < blastRadius) {
                  buildingsInBlast.push({ index: i, dist });
              }
          });

          if (buildingsInBlast.length === 0) return c;

          changed = true;
          const newBuildings = [...c.buildings];

          // Damage buildings and calculate immediate casualties
          let cityCasualties = 0;
          buildingsInBlast.forEach(({ index, dist }) => {
              const b = { ...newBuildings[index] };
              const prevDmg = b.damage || 0;
              const proximity = 1 - (dist / blastRadius);
              if (heavy) {
                  b.damage = Math.min(1.0, prevDmg + 0.5 + proximity * 0.5);
              } else {
                  b.damage = Math.min(1.0, prevDmg + 0.15 + proximity * 0.25);
              }
              // Immediate casualties: 40-70% of building pop for the damage increase
              const pop = getBuildingPop(b);
              const dmgIncrease = b.damage - prevDmg;
              const killRate = 0.4 + proximity * 0.3;
              cityCasualties += Math.round(pop * dmgIncrease * killRate);
              newBuildings[index] = b;
          });

          // Spawn persistent ground fires at heavily damaged buildings
          buildingsInBlast.forEach(({ index }) => {
              const b = newBuildings[index];
              if ((b.damage || 0) >= 0.6) {
                  groundFires.current.push({
                      x: c.x + b.xOffset + (Math.random() - 0.5) * b.w,
                      y: c.y,
                      age: 0,
                      maxAge: 999999,
                      size: 3 + Math.random() * 4
                  });
              }
          });

          createParticles(x, y, '#f00', heavy ? 8 : 4);

          const newCasualties = (c.casualties || 0) + cityCasualties;
          impactCasualties = cityCasualties;

          const newHp = c.hp - hpDamage;
          if (newHp <= 0) {
              destroyed = true;
              const rubbleBuildings = newBuildings.map(b => ({ ...b, damage: 1.0 }));
              // Remaining population: mass casualties on destruction
              const remainingPop = c.buildings.reduce((sum, b) => {
                  const alive = getBuildingPop(b) * (1 - (b.damage || 0) * 0.7);
                  return sum + Math.round(alive);
              }, 0);
              const totalCasualties = newCasualties + Math.round(remainingPop * 0.6);
              hitCity = { casualties: totalCasualties };
              return { ...c, hp: 0, active: false, buildings: rubbleBuildings, casualties: totalCasualties };
          }
          hitCity = { casualties: newCasualties };
          return { ...c, hp: newHp, buildings: newBuildings, casualties: newCasualties };
      });

      if (changed) {
          setCities(newCities);
          if (destroyed) {
              Sound.cityDestroyed();
              setMoney(m => Math.max(0, m - CITY_REPAIR_PENALTY));
              setMessage(heavy
                  ? `DEVASTATING IMPACT: CITY DESTROYED — ${hitCity.casualties.toLocaleString()} DEAD`
                  : `CRITICAL: CITY DESTROYED — ${hitCity.casualties.toLocaleString()} DEAD`);
          } else if (hitCity) {
              Sound.enemyHit();
              setMessage(heavy
                  ? `HEAVY BOMBARDMENT — ${impactCasualties.toLocaleString()} CASUALTIES`
                  : `CITY HIT — ${impactCasualties.toLocaleString()} CASUALTIES`);
          }
      }
  };

  const updateExplosions = () => {
    explosions.current.forEach(ex => {
        if (!ex.active) return;
        // Update shockwave
        if (ex.shockwaveRadius !== undefined) {
            ex.shockwaveRadius += 3;
        }
        if (ex.growing) {
            ex.radius += EXPLOSION_GROWTH;
            if (ex.radius >= ex.maxRadius) ex.growing = false;
        } else {
            ex.radius -= EXPLOSION_GROWTH * 0.5;
            if (ex.radius <= 0) ex.active = false;
        }
    });
    explosions.current = explosions.current.filter(ex => ex.active);
  };

  const updateParticles = () => {
      particles.current.forEach(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.life--;
      });
      particles.current = particles.current.filter(p => p.life > 0);
  };

  const createExplosion = (x, y, isChain = false, maxRadius = 30, color = null) => {
      if (explosions.current.length >= 50) return;
      const mr = isChain ? 25 : maxRadius;
      if (mr > 10) Sound.explosion(mr);
      explosions.current.push({
          x, y,
          radius: 1,
          maxRadius: mr,
          growing: true,
          active: true,
          color: color || (isChain ? '#ffaa00' : '#fff'),
          shockwaveRadius: 0,
          screenShakeAmount: mr > 50 ? 4 : mr > 30 ? 2 : 0
      });
      // Screen shake for large explosions
      if (mr > 30) {
          screenShake.current = Math.max(screenShake.current, mr > 50 ? 6 : 3);
      }
  };

  const createParticles = (x, y, color, count = 8) => {
      const room = 500 - particles.current.length;
      const actual = Math.min(count, room);
      for(let i=0; i<actual; i++) {
          const maxLife = 20 + Math.random() * 20;
          particles.current.push({
              x, y,
              vx: (Math.random() - 0.5) * 5,
              vy: (Math.random() - 0.5) * 5,
              color: color,
              life: maxLife,
              maxLife: maxLife,
              size: 1 + Math.random() * 3,
              shape: Math.random() > 0.5 ? 'circle' : 'square'
          });
      }
  };

  // --- Input Handling ---
  const handleCanvasClick = (e) => {
    if (gameState !== 'PLACEMENT') return;

    const rect = canvasRef.current.getBoundingClientRect();
    const scaleX = GAME_WIDTH / rect.width;
    const scaleY = GAME_HEIGHT / rect.height;
    const x = (e.clientX - rect.left) * scaleX;
    const clickY = (e.clientY - rect.top) * scaleY;

    // Compute fgScale to match visual positions (same formula as draw loop)
    const maxBuildingH = cities.reduce((max, c) => {
        if (!c.active) return max;
        return c.buildings.reduce((m, b) => Math.max(m, (b.damage || 0) < 0.8 ? b.h : 0), max);
    }, 0);
    const cityZoneHeight = LOWER_TERRAIN_Y - CITY_ZONE_TOP + 20;
    const maxAllowed = cityZoneHeight * 0.95;
    const fgScale = maxBuildingH > maxAllowed ? maxAllowed / maxBuildingH : 1.0;

    // Check for shield generator clicks in city zone
    if (clickY > CITY_ZONE_TOP) {
        for (const c of cities) {
            if (!c.active || !c.shields) continue;
            for (let si = 0; si < c.shields.length; si++) {
                const s = c.shields[si];
                // Transform world coords to screen coords with fgScale
                const gx = GAME_WIDTH / 2 + (c.x + s.x - GAME_WIDTH / 2) * fgScale;
                const gy = GAME_HEIGHT + (c.y + 7 - GAME_HEIGHT) * fgScale;
                if (distance(x, clickY, gx, gy) < 18 * fgScale) {
                    if (s.damaged) { setMessage("SHIELD OFFLINE — REPAIRS AFTER NEXT WAVE"); return; }
                    if (s.level >= 3) { setMessage("SHIELD AT MAX LEVEL"); return; }
                    const cost = SHIELD_BASE_COST * Math.pow(10, s.level);
                    if (money < cost) { setMessage(`INSUFFICIENT FUNDS (NEED $${cost})`); return; }
                    setMoney(m => m - cost);
                    const newLevel = s.level + 1;
                    const newMaxHp = 5 + 5 * newLevel;
                    const newCities = cities.map(cc => {
                        if (cc !== c) return cc;
                        return { ...cc, shields: cc.shields.map((ss, idx) => {
                            if (idx !== si) return ss;
                            return { ...ss, level: newLevel, maxHp: newMaxHp, hp: newMaxHp };
                        })};
                    });
                    setCities(newCities);
                    const particleY = GAME_HEIGHT + (c.y - GAME_HEIGHT) * fgScale;
                    createParticles(gx, particleY, '#00ffff', 8);
                    Sound.upgrade();
                    setMessage(`SHIELD UPGRADED — LV${newLevel} (HP: ${newMaxHp})`);
                    return;
                }
            }
        }
        if (selectedAction) {
            setMessage('CANNOT PLACE IN CIVILIAN ZONE');
        }
        return;
    }

    const y = getTerrainHeight(x, upperTerrain.current);

    const clickedTurret = turrets.current.find(t => distance(x, y, t.x, t.y) < 30);
    if (clickedTurret) {
        const upgradeCost = UPGRADE_BASE_COST * Math.pow(2, clickedTurret.level - 1);
        if (money >= upgradeCost) {
            setMoney(m => m - upgradeCost);
            clickedTurret.stats.fireRate = Math.max(2, clickedTurret.stats.fireRate * 0.85);
            clickedTurret.stats.range += 40;
            clickedTurret.stats.damage *= 1.2;
            clickedTurret.level++;
            createParticles(clickedTurret.x, clickedTurret.y, '#0f0');
            Sound.upgrade();
            setMessage(`SYSTEM UPGRADED TO MK ${clickedTurret.level} (NEXT: $${UPGRADE_BASE_COST * Math.pow(2, clickedTurret.level - 1)})`);
        } else {
            setMessage(`INSUFFICIENT FUNDS (NEED $${upgradeCost})`);
        }
        return;
    }

    if (selectedAction) {
        const typeData = TURRET_TYPES[selectedAction];
        if (money >= typeData.cost) {
            setMoney(m => m - typeData.cost);
            turrets.current.push({
                id: Date.now(),
                x,
                y: y - 10,
                type: selectedAction,
                stats: { ...typeData },
                lastFired: 0,
                level: 1,
                angle: Math.PI / 2,
                recoilOffset: 0,
                muzzleFlashTimer: 0
            });
            createParticles(x, y, typeData.color);
            Sound.placeTurret();
            setSelectedAction(null);
            setMessage(`${typeData.name} ONLINE`);
        } else {
            setMessage('INSUFFICIENT FUNDS');
            setSelectedAction(null);
        }
    }
  };

  // Shield generator: compute city building extent
  const getCityExtent = (city) => {
      if (!city.buildings || city.buildings.length === 0) return { min: -20, max: 20 };
      const offsets = city.buildings.map(b => [b.xOffset - b.w / 2, b.xOffset + b.w / 2]);
      return { min: Math.min(...offsets.map(o => o[0])), max: Math.max(...offsets.map(o => o[1])) };
  };

  // Find uncovered x-ranges within city extent
  const getUncoveredRanges = (city) => {
      const ext = getCityExtent(city);
      const shields = (city.shields || []).filter(s => !s.damaged);
      if (shields.length === 0) return [{ left: ext.min, right: ext.max }];
      // Build covered intervals (relative to city center)
      const covered = shields.map(s => ({ left: s.x - s.halfWidth, right: s.x + s.halfWidth }));
      covered.sort((a, b) => a.left - b.left);
      // Merge overlapping intervals
      const merged = [covered[0]];
      for (let i = 1; i < covered.length; i++) {
          const last = merged[merged.length - 1];
          if (covered[i].left <= last.right) {
              last.right = Math.max(last.right, covered[i].right);
          } else {
              merged.push({ ...covered[i] });
          }
      }
      // Subtract from extent
      const uncovered = [];
      let cursor = ext.min;
      for (const iv of merged) {
          if (iv.left > cursor) uncovered.push({ left: cursor, right: iv.left });
          cursor = Math.max(cursor, iv.right);
      }
      if (cursor < ext.max) uncovered.push({ left: cursor, right: ext.max });
      return uncovered;
  };

  const getShieldAction = () => {
      const activeCities = cities.filter(c => c.active && !c.isVillage);
      if (activeCities.length === 0) return { action: 'none' };
      // Check if any city has a placeable gap (respecting spacing)
      for (const c of activeCities) {
          const uncovered = getUncoveredRanges(c);
          const maxGap = uncovered.reduce((max, u) => Math.max(max, u.right - u.left), 0);
          if (maxGap > 30) return {
              action: 'place',
              cost: SHIELD_BASE_COST * Math.pow(2, shieldCount.current)
          };
      }
      return { action: 'none' };
  };

  const shieldAction = () => {
      const activeCities = cities.filter(c => c.active && !c.isVillage);
      if (activeCities.length === 0) {
          setMessage("NO CITIES TO SHIELD");
          return;
      }
      // Find city with widest uncovered gap
      let bestCity = null;
      let bestGap = 0;
      let bestGapCenter = 0;
      for (const c of activeCities) {
          const uncovered = getUncoveredRanges(c);
          for (const u of uncovered) {
              const gapW = u.right - u.left;
              if (gapW > bestGap) {
                  bestGap = gapW;
                  bestCity = c;
                  bestGapCenter = (u.left + u.right) / 2;
              }
          }
      }

      if (!bestCity || bestGap <= 30) {
          setMessage("NO ROOM FOR ADDITIONAL SHIELDS");
          return;
      }

      const cost = SHIELD_BASE_COST * Math.pow(2, shieldCount.current);
      if (money < cost) { setMessage("INSUFFICIENT FUNDS"); return; }
      setMoney(m => m - cost);
      shieldCount.current++;
      const ext = getCityExtent(bestCity);
      const hw = 60;
      let clampedX = Math.max(ext.min + hw, Math.min(ext.max - hw, bestGapCenter));
      // Enforce minimum spacing from existing shields (100px center-to-center)
      const minSpacing = 100;
      const existing = (bestCity.shields || []);
      for (const es of existing) {
          const dist = clampedX - es.x;
          if (Math.abs(dist) < minSpacing) {
              clampedX = dist >= 0 ? es.x + minSpacing : es.x - minSpacing;
          }
      }
      clampedX = Math.max(ext.min + hw, Math.min(ext.max - hw, clampedX));
      const newShield = {
          x: clampedX, hp: 5, maxHp: 5, level: 0,
          halfWidth: hw, damaged: false
      };
      const newCities = cities.map(c => {
          if (c === bestCity) return { ...c, shields: [...(c.shields || []), newShield] };
          return c;
      });
      setCities(newCities);
      createParticles(bestCity.x + clampedX, bestCity.y - 20, '#00ffff', 8);
      Sound.upgrade();
      setMessage(`SHIELD GENERATOR ONLINE (HP: ${newShield.maxHp})`);
  };

  const handleMouseMove = (e) => {
      const rect = canvasRef.current.getBoundingClientRect();
      const scaleX = GAME_WIDTH / rect.width;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * (GAME_HEIGHT / rect.height);

      mousePos.current = { x, y };

      if (gameState === 'PLACEMENT') {
          // Only show turret hover when in upper terrain zone
          if (y <= CITY_ZONE_TOP) {
              const terrainY = getTerrainHeight(x, upperTerrain.current);
              const hovered = turrets.current.find(t => distance(x, terrainY, t.x, t.y) < 30);
              setHoveredTurret(hovered || null);
          } else {
              setHoveredTurret(null);
          }
      }
  };

  // --- Rendering ---
  const draw = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const fc = frameCount.current;

    // Screen shake
    ctx.save();
    if (screenShake.current > 0.5) {
        const sx = (Math.random() - 0.5) * screenShake.current * 2;
        const sy = (Math.random() - 0.5) * screenShake.current * 2;
        ctx.translate(sx, sy);
    }

    drawBackground(ctx, mapData.current, fc, level);
    drawUpperTerrain(ctx, upperTerrain.current, mapData.current);

    // Turrets on upper terrain
    turrets.current.forEach(t => {
        const isHovered = hoveredTurret && hoveredTurret.id === t.id;
        drawTurret(ctx, t, isHovered, gameState, fc);
    });

    // Compute foreground zoom-out based on tallest building
    const maxBuildingH = cities.reduce((max, c) => {
        if (!c.active) return max;
        return c.buildings.reduce((m, b) => Math.max(m, (b.damage || 0) < 0.8 ? b.h : 0), max);
    }, 0);
    const cityZoneHeight = LOWER_TERRAIN_Y - CITY_ZONE_TOP + 20; // allow slight turret overlap
    const maxAllowed = cityZoneHeight * 0.95;
    const fgScale = maxBuildingH > maxAllowed ? maxAllowed / maxBuildingH : 1.0;

    if (fgScale < 1.0) {
        ctx.save();
        // Scale from bottom-center: shrink foreground, anchored at canvas bottom
        ctx.translate(GAME_WIDTH / 2, GAME_HEIGHT);
        ctx.scale(fgScale, fgScale);
        ctx.translate(-GAME_WIDTH / 2, -GAME_HEIGHT);
    }

    drawLowerTerrain(ctx, lowerTerrain.current);

    // Cities on lower terrain
    cities.forEach(c => drawCity(ctx, c, fc));

    // Ground fires on damaged buildings
    groundFires.current.forEach(f => drawGroundFire(ctx, f, fc));

    if (fgScale < 1.0) {
        ctx.restore();
    }

    // Placement ghost — only in turret zone
    if (gameState === 'PLACEMENT' && selectedAction && mousePos.current.y <= CITY_ZONE_TOP) {
        const mx = mousePos.current.x;
        const my = getTerrainHeight(mx, upperTerrain.current);
        const typeData = TURRET_TYPES[selectedAction];

        ctx.strokeStyle = typeData.color;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(mx, my - 10, 10, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1.0;

        // Ghost range
        const ghostGrad = ctx.createRadialGradient(mx, my - 10, 0, mx, my - 10, typeData.range);
        ghostGrad.addColorStop(0, 'rgba(0, 255, 0, 0.02)');
        ghostGrad.addColorStop(1, 'rgba(0, 255, 0, 0)');
        ctx.fillStyle = ghostGrad;
        ctx.beginPath();
        ctx.arc(mx, my - 10, typeData.range, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#333';
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.arc(mx, my - 10, typeData.range, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    bombers.current.forEach(b => b.isBossShip ? drawBossShip(ctx, b, fc) : drawBomber(ctx, b, fc));
    enemyMissiles.current.forEach(m => drawEnemyMissile(ctx, m, fc));
    playerMissiles.current.forEach(m => drawPlayerMissile(ctx, m));
    pdcProjectiles.current.forEach(p => drawPdcProjectile(ctx, p));
    lasers.current.forEach(l => drawLaserBeam(ctx, l));
    explosions.current.forEach(ex => drawExplosion(ctx, ex));
    mushroomClouds.current.forEach(mc => drawMushroomCloud(ctx, mc));
    particles.current.forEach(p => drawParticle(ctx, p));

    // EMP pulse rings
    empPulses.current.forEach(p => {
        const alpha = (p.life / 60) * 0.6;
        ctx.save();
        ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
        ctx.lineWidth = 3 * (p.life / 60);
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.stroke();
        // Inner glow ring
        ctx.strokeStyle = `rgba(100, 200, 255, ${alpha * 0.4})`;
        ctx.lineWidth = 8 * (p.life / 60);
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    });

    ctx.restore(); // End screen shake

    // White screen flash (BOSS impact)
    if (screenFlash.current > 0.02) {
        ctx.fillStyle = `rgba(255, 255, 255, ${screenFlash.current * 0.7})`;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    }
  };

  const loop = useCallback(() => {
    update();
    draw();
    requestRef.current = requestAnimationFrame(loop);
  }, [update]);

  useEffect(() => {
    requestRef.current = requestAnimationFrame(loop);
    return () => cancelAnimationFrame(requestRef.current);
  }, [loop]);


  // --- UI ---
  return (
    <div className="w-full h-full min-h-screen bg-zinc-950 flex flex-col items-center p-2 font-mono text-green-500 select-none overflow-y-auto">

      {/* HUD */}
      <div className="w-full max-w-[800px] bg-black border border-green-900 p-2 mb-2 flex justify-between items-center shadow-lg rounded">
        <div className="flex gap-4 md:gap-8">
            <div className="flex flex-col">
                <span className="text-[10px] text-green-700">FUNDS</span>
                <div className="flex items-center gap-1 text-lg font-bold text-green-400">
                    <DollarSign size={16} />{money}
                </div>
            </div>
            <div className="flex flex-col">
                <span className="text-[10px] text-green-700">SCORE</span>
                <div className="flex items-center gap-1 text-lg font-bold">
                    <Trophy size={16} />{score}
                </div>
            </div>
            <div className="flex flex-col">
                <span className="text-[10px] text-green-700">POP</span>
                <div className="flex items-center gap-1 text-lg font-bold">
                    <Users size={16} />{formatNumber(cities.reduce((s, c) => s + getCityPopulation(c), 0))}
                </div>
            </div>
            <div className="flex flex-col">
                <span className="text-[10px] text-green-700">WAVE</span>
                <div className="flex items-center gap-1 text-lg font-bold">
                    <Shield size={16} />{level}
                </div>
            </div>
        </div>
        <div className="text-green-400 font-bold animate-pulse text-right text-sm">
            {message}
        </div>
      </div>

      {/* Game Viewport */}
      <div className="relative border-2 border-zinc-800 rounded shadow-2xl bg-black mb-2 overflow-hidden">
        <canvas
            ref={canvasRef}
            width={GAME_WIDTH}
            height={GAME_HEIGHT}
            onClick={handleCanvasClick}
            onMouseMove={handleMouseMove}
            className="block cursor-crosshair max-w-full h-auto"
        />

        {/* --- OVERLAYS --- */}

        {gameState === 'START' && (
            <div className="absolute inset-0 bg-black/90 flex flex-col items-center justify-center">
                <h1 className="text-4xl md:text-6xl font-black text-green-500 tracking-tighter mb-4" style={{textShadow: '0 0 15px #0f0'}}>VECTOR DEFENSE</h1>
                <p className="text-green-700 mb-8 tracking-widest text-center">DEFEND THE CITIES</p>
                <div className="flex flex-col gap-3">
                    {hasSave() && (
                        <button onClick={resumeGame} className="px-8 py-3 border border-green-500 text-green-500 hover:bg-green-500 hover:text-black font-bold uppercase tracking-widest transition-all">
                            Continue (Wave {(() => { try { const s = JSON.parse(localStorage.getItem(SAVE_KEY)); return s?.level || '?'; } catch(e) { return '?'; } })()})
                        </button>
                    )}
                    <button onClick={initGame} className="px-8 py-3 border border-green-500 text-green-500 hover:bg-green-500 hover:text-black font-bold uppercase tracking-widest transition-all">
                        {hasSave() ? 'New Game' : 'Initialize'}
                    </button>
                </div>
            </div>
        )}

        {/* LEVEL COMPLETE */}
        {gameState === 'LEVEL_COMPLETE' && bonusReport && (
             <div className="absolute inset-0 bg-black flex flex-col items-center justify-center font-mono">
                <h2 className="text-4xl text-green-500 font-bold mb-8 blink">WAVE {bonusReport.wave} CLEARED</h2>

                <div className="w-64 space-y-4 mb-8 text-green-400">
                    <div className="flex justify-between border-b border-green-900 pb-1">
                        <span>BASE BONUS</span>
                        <span>{bonusReport.base}</span>
                    </div>
                    <div className="flex justify-between border-b border-green-900 pb-1">
                        <span>CITIES SECURE ({bonusReport.cityCount})</span>
                        <span>{bonusReport.cityBonus}</span>
                    </div>
                    {bonusReport.repairedCount > 0 && (
                    <div className="flex justify-between border-b border-cyan-900 pb-1 text-cyan-400">
                        <span>CITIES REPAIRED</span>
                        <span>{bonusReport.repairedCount}</span>
                    </div>
                    )}
                    {bonusReport.growingCount > 0 && (
                    <div className="flex justify-between border-b border-emerald-900 pb-1 text-emerald-400">
                        <span>CITIES GROWING</span>
                        <span>{bonusReport.growingCount}</span>
                    </div>
                    )}
                    {bonusReport.villageCount > 0 && (
                    <div className="flex justify-between border-b border-amber-900 pb-1 text-amber-400">
                        <span>VILLAGES SETTLED</span>
                        <span>{bonusReport.villageCount}</span>
                    </div>
                    )}
                    <div className="flex justify-between text-yellow-400 font-bold pt-2">
                        <span>TOTAL FUNDS</span>
                        <span>+{bonusReport.total}</span>
                    </div>
                </div>

                <button
                    onClick={advanceLevel}
                    className="px-8 py-3 bg-green-900 text-white font-bold hover:bg-green-700 animate-pulse border border-green-500"
                >
                    PROCEED TO NEXT SECTOR
                </button>
             </div>
        )}

        {/* GAME OVER */}
        {gameState === 'GAME_OVER' && (
            <div className="absolute inset-0 bg-black/95 flex flex-col items-center justify-center">
                <h2 className="text-5xl text-red-500 font-bold mb-2 glitch-effect">SECTOR LOST</h2>
                <div className="text-2xl mb-8 border border-green-900 px-6 py-2 text-white">FINAL SCORE: {score}</div>
                <button onClick={initGame} className="flex items-center gap-2 px-6 py-3 border border-red-500 text-red-500 hover:bg-red-900/30 font-bold transition-all">
                    <RotateCcw size={18} /> REBOOT SYSTEM
                </button>
            </div>
        )}
      </div>

      {/* Armory */}
      <div className={`w-full max-w-[800px] transition-all duration-300 ${gameState === 'PLACEMENT' ? 'opacity-100 translate-y-0' : 'opacity-30 grayscale pointer-events-none'}`}>
          <div className="grid grid-cols-2 md:grid-cols-[1fr_auto] gap-2">

              <div className="bg-black border border-green-900 p-2 rounded flex flex-wrap gap-2 justify-center md:justify-start">

                  {Object.keys(TURRET_TYPES).map(key => {
                      const t = TURRET_TYPES[key];
                      const Icon = t.icon;
                      return (
                        <button
                            key={key}
                            onClick={() => setSelectedAction(key)}
                            className={`flex flex-col items-center justify-center w-20 h-20 border rounded transition-all ${selectedAction === key ? 'bg-green-900/40 border-green-400' : 'border-zinc-800 hover:border-zinc-600'}`}
                        >
                            <Icon size={20} style={{color: t.color}} className="mb-1" />
                            <span className="text-[10px] font-bold text-zinc-300">{t.name}</span>
                            <span className="text-[10px] text-green-600">${t.cost}</span>
                        </button>
                      );
                  })}

                  <div className="w-px bg-zinc-800 mx-1"></div>

                   {(() => {
                        const sa = getShieldAction();
                        const disabled = sa.action === 'none';
                        return (
                            <button
                                onClick={shieldAction}
                                disabled={disabled}
                                className={`flex flex-col items-center justify-center w-20 h-20 border rounded transition-all ${disabled ? 'border-zinc-800 opacity-40 cursor-not-allowed' : 'border-zinc-800 hover:border-cyan-500 group'}`}
                            >
                                <ShieldPlus size={20} className="text-cyan-400 mb-1 group-hover:animate-pulse" />
                                <span className="text-[10px] font-bold text-zinc-300">SHIELD</span>
                                {!disabled && <span className="text-[10px] text-cyan-400">${sa.cost}</span>}
                            </button>
                        );
                    })()}
              </div>

              <button
                onClick={startWave}
                className="col-span-2 md:col-span-1 bg-green-900/20 border border-green-600 text-green-400 hover:bg-green-500 hover:text-black transition-all px-6 rounded font-bold text-lg flex items-center justify-center uppercase tracking-wider"
              >
                  <Play size={24} className="mr-2" /> ENGAGE
              </button>
          </div>
          <div className="text-center text-xs text-zinc-600 mt-2">
            Click turrets or shield generators to upgrade
          </div>
      </div>

      <style>{`
        @keyframes blink { 50% { opacity: 0; } }
        .blink { animation: blink 1s step-end infinite; }
      `}</style>
    </div>
  );
};

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
