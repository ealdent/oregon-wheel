<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Defense</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        html, body { margin: 0; padding: 0; background: #09090b; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
const { useState, useEffect, useRef, useCallback } = React;

// --- Inline SVG Icon Components (replacing lucide-react) ---
const SvgIcon = ({ children, size = 24, className = '', style = {}, ...props }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24"
         fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round"
         strokeLinejoin="round" className={className} style={style} {...props}>
        {children}
    </svg>
);

const Play = (props) => <SvgIcon {...props}><polygon points="5 3 19 12 5 21 5 3"/></SvgIcon>;
const RotateCcw = (props) => <SvgIcon {...props}><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></SvgIcon>;
const Shield = (props) => <SvgIcon {...props}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></SvgIcon>;
const DollarSign = (props) => <SvgIcon {...props}><line x1="12" y1="1" x2="12" y2="23"/><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/></SvgIcon>;
const Crosshair = (props) => <SvgIcon {...props}><circle cx="12" cy="12" r="10"/><line x1="22" y1="12" x2="18" y2="12"/><line x1="6" y1="12" x2="2" y2="12"/><line x1="12" y1="6" x2="12" y2="2"/><line x1="12" y1="22" x2="12" y2="18"/></SvgIcon>;
const Trophy = (props) => <SvgIcon {...props}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></SvgIcon>;
const AlertTriangle = (props) => <SvgIcon {...props}><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></SvgIcon>;
const Zap = (props) => <SvgIcon {...props}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></SvgIcon>;
const Target = (props) => <SvgIcon {...props}><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></SvgIcon>;
const Wifi = (props) => <SvgIcon {...props}><path d="M5 12.55a11 11 0 0 1 14.08 0"/><path d="M1.42 9a16 16 0 0 1 21.16 0"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><line x1="12" y1="20" x2="12.01" y2="20"/></SvgIcon>;

// --- Constants ---
const GAME_WIDTH = 800;
const GAME_HEIGHT = 600;
const PLAYER_PROJECTILE_SPEED = 15;
const SAM_SPEED = 7;
const EXPLOSION_GROWTH = 1.5;

// Balance Constants
const FLAK_COST = 800;
const SAM_COST = 1800;
const ARTILLERY_COST = 2800;
const LASER_COST = 4500;
const UPGRADE_BASE_COST = 500;
const REPAIR_COST = 2000;
const CITY_REPAIR_PENALTY = 300;
const WAVE_COMPLETE_BONUS = 2500;

// Enemy Stats (HP values)
const HP_NORMAL = 10;
const HP_FAST = 15;
const HP_ARMORED = 40;
const HP_BOSS_BASE = 200;

// Turret Stats
const TURRET_TYPES = {
  FLAK: {
    name: 'FLAK',
    desc: 'Area Damage',
    color: '#00ff00',
    range: 280,
    fireRate: 20,
    explosionRadius: 35,
    projectileColor: '#0f0',
    damage: 10,
    cost: FLAK_COST,
    icon: Crosshair
  },
  SAM: {
    name: 'SAM',
    desc: 'High Impact',
    color: '#00ffff',
    range: 400,
    fireRate: 45,
    explosionRadius: 20,
    projectileColor: '#0ff',
    damage: 40,
    cost: SAM_COST,
    icon: Target
  },
  ARTILLERY: {
    name: 'ARTILLERY',
    desc: 'Massive Area',
    color: '#ff00ff',
    range: 350,
    fireRate: 70,
    explosionRadius: 100,
    projectileColor: '#f0f',
    damage: 20,
    cost: ARTILLERY_COST,
    icon: Shield
  },
  LASER: {
    name: 'LASER',
    desc: 'Focused Beam',
    color: '#ffff00',
    range: 500,
    fireRate: 8,
    explosionRadius: 10,
    projectileColor: '#ff0',
    damage: 3,
    cost: LASER_COST,
    icon: Zap
  }
};

// --- Helper Functions ---
const distance = (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);

const App = () => {
  const canvasRef = useRef(null);
  const requestRef = useRef();

  // Game State
  const [gameState, setGameState] = useState('START');
  const [money, setMoney] = useState(3500);
  const [score, setScore] = useState(0);
  const [level, setLevel] = useState(1);
  const [message, setMessage] = useState('');
  const [bonusReport, setBonusReport] = useState(null);

  // Entities
  const [cities, setCities] = useState([]);
  const turrets = useRef([]);

  // Refs
  const enemyMissiles = useRef([]);
  const bombers = useRef([]);
  const playerMissiles = useRef([]);
  const lasers = useRef([]);
  const explosions = useRef([]);
  const particles = useRef([]);
  const terrain = useRef([]);
  const mousePos = useRef({ x: 0, y: 0 });
  const blinkTimer = useRef(0);

  // Placement State
  const [selectedAction, setSelectedAction] = useState(null);
  const [hoveredTurret, setHoveredTurret] = useState(null);

  // Level Config
  const levelConfig = useRef({
    spawnTimer: 0,
    spawnInterval: 100,
    totalToSpawn: 0,
    bomberTimer: 0
  });
  const waveCompleted = useRef(false);

  // --- Map Generation ---
  const generateMap = useCallback((numCities, lvl = 1) => {
    const points = [];
    const segments = 80;
    const segmentWidth = GAME_WIDTH / segments;
    const citySlots = [];
    const padding = 80;
    const availableWidth = GAME_WIDTH - (padding * 2);
    const spacing = availableWidth / (numCities - 1 || 1);

    for (let i = 0; i < numCities; i++) {
        const jitter = (Math.random() - 0.5) * 60;
        let cx = padding + (i * spacing) + jitter;
        cx = Math.max(50, Math.min(GAME_WIDTH - 50, cx));
        citySlots.push({ x: cx, w: 40 });
    }

    for(let i=0; i<=segments; i++) {
        const x = i * segmentWidth;
        let distToCity = Infinity;
        citySlots.forEach(slot => {
            const d = Math.abs(x - slot.x);
            if (d < distToCity) distToCity = d;
        });

        let height = 0;
        if (distToCity < 50) {
            height = 20;
        } else {
            const blend = Math.min(1, (distToCity - 50) / 80);
            const noise = Math.random() * 40;
            const mountainHeight = 120 + (Math.sin(i * 0.3) * 80) + (Math.cos(i * 1.5) * 20) + noise;
            height = 20 + (mountainHeight * blend);
        }
        points.push({ x: x, y: GAME_HEIGHT - height });
    }
    terrain.current = points;

    const newCities = citySlots.map(slot => {
        const cy = getTerrainHeight(slot.x, points);
        const buildings = [];
        const growthFactor = 1 + (lvl - 1) * 0.1;
        const count = Math.floor((4 + Math.floor(Math.random() * 4)) * growthFactor);
        for(let b=0; b<count; b++) {
            buildings.push({
                w: (6 + Math.random() * 12) * growthFactor,
                h: (15 + Math.random() * 25) * growthFactor,
                xOffset: (Math.random() - 0.5) * 35 * growthFactor
            });
        }
        return { x: slot.x, y: cy, active: true, buildings };
    });
    setCities(newCities);
    return points;
  }, []);

  const getTerrainHeight = (x, terrainPoints) => {
      if (!terrainPoints || terrainPoints.length === 0) return GAME_HEIGHT;
      if (typeof x !== 'number' || isNaN(x)) return GAME_HEIGHT;
      const segmentWidth = GAME_WIDTH / (terrainPoints.length - 1);
      const index = Math.floor(x / segmentWidth);
      if (index < 0 || index >= terrainPoints.length - 1) return GAME_HEIGHT;
      const p1 = terrainPoints[index];
      const p2 = terrainPoints[index+1];
      if (!p1 || !p2) return GAME_HEIGHT;
      const ratio = (x - p1.x) / (p2.x - p1.x);
      return p1.y + (p2.y - p1.y) * ratio;
  };

  // --- Initialization ---
  const initGame = useCallback(() => {
    setMoney(3500);
    setScore(0);
    setLevel(1);
    setGameState('PLACEMENT');
    setMessage('Commander, hostile forces inbound.');
    turrets.current = [];
    resetEntities();
    generateMap(3);
    setupLevel(1);
  }, [generateMap]);

  const setupLevel = (lvl) => {
    levelConfig.current = {
        spawnTimer: 0,
        spawnInterval: Math.max(15, 90 - (lvl * 3)),
        totalToSpawn: 12 + (lvl * 4),
        bomberTimer: 0
    };
  };

  const resetEntities = () => {
    enemyMissiles.current = [];
    bombers.current = [];
    playerMissiles.current = [];
    lasers.current = [];
    explosions.current = [];
    particles.current = [];
  };

  const startWave = () => {
      if (turrets.current.length === 0) {
          setMessage("WARNING: NO DEFENSES PLACED");
          setTimeout(() => setMessage(`WAVE ${level} INBOUND`), 2000);
      } else {
          setMessage(`WAVE ${level} ENGAGING`);
      }
      waveCompleted.current = false;
      setGameState('PLAYING');
      setSelectedAction(null);
  };

  // --- Game Loop ---
  const update = useCallback(() => {
    if (gameState === 'PLAYING') {
        const cfg = levelConfig.current;
        cfg.spawnTimer++;
        cfg.bomberTimer++;

        // Spawn Logic
        if (cfg.totalToSpawn > 0 && cfg.spawnTimer > cfg.spawnInterval) {
            spawnEnemyMissile();
            cfg.spawnTimer = 0;
            cfg.totalToSpawn--;
        }

        if (level >= 3 && cfg.bomberTimer > 500 && Math.random() < 0.25) {
            spawnBomber();
            cfg.bomberTimer = 0;
        }

        // Turret Logic
        turrets.current.forEach(turret => {
            turret.lastFired++;
            let target = null;
            let minDist = turret.stats.range;

            const allTargets = [...bombers.current, ...enemyMissiles.current];

            // Laser turrets prefer their current target for beam continuity
            if (turret.type === 'LASER' && turret.laserTarget) {
                const cur = allTargets.find(m => m.id === turret.laserTarget);
                if (cur && cur.active && distance(turret.x, turret.y, cur.x, cur.y) < turret.stats.range) {
                    target = cur;
                }
            }

            if (!target) {
                allTargets.forEach(m => {
                    if (!m.active) return;
                    let d = distance(turret.x, turret.y, m.x, m.y);
                    if (d < minDist) {
                        minDist = d;
                        target = m;
                    }
                });
            }

            if (turret.type === 'LASER') {
                if (target) {
                    if (turret.laserTarget === target.id) {
                        turret.dwellTime = (turret.dwellTime || 0) + 1;
                    } else {
                        turret.laserTarget = target.id;
                        turret.dwellTime = 0;
                    }
                    if (turret.lastFired >= turret.stats.fireRate) {
                        fireTurret(turret, target);
                        turret.lastFired = 0;
                    }
                } else {
                    turret.laserTarget = null;
                    turret.dwellTime = 0;
                }
            } else if (target && turret.lastFired >= turret.stats.fireRate) {
                fireTurret(turret, target);
                turret.lastFired = 0;
            }
        });

        updateEnemyMissiles();
        updateBombers();
        updatePlayerMissiles();
        updateLasers();
        updateExplosions();
        updateParticles();

        if (!waveCompleted.current && cfg.totalToSpawn === 0 && enemyMissiles.current.length === 0 && bombers.current.length === 0 && explosions.current.length === 0) {
            waveCompleted.current = true;
            handleWaveComplete();
        }

        if (cities.filter(c => c.active).length === 0) {
            setGameState('GAME_OVER');
        }
    } else {
        updateParticles();
        updateExplosions();
        blinkTimer.current++;
    }
  }, [gameState, cities, level]);

  const handleWaveComplete = () => {
      const levelMult = 1 + (level - 1) * 0.15;
      const baseBonus = Math.round(WAVE_COMPLETE_BONUS * levelMult);
      const cityBonus = cities.filter(c => c.active).length * Math.round(500 * levelMult);
      const totalBonus = baseBonus + cityBonus;

      setBonusReport({
          wave: level,
          base: baseBonus,
          cityCount: cities.filter(c => c.active).length,
          cityBonus: cityBonus,
          total: totalBonus
      });

      setMoney(prev => prev + totalBonus);
      setGameState('LEVEL_COMPLETE');
  };

  const findMountainPeaks = (terrainPoints, count) => {
      const candidates = terrainPoints
          .filter((p, i) => i > 5 && i < terrainPoints.length - 5)
          .map(p => ({ x: p.x, y: p.y }))
          .sort((a, b) => a.y - b.y);
      const peaks = [];
      for (const c of candidates) {
          if (peaks.every(p => Math.abs(p.x - c.x) > 60)) {
              peaks.push(c);
              if (peaks.length >= count) break;
          }
      }
      return peaks;
  };

  const advanceLevel = () => {
      const nextLvl = level + 1;
      setLevel(nextLvl);
      const nextCities = Math.max(1, 3 - Math.floor(nextLvl / 5));
      const newTerrainPoints = generateMap(nextCities, nextLvl);

      const peaks = findMountainPeaks(newTerrainPoints, turrets.current.length);
      turrets.current.forEach((t, i) => {
          if (peaks[i]) {
              t.x = peaks[i].x;
              t.y = peaks[i].y - 10;
          } else {
              const newY = getTerrainHeight(t.x, newTerrainPoints);
              t.y = newY - 10;
          }
          createParticles(t.x, t.y, '#00ff00');
      });

      resetEntities();
      setupLevel(nextLvl);

      setGameState('LEVEL_START');
      setTimeout(() => {
          setGameState('PLACEMENT');
          setMessage('DEFENSES RELOCATED. PREPARE FOR BATTLE.');
      }, 3000);
  };

  // --- Logic Helpers ---
  const applyDamage = (enemy, damage) => {
      if (!enemy.active || enemy.hp <= 0) return;
      enemy.hp -= damage;
      if (enemy.hp <= 0) {
          enemy.active = false;
          const levelMult = 1 + (level - 1) * 0.15;
          let reward = Math.round(50 * levelMult);
          let scoreReward = Math.round(100 * levelMult);
          if (enemy.type === 'BOSS') { reward = Math.round(800 * levelMult); scoreReward = Math.round(2000 * levelMult); }
          if (enemy.type === 'ARMORED') { reward = Math.round(100 * levelMult); scoreReward = Math.round(300 * levelMult); }

          setMoney(m => m + reward);
          setScore(s => s + scoreReward);

          createExplosion(enemy.x, enemy.y, true, enemy.type === 'BOSS' ? 80 : 30);
          createParticles(enemy.x, enemy.y, enemy.color);
      } else {
          createParticles(enemy.x, enemy.y, '#fff', 2);
      }
  };

  const fireTurret = (turret, target) => {
      if (turret.type === 'LASER') {
          const dist = distance(turret.x, turret.y, target.x, target.y);
          const distFalloff = Math.max(0.2, 1 - (dist / turret.stats.range) * 0.8);
          const dwellBonus = 1 + Math.min((turret.dwellTime || 0) / 30, 5);
          const finalDamage = turret.stats.damage * distFalloff * dwellBonus;
          const beamWidth = Math.min(1 + (turret.dwellTime || 0) / 15, 6);
          lasers.current.push({
              x1: turret.x, y1: turret.y,
              x2: target.x, y2: target.y,
              color: turret.stats.projectileColor,
              life: turret.stats.fireRate,
              width: beamWidth
          });
          if ((turret.dwellTime || 0) > 10) {
              createParticles(target.x, target.y, '#ff00ff', 1);
          }
          applyDamage(target, finalDamage);
          return;
      }

      if (turret.type === 'SAM') {
           playerMissiles.current.push({
              x: turret.x,
              y: turret.y,
              vx: 0,
              vy: -SAM_SPEED,
              targetId: target.id,
              active: true,
              type: 'SAM',
              color: turret.stats.projectileColor,
              damage: turret.stats.damage,
              explosionRadius: turret.stats.explosionRadius
          });
          return;
      }

      const dist = distance(turret.x, turret.y, target.x, target.y);
      const timeToHit = dist / PLAYER_PROJECTILE_SPEED;
      const predX = target.x + (target.vx * timeToHit);
      const predY = target.y + (target.vy * timeToHit);
      const angle = Math.atan2(predY - turret.y, predX - turret.x);

      playerMissiles.current.push({
          x: turret.x,
          y: turret.y,
          vx: Math.cos(angle) * PLAYER_PROJECTILE_SPEED,
          vy: Math.sin(angle) * PLAYER_PROJECTILE_SPEED,
          targetX: predX,
          targetY: predY,
          active: true,
          type: turret.type,
          color: turret.stats.projectileColor,
          damage: turret.stats.damage,
          explosionRadius: turret.stats.explosionRadius
      });
  };

  const spawnEnemyMissile = (originX = null, originY = null, isBomblet = false) => {
    const startX = originX ?? Math.random() * GAME_WIDTH;
    const startY = originY ?? 0;

    const validCities = cities.filter(c => c.active);
    if (validCities.length === 0) return;
    const targetCity = validCities[Math.floor(Math.random() * validCities.length)];

    const angle = Math.atan2(targetCity.y - startY, targetCity.x - startX);

    let type = 'NORMAL';
    let speed = 0.8 + (level * 0.08);
    let color = '#ff0000';
    let maxHp = HP_NORMAL;
    let size = 4;
    let canSplit = false;

    if (!isBomblet) {
        const rand = Math.random();

        if (level >= 5 && rand < 0.05) {
            type = 'BOSS';
            speed = 0.4;
            maxHp = HP_BOSS_BASE + (level * 50);
            size = 15;
            color = '#ff0000';
        }
        else if (level >= 7 && rand < 0.2) {
            type = 'MIRV'; canSplit = true; color = '#ffaa00'; maxHp = HP_NORMAL * 2;
        }
        else if (level >= 4 && rand < 0.3) {
            type = 'ARMORED';
            speed *= 1.1;
            maxHp = HP_ARMORED;
            size = 6;
            color = '#ffffff';
        }
        else if (level >= 3 && rand < 0.45) {
            type = 'FAST';
            speed = 2.2 + (level * 0.1);
            color = '#bd00ff';
            maxHp = HP_FAST;
        }
    }

    enemyMissiles.current.push({
        id: Math.random().toString(36),
        x: startX,
        y: startY,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        active: true,
        type,
        color,
        maxHp,
        hp: maxHp,
        size,
        canSplit
    });
  };

  const spawnBomber = () => {
      const fromLeft = Math.random() > 0.5;
      const y = 50 + Math.random() * 80;
      bombers.current.push({
          id: Math.random().toString(36),
          x: fromLeft ? -50 : GAME_WIDTH + 50,
          y: y,
          vx: fromLeft ? 1.2 : -1.2,
          active: true,
          type: 'BOMBER',
          maxHp: 60,
          hp: 60,
          color: '#ffff00',
          size: 10,
          lastDrop: 0
      });
  };

  const updateBombers = () => {
      bombers.current.forEach(b => {
          if (!b.active) return;
          b.x += b.vx;
          b.lastDrop++;
          if (b.lastDrop > 50 && Math.random() < 0.03) {
              spawnEnemyMissile(b.x, b.y, true);
              b.lastDrop = 0;
          }
          if (b.x < -100 || b.x > GAME_WIDTH + 100) b.active = false;

          for (let ex of explosions.current) {
            if (!b.active) break;
            if (distance(b.x, b.y, ex.x, ex.y) < ex.radius) {
                applyDamage(b, 2);
            }
          }
      });
      bombers.current = bombers.current.filter(b => b.active);
  };

  const updateEnemyMissiles = () => {
    enemyMissiles.current.forEach(m => {
        if (!m.active) return;
        m.x += m.vx;
        m.y += m.vy;

        if (m.type === 'MIRV' && m.canSplit && m.y > 150 && Math.random() < 0.02) {
            m.active = false;
            createExplosion(m.x, m.y);
            spawnEnemyMissile(m.x, m.y, true);
            spawnEnemyMissile(m.x, m.y, true);
            spawnEnemyMissile(m.x, m.y, true);
            return;
        }

        const groundY = getTerrainHeight(m.x, terrain.current);
        if (m.y >= groundY) {
            m.active = false;
            createExplosion(m.x, m.y);
            checkCityDamage(m.x, m.y);
        }

        for (let ex of explosions.current) {
            if (!m.active) break;
            if (distance(m.x, m.y, ex.x, ex.y) < ex.radius) {
                applyDamage(m, 2);
            }
        }
    });
    enemyMissiles.current = enemyMissiles.current.filter(m => m.active);
  };

  const updatePlayerMissiles = () => {
    playerMissiles.current.forEach(m => {
        if (!m.active) return;

        if (m.type === 'SAM' && m.targetId) {
             const target = [...enemyMissiles.current, ...bombers.current].find(e => e.id === m.targetId);
             if (target && target.active) {
                 const angle = Math.atan2(target.y - m.y, target.x - m.x);
                 m.vx = Math.cos(angle) * SAM_SPEED;
                 m.vy = Math.sin(angle) * SAM_SPEED;
             }
        }

        m.x += m.vx;
        m.y += m.vy;

        let detonated = false;

        if (m.type === 'SAM') {
             const target = [...enemyMissiles.current, ...bombers.current].find(e => e.id === m.targetId);
             if (target && target.active && distance(m.x, m.y, target.x, target.y) < 15) {
                 detonated = true;
             }
        }
        else {
            const dist = distance(m.x, m.y, m.targetX, m.targetY);
            if (dist < PLAYER_PROJECTILE_SPEED) {
                detonated = true;
            }
        }

        const groundY = getTerrainHeight(m.x, terrain.current);
        if (m.y > groundY || m.y < 0 || m.x < 0 || m.x > GAME_WIDTH) {
            detonated = true;
        }

        if (detonated) {
            m.active = false;
            createExplosion(m.x, m.y, false, m.explosionRadius, m.color);

            const targets = [...enemyMissiles.current, ...bombers.current];
            targets.forEach(t => {
                if (t.active && distance(m.x, m.y, t.x, t.y) < m.explosionRadius) {
                    applyDamage(t, m.damage);
                }
            });
        }
    });
    playerMissiles.current = playerMissiles.current.filter(m => m.active);
  };

  const updateLasers = () => {
      lasers.current.forEach(l => l.life--);
      lasers.current = lasers.current.filter(l => l.life > 0);
  };

  const checkCityDamage = (x, y) => {
      let damageDealt = false;
      const newCities = cities.map(c => {
          if (c.active && distance(x, y, c.x, c.y) < 55) {
              createParticles(c.x, c.y, '#f00');
              damageDealt = true;
              return { ...c, active: false };
          }
          return c;
      });

      if (damageDealt) {
          setCities(newCities);
          setMoney(m => Math.max(0, m - CITY_REPAIR_PENALTY));
          setMessage('CRITICAL: CITY LOST.');
      }
  };

  const updateExplosions = () => {
    explosions.current.forEach(ex => {
        if (!ex.active) return;
        if (ex.growing) {
            ex.radius += EXPLOSION_GROWTH;
            if (ex.radius >= ex.maxRadius) ex.growing = false;
        } else {
            ex.radius -= EXPLOSION_GROWTH * 0.5;
            if (ex.radius <= 0) ex.active = false;
        }
    });
    explosions.current = explosions.current.filter(ex => ex.active);
  };

  const updateParticles = () => {
      particles.current.forEach(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.life--;
      });
      particles.current = particles.current.filter(p => p.life > 0);
  };

  const createExplosion = (x, y, isChain = false, maxRadius = 30, color = null) => {
      if (explosions.current.length >= 50) return;
      explosions.current.push({
          x, y,
          radius: 1,
          maxRadius: isChain ? 25 : maxRadius,
          growing: true,
          active: true,
          color: color || (isChain ? '#ffaa00' : '#fff')
      });
  };

  const createParticles = (x, y, color, count = 8) => {
      const room = 500 - particles.current.length;
      const actual = Math.min(count, room);
      for(let i=0; i<actual; i++) {
          particles.current.push({
              x, y,
              vx: (Math.random() - 0.5) * 5,
              vy: (Math.random() - 0.5) * 5,
              color: color,
              life: 20 + Math.random() * 20
          });
      }
  };

  // --- Input Handling ---
  const handleCanvasClick = (e) => {
    if (gameState !== 'PLACEMENT') return;

    const rect = canvasRef.current.getBoundingClientRect();
    const scaleX = GAME_WIDTH / rect.width;
    const x = (e.clientX - rect.left) * scaleX;
    const y = getTerrainHeight(x, terrain.current);

    const clickedTurret = turrets.current.find(t => distance(x, y, t.x, t.y) < 30);
    if (clickedTurret) {
        const upgradeCost = UPGRADE_BASE_COST * Math.pow(2, clickedTurret.level - 1);
        if (money >= upgradeCost) {
            setMoney(m => m - upgradeCost);
            clickedTurret.stats.fireRate = Math.max(2, clickedTurret.stats.fireRate * 0.85);
            clickedTurret.stats.range += 40;
            clickedTurret.stats.damage *= 1.2;
            clickedTurret.level++;
            createParticles(clickedTurret.x, clickedTurret.y, '#0f0');
            setMessage(`SYSTEM UPGRADED TO MK ${clickedTurret.level} (NEXT: $${UPGRADE_BASE_COST * Math.pow(2, clickedTurret.level - 1)})`);
        } else {
            setMessage(`INSUFFICIENT FUNDS (NEED $${upgradeCost})`);
        }
        return;
    }

    if (selectedAction) {
        if (selectedAction === 'REPAIR') return;
        const typeData = TURRET_TYPES[selectedAction];
        if (money >= typeData.cost) {
            setMoney(m => m - typeData.cost);
            turrets.current.push({
                id: Date.now(),
                x,
                y: y - 10,
                type: selectedAction,
                stats: { ...typeData },
                lastFired: 0,
                level: 1
            });
            createParticles(x, y, typeData.color);
            setSelectedAction(null);
            setMessage(`${typeData.name} ONLINE`);
        } else {
            setMessage('INSUFFICIENT FUNDS');
            setSelectedAction(null);
        }
    }
  };

  const buyRepair = () => {
      if (money >= REPAIR_COST) {
          if (cities.length < 5) {
               setMoney(m => m - REPAIR_COST);
               const deadCity = cities.find(c => !c.active);
               if (deadCity) {
                   deadCity.active = true;
                   deadCity.buildings = [];
                   createParticles(deadCity.x, deadCity.y, '#0ff');
                   setMessage("CITY RECONSTRUCTED");
                   setCities([...cities]);
               } else {
                   setMessage("ALL CITIES OPERATIONAL");
                   setMoney(m => m + REPAIR_COST);
               }
          } else {
              setMessage("MAX CITIES REACHED");
          }
      } else {
          setMessage("INSUFFICIENT FUNDS");
      }
  };

  const handleMouseMove = (e) => {
      const rect = canvasRef.current.getBoundingClientRect();
      const scaleX = GAME_WIDTH / rect.width;
      const x = (e.clientX - rect.left) * scaleX;
      const terrainY = getTerrainHeight(x, terrain.current);
      const y = (e.clientY - rect.top) * (GAME_HEIGHT / rect.height);

      mousePos.current = { x, y };

      if (gameState === 'PLACEMENT') {
          const hovered = turrets.current.find(t => distance(x, terrainY, t.x, t.y) < 30);
          setHoveredTurret(hovered || null);
      }
  };

  // --- Rendering ---
  const draw = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = '#050510';
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    for (let i = 0; i < GAME_HEIGHT; i += 4) {
        ctx.fillRect(0, i, GAME_WIDTH, 1);
    }

    ctx.strokeStyle = '#111';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let i=0; i<GAME_WIDTH; i+=50) { ctx.moveTo(i, 0); ctx.lineTo(i, GAME_HEIGHT); }
    for(let i=0; i<GAME_HEIGHT; i+=50) { ctx.moveTo(0, i); ctx.lineTo(GAME_WIDTH, i); }
    ctx.stroke();

    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 2;
    ctx.beginPath();
    if (terrain.current.length > 0) {
        ctx.moveTo(0, GAME_HEIGHT);
        ctx.lineTo(0, terrain.current[0].y);
        terrain.current.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.lineTo(GAME_WIDTH, terrain.current[terrain.current.length-1].y);
        ctx.lineTo(GAME_WIDTH, GAME_HEIGHT);
    }
    ctx.stroke();
    ctx.fillStyle = '#001a00';
    ctx.fill();

    cities.forEach(c => {
        if (!c.active) return;
        ctx.fillStyle = '#00ffff';
        c.buildings.forEach(b => {
             ctx.fillRect(c.x + b.xOffset - (b.w/2), c.y - b.h, b.w, b.h);
             ctx.strokeStyle = '#0088aa';
             ctx.strokeRect(c.x + b.xOffset - (b.w/2), c.y - b.h, b.w, b.h);
             ctx.fillStyle = '#fff';
             if (Math.random() > 0.9) ctx.fillRect(c.x + b.xOffset, c.y - b.h + 5, 2, 2);
             ctx.fillStyle = '#00ffff';
        });
    });

    turrets.current.forEach(t => {
        const isHovered = hoveredTurret && hoveredTurret.id === t.id;
        ctx.strokeStyle = isHovered ? '#ffff00' : t.stats.color;
        ctx.fillStyle = '#000';
        ctx.lineWidth = 2;

        ctx.beginPath();
        if (t.type === 'ARTILLERY') {
            ctx.rect(t.x - 12, t.y - 8, 24, 16);
        } else if (t.type === 'SAM') {
            ctx.moveTo(t.x - 10, t.y); ctx.lineTo(t.x, t.y - 15); ctx.lineTo(t.x + 10, t.y);
        } else if (t.type === 'LASER') {
            ctx.arc(t.x, t.y, 8, 0, Math.PI * 2);
            ctx.moveTo(t.x, t.y-8); ctx.lineTo(t.x, t.y-18);
        } else {
            ctx.arc(t.x, t.y, 10, 0, Math.PI * 2);
        }
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = t.stats.color;
        for(let i=0; i<t.level; i++) {
            ctx.fillRect(t.x - 6 + (i*4), t.y + 12, 3, 3);
        }

        if (gameState === 'PLACEMENT' && isHovered) {
            ctx.strokeStyle = '#333';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(t.x, t.y, t.stats.range, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    });

    if (gameState === 'PLACEMENT' && selectedAction && selectedAction !== 'REPAIR') {
        const mx = mousePos.current.x;
        const my = getTerrainHeight(mx, terrain.current);
        const typeData = TURRET_TYPES[selectedAction];

        ctx.strokeStyle = typeData.color;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(mx, my - 10, 10, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1.0;

        ctx.strokeStyle = '#333';
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.arc(mx, my - 10, typeData.range, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    ctx.fillStyle = '#ffff00';
    bombers.current.forEach(b => {
        ctx.beginPath();
        ctx.moveTo(b.x + (b.vx * 15), b.y);
        ctx.lineTo(b.x - (b.vx * 10), b.y - 8);
        ctx.lineTo(b.x - (b.vx * 10), b.y + 8);
        ctx.fill();
        if (b.hp < b.maxHp) {
            ctx.fillStyle = '#f00';
            ctx.fillRect(b.x - 10, b.y - 15, 20, 2);
            ctx.fillStyle = '#0f0';
            ctx.fillRect(b.x - 10, b.y - 15, 20 * (b.hp / b.maxHp), 2);
        }
    });

    enemyMissiles.current.forEach(m => {
        const isBoss = m.type === 'BOSS';

        ctx.strokeStyle = m.color;
        ctx.lineWidth = isBoss ? 4 : 2;
        ctx.globalAlpha = 1.0;

        ctx.beginPath();
        ctx.moveTo(m.x - m.vx * (isBoss ? 10 : 6), m.y - m.vy * (isBoss ? 10 : 6));
        ctx.lineTo(m.x, m.y);
        ctx.stroke();

        ctx.fillStyle = m.color;
        if (m.type === 'ARMORED') {
             ctx.beginPath();
             ctx.moveTo(m.x, m.y - 4);
             ctx.lineTo(m.x + 4, m.y);
             ctx.lineTo(m.x, m.y + 4);
             ctx.lineTo(m.x - 4, m.y);
             ctx.fill();
        } else {
             const s = m.size || 4;
             ctx.fillRect(m.x - s/2, m.y - s/2, s, s);
        }

        if (m.hp < m.maxHp || isBoss) {
            const barW = isBoss ? 40 : 16;
            const barOff = isBoss ? 20 : 10;
            ctx.fillStyle = '#f00';
            ctx.fillRect(m.x - barW/2, m.y - barOff, barW, isBoss ? 4 : 2);
            ctx.fillStyle = '#0f0';
            ctx.fillRect(m.x - barW/2, m.y - barOff, barW * (m.hp / m.maxHp), isBoss ? 4 : 2);
        }
    });

    playerMissiles.current.forEach(m => {
        ctx.fillStyle = m.color;
        if (m.type === 'SAM') {
            ctx.beginPath();
            ctx.arc(m.x, m.y, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(m.x - m.vx*2, m.y - m.vy*2, 2, 2);
        } else {
            ctx.beginPath();
            ctx.arc(m.x, m.y, 2, 0, Math.PI * 2);
            ctx.fill();
        }
    });

    lasers.current.forEach(l => {
        const w = l.width || 2;
        ctx.strokeStyle = l.color;
        ctx.lineWidth = w + 2;
        ctx.globalAlpha = Math.min(1, l.life / 3);
        ctx.beginPath();
        ctx.moveTo(l.x1, l.y1);
        ctx.lineTo(l.x2, l.y2);
        ctx.stroke();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = Math.max(1, w - 1);
        ctx.beginPath();
        ctx.moveTo(l.x1, l.y1);
        ctx.lineTo(l.x2, l.y2);
        ctx.stroke();
        ctx.globalAlpha = 1.0;
    });

    explosions.current.forEach(ex => {
        ctx.strokeStyle = ex.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(ex.x, ex.y, ex.radius, 0, Math.PI * 2);
        ctx.stroke();
    });

    particles.current.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 2, 2);
    });
  };

  const loop = useCallback(() => {
    update();
    draw();
    requestRef.current = requestAnimationFrame(loop);
  }, [update]);

  useEffect(() => {
    requestRef.current = requestAnimationFrame(loop);
    return () => cancelAnimationFrame(requestRef.current);
  }, [loop]);


  // --- UI ---
  return (
    <div className="w-full h-full min-h-screen bg-zinc-950 flex flex-col items-center p-2 font-mono text-green-500 select-none overflow-y-auto">

      {/* HUD */}
      <div className="w-full max-w-[800px] bg-black border border-green-900 p-2 mb-2 flex justify-between items-center shadow-lg rounded">
        <div className="flex gap-4 md:gap-8">
            <div className="flex flex-col">
                <span className="text-[10px] text-green-700">FUNDS</span>
                <div className="flex items-center gap-1 text-lg font-bold text-green-400">
                    <DollarSign size={16} />{money}
                </div>
            </div>
            <div className="flex flex-col">
                <span className="text-[10px] text-green-700">SCORE</span>
                <div className="flex items-center gap-1 text-lg font-bold">
                    <Trophy size={16} />{score}
                </div>
            </div>
            <div className="flex flex-col">
                <span className="text-[10px] text-green-700">WAVE</span>
                <div className="flex items-center gap-1 text-lg font-bold">
                    <Shield size={16} />{level}
                </div>
            </div>
        </div>
        <div className="text-green-400 font-bold animate-pulse text-right text-sm">
            {message}
        </div>
      </div>

      {/* Game Viewport */}
      <div className="relative border-2 border-zinc-800 rounded shadow-2xl bg-black mb-2 overflow-hidden">
        <canvas
            ref={canvasRef}
            width={GAME_WIDTH}
            height={GAME_HEIGHT}
            onClick={handleCanvasClick}
            onMouseMove={handleMouseMove}
            className="block cursor-crosshair max-w-full h-auto"
        />

        {/* --- OVERLAYS --- */}

        {gameState === 'START' && (
            <div className="absolute inset-0 bg-black/90 flex flex-col items-center justify-center">
                <h1 className="text-4xl md:text-6xl font-black text-green-500 tracking-tighter mb-4" style={{textShadow: '0 0 15px #0f0'}}>VECTOR DEFENSE</h1>
                <p className="text-green-700 mb-8 tracking-widest text-center">SECURE THE VALLEYS</p>
                <button onClick={initGame} className="px-8 py-3 border border-green-500 text-green-500 hover:bg-green-500 hover:text-black font-bold uppercase tracking-widest transition-all">
                    Initialize
                </button>
            </div>
        )}

        {/* LEVEL COMPLETE */}
        {gameState === 'LEVEL_COMPLETE' && bonusReport && (
             <div className="absolute inset-0 bg-black flex flex-col items-center justify-center font-mono">
                <h2 className="text-4xl text-green-500 font-bold mb-8 blink">WAVE {bonusReport.wave} CLEARED</h2>

                <div className="w-64 space-y-4 mb-8 text-green-400">
                    <div className="flex justify-between border-b border-green-900 pb-1">
                        <span>BASE BONUS</span>
                        <span>{bonusReport.base}</span>
                    </div>
                    <div className="flex justify-between border-b border-green-900 pb-1">
                        <span>CITIES SECURE ({bonusReport.cityCount})</span>
                        <span>{bonusReport.cityBonus}</span>
                    </div>
                    <div className="flex justify-between text-yellow-400 font-bold pt-2">
                        <span>TOTAL FUNDS</span>
                        <span>+{bonusReport.total}</span>
                    </div>
                </div>

                <button
                    onClick={advanceLevel}
                    className="px-8 py-3 bg-green-900 text-white font-bold hover:bg-green-700 animate-pulse border border-green-500"
                >
                    PROCEED TO NEXT SECTOR
                </button>
             </div>
        )}

        {/* LEVEL START */}
        {gameState === 'LEVEL_START' && (
            <div className="absolute inset-0 bg-black flex flex-col items-center justify-center">
                <h2 className="text-6xl font-black text-transparent bg-clip-text bg-gradient-to-b from-green-300 to-green-800 animate-pulse">
                    LEVEL {level}
                </h2>
                <div className="mt-4 text-green-600 tracking-[0.5em] text-sm">
                    GENERATING TERRAIN...
                </div>
            </div>
        )}

        {/* GAME OVER */}
        {gameState === 'GAME_OVER' && (
            <div className="absolute inset-0 bg-black/95 flex flex-col items-center justify-center">
                <h2 className="text-5xl text-red-500 font-bold mb-2 glitch-effect">SECTOR LOST</h2>
                <div className="text-2xl mb-8 border border-green-900 px-6 py-2 text-white">FINAL SCORE: {score}</div>
                <button onClick={initGame} className="flex items-center gap-2 px-6 py-3 border border-red-500 text-red-500 hover:bg-red-900/30 font-bold transition-all">
                    <RotateCcw size={18} /> REBOOT SYSTEM
                </button>
            </div>
        )}
      </div>

      {/* Armory */}
      <div className={`w-full max-w-[800px] transition-all duration-300 ${gameState === 'PLACEMENT' ? 'opacity-100 translate-y-0' : 'opacity-30 grayscale pointer-events-none'}`}>
          <div className="grid grid-cols-2 md:grid-cols-[1fr_auto] gap-2">

              <div className="bg-black border border-green-900 p-2 rounded flex flex-wrap gap-2 justify-center md:justify-start">

                  {Object.keys(TURRET_TYPES).map(key => {
                      const t = TURRET_TYPES[key];
                      const Icon = t.icon;
                      return (
                        <button
                            key={key}
                            onClick={() => setSelectedAction(key)}
                            className={`flex flex-col items-center justify-center w-20 h-20 border rounded transition-all ${selectedAction === key ? 'bg-green-900/40 border-green-400' : 'border-zinc-800 hover:border-zinc-600'}`}
                        >
                            <Icon size={20} style={{color: t.color}} className="mb-1" />
                            <span className="text-[10px] font-bold text-zinc-300">{t.name}</span>
                            <span className="text-[10px] text-green-600">${t.cost}</span>
                        </button>
                      );
                  })}

                  <div className="w-px bg-zinc-800 mx-1"></div>

                   <button
                        onClick={buyRepair}
                        className="flex flex-col items-center justify-center w-20 h-20 border border-zinc-800 rounded hover:border-blue-500 group transition-all"
                    >
                        <Wifi size={20} className="text-blue-500 mb-1 group-hover:animate-pulse" />
                        <span className="text-[10px] font-bold text-zinc-300">REPAIR</span>
                        <span className="text-[10px] text-blue-500">${REPAIR_COST}</span>
                    </button>
              </div>

              <button
                onClick={startWave}
                className="col-span-2 md:col-span-1 bg-green-900/20 border border-green-600 text-green-400 hover:bg-green-500 hover:text-black transition-all px-6 rounded font-bold text-lg flex items-center justify-center uppercase tracking-wider"
              >
                  <Play size={24} className="mr-2" /> ENGAGE
              </button>
          </div>
          <div className="text-center text-xs text-zinc-600 mt-2">
            Click Unit to Upgrade (cost scales per level)
          </div>
      </div>

      <style>{`
        @keyframes blink { 50% { opacity: 0; } }
        .blink { animation: blink 1s step-end infinite; }
      `}</style>
    </div>
  );
};

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
