<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bubble Bastion Defense</title>
  <style>
    :root {
      --ink: #24324a;
      --muted: #62758d;
      --panel: rgba(255, 255, 255, 0.88);
      --outline: rgba(255, 255, 255, 0.72);
      --accent: #ff9f43;
      --accent-2: #ffbf73;
      --good: #2faa68;
      --danger: #d55555;
      --shadow: 0 13px 28px rgba(72, 111, 140, 0.2);
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      width: 100%;
      min-height: 100%;
    }

    body {
      font-family: "Trebuchet MS", "Avenir Next", "Segoe UI", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(circle at 10% 12%, rgba(255, 255, 255, 0.95) 0, rgba(255, 255, 255, 0.42) 23%, transparent 41%),
        radial-gradient(circle at 84% 14%, rgba(255, 243, 214, 0.9) 0, rgba(255, 243, 214, 0.45) 24%, transparent 42%),
        linear-gradient(180deg, #b8e8ff 0%, #d7f4ff 46%, #ecffe3 100%);
      padding: 12px;
    }

    .app {
      width: min(1440px, 100%);
      margin: 0 auto;
      min-height: calc(100vh - 24px);
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 12px;
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--outline);
      border-radius: 18px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(4px);
    }

    .hud {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 10px 14px;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 240px;
    }

    .logo-dot {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #fff2a4 0, #ffbf47 48%, #f38635 100%);
      box-shadow: 0 0 0 4px rgba(255, 189, 100, 0.3);
      flex: 0 0 auto;
    }

    .brand h1 {
      margin: 0;
      font-size: 1.16rem;
      line-height: 1.2;
      letter-spacing: 0.02em;
    }

    .brand p {
      margin: 2px 0 0;
      color: var(--muted);
      font-size: 0.85rem;
    }

    .stats {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: center;
    }

    .pill {
      border-radius: 999px;
      padding: 7px 12px;
      border: 1px solid #ffffff;
      background: linear-gradient(180deg, #ffffff, #f3fbff);
      font-size: 0.92rem;
      font-weight: 700;
      letter-spacing: 0.01em;
      box-shadow: inset 0 1px 0 #ffffff;
      white-space: nowrap;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: flex-end;
    }

    button {
      border: none;
      border-radius: 11px;
      padding: 8px 12px;
      font: inherit;
      font-weight: 700;
      color: #1f2b3f;
      background: linear-gradient(180deg, #fff5e6 0%, #ffd8a9 100%);
      cursor: pointer;
      box-shadow: 0 4px 0 rgba(166, 111, 33, 0.3);
      transition: transform 0.08s ease, filter 0.15s ease, opacity 0.2s ease;
      min-height: 36px;
    }

    button:hover:not(:disabled) {
      filter: brightness(1.03);
      transform: translateY(-1px);
    }

    button:active:not(:disabled) {
      transform: translateY(1px);
      box-shadow: 0 2px 0 rgba(166, 111, 33, 0.3);
    }

    button:disabled {
      opacity: 0.52;
      cursor: not-allowed;
      box-shadow: none;
    }

    .layout {
      display: grid;
      grid-template-columns: 280px 1fr 290px;
      gap: 12px;
      min-height: 0;
      align-items: stretch;
    }

    .panel {
      padding: 12px;
      display: flex;
      flex-direction: column;
      min-height: 0;
      gap: 10px;
    }

    .panel h2 {
      margin: 0;
      font-size: 1.03rem;
      letter-spacing: 0.01em;
    }

    .panel .subtle {
      margin: 0;
      color: var(--muted);
      font-size: 0.88rem;
    }

    .tower-shop {
      display: grid;
      gap: 9px;
      overflow-y: auto;
      padding-right: 2px;
    }

    .tower-card {
      border: 1px solid #d7e8f8;
      background: linear-gradient(180deg, #ffffff, #eff8ff);
      border-radius: 12px;
      padding: 9px;
      cursor: pointer;
      transition: transform 0.1s ease, border-color 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
      box-shadow: inset 0 1px 0 #ffffff;
    }

    .tower-card:hover {
      transform: translateY(-1px);
      border-color: #bed8ee;
    }

    .tower-card.selected {
      border-color: #f3ae4f;
      box-shadow: 0 0 0 2px rgba(255, 172, 61, 0.32), inset 0 1px 0 #ffffff;
      transform: translateY(-1px);
    }

    .tower-card.locked {
      opacity: 0.56;
    }

    .tower-card-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-weight: 700;
      font-size: 0.9rem;
    }

    .tower-swatch {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 6px;
      border: 1px solid rgba(0, 0, 0, 0.1);
      vertical-align: middle;
    }

    .tower-meta {
      margin-top: 5px;
      display: flex;
      justify-content: space-between;
      gap: 10px;
      color: var(--muted);
      font-size: 0.8rem;
    }

    .field-panel {
      padding: 10px;
      display: flex;
      align-items: stretch;
      justify-content: stretch;
    }

    #canvasWrap {
      width: 100%;
      aspect-ratio: 16 / 9;
      border-radius: 14px;
      overflow: hidden;
      position: relative;
      border: 2px solid #9dcef0;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.8);
      background: #c0edff;
    }

    #gameCanvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
      user-select: none;
      cursor: crosshair;
    }

    #centerBanner {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.95);
      color: #2a3c57;
      font-weight: 700;
      font-size: 0.83rem;
      letter-spacing: 0.01em;
      padding: 6px 11px;
      box-shadow: 0 6px 14px rgba(52, 98, 130, 0.16);
      pointer-events: none;
      text-align: center;
      max-width: calc(100% - 20px);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .selection-info {
      min-height: 120px;
      border: 1px solid #d9e8f4;
      border-radius: 12px;
      background: linear-gradient(180deg, #ffffff, #f3f9ff);
      padding: 10px;
      font-size: 0.88rem;
      color: #2c3b56;
      line-height: 1.34;
    }

    .selection-info .muted {
      color: var(--muted);
    }

    .selection-info strong {
      display: inline-block;
      margin-bottom: 4px;
    }

    .info-panel button {
      width: 100%;
    }

    .next-wave {
      margin-top: auto;
      border-top: 1px dashed #c9ddee;
      padding-top: 9px;
    }

    .next-wave h3 {
      margin: 0 0 6px;
      font-size: 0.95rem;
    }

    .next-wave p {
      margin: 0;
      font-size: 0.86rem;
      color: #324766;
      line-height: 1.36;
    }

    .log-panel {
      padding: 10px 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 108px;
    }

    .log-panel h2 {
      margin: 0;
      font-size: 1rem;
    }

    #eventLog {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 4px;
      color: #314864;
      font-size: 0.86rem;
      line-height: 1.3;
    }

    #eventLog li {
      padding: 3px 6px;
      border-radius: 7px;
      background: rgba(239, 248, 255, 0.8);
      border: 1px solid rgba(214, 233, 248, 0.72);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .good {
      color: var(--good);
    }

    .danger {
      color: var(--danger);
    }

    @media (max-width: 1220px) {
      .layout {
        grid-template-columns: 260px 1fr;
      }

      .info-panel {
        grid-column: 1 / -1;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        align-items: start;
      }

      .info-panel > h2 {
        grid-column: 1 / -1;
      }

      .info-panel > .selection-info {
        grid-column: 1 / -1;
      }

      .next-wave {
        grid-column: 1 / -1;
      }
    }

    @media (max-width: 900px) {
      body {
        padding: 8px;
      }

      .app {
        min-height: calc(100vh - 16px);
      }

      .layout {
        grid-template-columns: 1fr;
      }

      .shop-panel,
      .info-panel {
        order: 2;
      }

      .field-panel {
        order: 1;
      }

      .panel {
        max-height: none;
      }

      .tower-shop {
        grid-template-columns: repeat(auto-fill, minmax(145px, 1fr));
      }

      #centerBanner {
        white-space: normal;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="card hud">
      <div class="brand">
        <div class="logo-dot"></div>
        <div>
          <h1>Bubble Bastion Defense</h1>
          <p>Random map each run. Build smart between waves.</p>
        </div>
      </div>

      <div class="stats">
        <div class="pill" id="coinDisplay">Coins: 0</div>
        <div class="pill" id="lifeDisplay">Lives: 0</div>
        <div class="pill" id="waveDisplay">Wave: 0/0</div>
        <div class="pill" id="phaseDisplay">Build Phase</div>
      </div>

      <div class="controls">
        <button id="startWaveBtn">Start Wave</button>
        <button id="speedBtn">Speed x1</button>
        <button id="restartBtn">Restart Run</button>
        <button id="newTrackBtn">New Track</button>
      </div>
    </header>

    <main class="layout">
      <aside class="card panel shop-panel">
        <h2>Towers</h2>
        <p class="subtle">Pick a tower, then click the map to place it.</p>
        <div id="towerShop" class="tower-shop"></div>
      </aside>

      <section class="card field-panel">
        <div id="canvasWrap">
          <canvas id="gameCanvas"></canvas>
          <div id="centerBanner">Build your first defenses and press Start Wave.</div>
        </div>
      </section>

      <aside class="card panel info-panel">
        <h2>Command</h2>
        <div id="selectionInfo" class="selection-info"></div>
        <button id="upgradeBtn" disabled>Upgrade</button>
        <button id="sellBtn" disabled>Sell</button>
        <div class="next-wave">
          <h3>Next Wave</h3>
          <p id="nextWaveInfo"></p>
        </div>
      </aside>
    </main>

    <section class="card log-panel">
      <h2>Field Log</h2>
      <ul id="eventLog"></ul>
    </section>
  </div>

  <script>
    (() => {
      'use strict';

      const WORLD_WIDTH = 960;
      const WORLD_HEIGHT = 540;
      const PATH_WIDTH = 58;
      const MAX_WAVES = 24;
      const INITIAL_COINS = 260;
      const INITIAL_LIVES = 20;

      const TOWER_DEFS = {
        sprout: {
          key: 'sprout',
          name: 'Sprout Shooter',
          cost: 80,
          color: '#6ecf74',
          accent: '#3c9e50',
          description: 'Rapid pea fire for nearby lanes.',
          behavior: 'single',
          upgradeCosts: [65, 90, 125, 165],
          stats: [
            { range: 122, damage: 8, rate: 3.8 },
            { range: 132, damage: 11, rate: 4.2 },
            { range: 142, damage: 15, rate: 4.7 },
            { range: 152, damage: 19, rate: 5.2 },
            { range: 166, damage: 24, rate: 5.8 }
          ]
        },
        puff: {
          key: 'puff',
          name: 'Puff Mortar',
          cost: 115,
          color: '#ffb062',
          accent: '#db7f37',
          description: 'Pops clusters with splash blasts.',
          behavior: 'splash',
          upgradeCosts: [85, 115, 150, 200],
          stats: [
            { range: 138, damage: 15, rate: 1.05, splash: 52 },
            { range: 148, damage: 20, rate: 1.2, splash: 58 },
            { range: 160, damage: 27, rate: 1.35, splash: 66 },
            { range: 172, damage: 35, rate: 1.5, splash: 74 },
            { range: 186, damage: 44, rate: 1.66, splash: 82 }
          ]
        },
        spark: {
          key: 'spark',
          name: 'Spark Wheel',
          cost: 130,
          color: '#66d5ff',
          accent: '#3e95c7',
          description: 'Lightning chains through nearby mobs.',
          behavior: 'chain',
          upgradeCosts: [95, 130, 170, 225],
          stats: [
            { range: 132, damage: 14, rate: 1.7, chains: 2, chainRange: 78 },
            { range: 142, damage: 18, rate: 1.9, chains: 3, chainRange: 86 },
            { range: 154, damage: 23, rate: 2.1, chains: 3, chainRange: 94 },
            { range: 168, damage: 29, rate: 2.3, chains: 4, chainRange: 102 },
            { range: 182, damage: 36, rate: 2.5, chains: 5, chainRange: 110 }
          ]
        },
        chill: {
          key: 'chill',
          name: 'Chill Teapot',
          cost: 95,
          color: '#89baf9',
          accent: '#537fc0',
          description: 'Slows enemies with frosty tea spray.',
          behavior: 'slow',
          upgradeCosts: [70, 100, 135, 175],
          stats: [
            { range: 130, damage: 10, rate: 1.7, slow: 0.24, slowDuration: 1.4 },
            { range: 142, damage: 13, rate: 1.9, slow: 0.31, slowDuration: 1.6 },
            { range: 154, damage: 17, rate: 2.1, slow: 0.38, slowDuration: 1.9 },
            { range: 168, damage: 21, rate: 2.3, slow: 0.45, slowDuration: 2.2 },
            { range: 182, damage: 27, rate: 2.5, slow: 0.52, slowDuration: 2.5 }
          ]
        },
        luma: {
          key: 'luma',
          name: 'Luma Cannon',
          cost: 165,
          color: '#ffe07b',
          accent: '#c79f37',
          description: 'Long-range stars with critical hits.',
          behavior: 'sniper',
          upgradeCosts: [120, 160, 210, 280],
          stats: [
            { range: 235, damage: 38, rate: 0.75, crit: 0.18 },
            { range: 250, damage: 50, rate: 0.84, crit: 0.22 },
            { range: 265, damage: 66, rate: 0.93, crit: 0.26 },
            { range: 282, damage: 84, rate: 1.02, crit: 0.3 },
            { range: 300, damage: 108, rate: 1.12, crit: 0.35 }
          ]
        }
      };

      const ENEMY_DEFS = {
        munch: {
          key: 'munch',
          name: 'Munchling',
          hp: 46,
          speed: 62,
          reward: 8,
          radius: 11,
          color: '#ffafbf',
          outline: '#d77f90',
          armor: 0,
          leak: 1
        },
        zip: {
          key: 'zip',
          name: 'Zippy',
          hp: 34,
          speed: 102,
          reward: 9,
          radius: 9,
          color: '#ffd58d',
          outline: '#cf9f53',
          armor: 0,
          leak: 1
        },
        chunk: {
          key: 'chunk',
          name: 'Chunkster',
          hp: 126,
          speed: 44,
          reward: 15,
          radius: 14,
          color: '#d7b3ff',
          outline: '#a07ac8',
          armor: 0.06,
          leak: 1
        },
        shell: {
          key: 'shell',
          name: 'Shellback',
          hp: 185,
          speed: 45,
          reward: 19,
          radius: 15,
          color: '#c8d98f',
          outline: '#8fa35a',
          armor: 0.22,
          leak: 1
        },
        wisp: {
          key: 'wisp',
          name: 'Wisp',
          hp: 96,
          speed: 118,
          reward: 18,
          radius: 9,
          color: '#b6ecff',
          outline: '#71abc0',
          armor: 0.05,
          leak: 1
        },
        brute: {
          key: 'brute',
          name: 'Brute Ball',
          hp: 320,
          speed: 37,
          reward: 30,
          radius: 17,
          color: '#f2b26a',
          outline: '#c9863d',
          armor: 0.14,
          leak: 1
        },
        boss: {
          key: 'boss',
          name: 'Royal Guzzler',
          hp: 950,
          speed: 30,
          reward: 90,
          radius: 22,
          color: '#f07e95',
          outline: '#bc4a62',
          armor: 0.2,
          leak: 3
        }
      };

      const ENEMY_THREAT = {
        munch: 6,
        zip: 7,
        chunk: 13,
        shell: 16,
        wisp: 15,
        brute: 24,
        boss: 95
      };

      const state = {
        coins: INITIAL_COINS,
        lives: INITIAL_LIVES,
        wave: 0,
        phase: 'build',
        buildCountdown: null,
        gameSpeed: 1,
        status: 'running',
        selectedShop: null,
        selectedTowerId: null,
        towers: [],
        enemies: [],
        effects: [],
        waves: [],
        spawnQueue: [],
        spawnTimer: 0,
        path: null,
        decor: null,
        hover: null,
        log: [],
        ids: { tower: 1, enemy: 1 },
        time: 0
      };

      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');

      const els = {
        coin: document.getElementById('coinDisplay'),
        life: document.getElementById('lifeDisplay'),
        wave: document.getElementById('waveDisplay'),
        phase: document.getElementById('phaseDisplay'),
        startWave: document.getElementById('startWaveBtn'),
        speed: document.getElementById('speedBtn'),
        restart: document.getElementById('restartBtn'),
        newTrack: document.getElementById('newTrackBtn'),
        towerShop: document.getElementById('towerShop'),
        selectionInfo: document.getElementById('selectionInfo'),
        upgrade: document.getElementById('upgradeBtn'),
        sell: document.getElementById('sellBtn'),
        nextWaveInfo: document.getElementById('nextWaveInfo'),
        eventLog: document.getElementById('eventLog'),
        centerBanner: document.getElementById('centerBanner')
      };

      let lastFrame = performance.now();

      init();

      function init() {
        buildTowerShop();
        bindEvents();
        resetRun(true);
        resizeCanvas();
        requestAnimationFrame(loop);
      }

      function buildTowerShop() {
        const frag = document.createDocumentFragment();
        Object.values(TOWER_DEFS).forEach((tower) => {
          const card = document.createElement('button');
          card.type = 'button';
          card.className = 'tower-card';
          card.dataset.type = tower.key;

          const top = document.createElement('div');
          top.className = 'tower-card-top';
          top.innerHTML =
            '<span><span class="tower-swatch" style="background:' + tower.color + '"></span>' +
            tower.name + '</span><span>$' + tower.cost + '</span>';

          const meta = document.createElement('div');
          meta.className = 'tower-meta';
          meta.innerHTML = '<span>' + tower.description + '</span><span>L1</span>';

          card.appendChild(top);
          card.appendChild(meta);
          card.addEventListener('click', () => {
            if (state.selectedShop === tower.key) {
              state.selectedShop = null;
            } else {
              state.selectedShop = tower.key;
              state.selectedTowerId = null;
            }
            syncUI();
          });

          frag.appendChild(card);
        });

        els.towerShop.textContent = '';
        els.towerShop.appendChild(frag);
      }

      function bindEvents() {
        els.startWave.addEventListener('click', () => startWave(false));

        els.speed.addEventListener('click', () => {
          state.gameSpeed = state.gameSpeed === 1 ? 2 : 1;
          syncUI();
        });

        els.restart.addEventListener('click', () => resetRun(false));
        els.newTrack.addEventListener('click', () => resetRun(true));

        els.upgrade.addEventListener('click', upgradeSelectedTower);
        els.sell.addEventListener('click', sellSelectedTower);

        canvas.addEventListener('pointermove', (event) => {
          state.hover = screenToWorld(event.clientX, event.clientY);
        });

        canvas.addEventListener('pointerleave', () => {
          state.hover = null;
        });

        canvas.addEventListener('click', (event) => {
          const point = screenToWorld(event.clientX, event.clientY);
          onCanvasClick(point.x, point.y);
        });

        window.addEventListener('resize', resizeCanvas);
      }

      function resetRun(newTrack) {
        state.coins = INITIAL_COINS;
        state.lives = INITIAL_LIVES;
        state.wave = 0;
        state.phase = 'build';
        state.buildCountdown = null;
        state.status = 'running';
        state.selectedTowerId = null;
        state.towers = [];
        state.enemies = [];
        state.effects = [];
        state.spawnQueue = [];
        state.spawnTimer = 0;
        state.ids.tower = 1;
        state.ids.enemy = 1;
        state.time = 0;

        if (newTrack || !state.path) {
          state.path = generateRandomPath();
          state.decor = generateDecor();
        }

        state.waves = buildWaves();
        state.selectedShop = Object.keys(TOWER_DEFS)[0];

        state.log = [];
        pushLog(newTrack ? 'Fresh track generated. New run ready.' : 'Run restarted on current track.');
        pushLog('Build defenses, then launch wave 1.');
        syncUI();
      }

      function buildWaves() {
        const waves = [];
        for (let wave = 1; wave <= MAX_WAVES; wave += 1) {
          waves.push(generateWave(wave));
        }
        return waves;
      }

      function generateWave(wave) {
        const spawns = [];
        const unlocked = ['munch', 'zip'];
        if (wave >= 3) {
          unlocked.push('chunk');
        }
        if (wave >= 6) {
          unlocked.push('shell');
        }
        if (wave >= 9) {
          unlocked.push('wisp');
        }
        if (wave >= 12) {
          unlocked.push('brute');
        }

        let budget = 62 + wave * 18;
        if (wave % 4 === 0) {
          budget += 36;
        }
        if (wave % 5 === 0) {
          budget -= 24;
        }

        const baseDelay = clamp(0.8 - wave * 0.018, 0.2, 0.82);

        while (budget > 0 && spawns.length < 220) {
          const candidates = unlocked.filter((key) => ENEMY_THREAT[key] <= budget + 8);
          if (!candidates.length) {
            break;
          }

          const chosen = weightedEnemyPick(candidates, wave);
          spawns.push({
            type: chosen,
            delay: clamp(baseDelay + rand(-0.12, 0.16), 0.16, 1.2)
          });
          budget -= ENEMY_THREAT[chosen];
        }

        if (wave % 3 === 0) {
          const rushCount = 4 + Math.floor(wave / 3);
          for (let i = 0; i < rushCount; i += 1) {
            spawns.push({
              type: wave >= 10 && i % 2 === 1 ? 'wisp' : 'zip',
              delay: 0.18
            });
          }
        }

        if (wave % 5 === 0) {
          spawns.push({ type: 'boss', delay: 1.45 });
          const escorts = Math.max(2, Math.floor(wave / 5));
          for (let i = 0; i < escorts; i += 1) {
            spawns.push({
              type: wave >= 15 && i % 2 === 0 ? 'brute' : 'shell',
              delay: 0.35
            });
          }
        }

        if (wave >= 18) {
          const tail = Math.floor(wave / 3);
          for (let i = 0; i < tail; i += 1) {
            spawns.push({
              type: i % 3 === 0 ? 'brute' : 'wisp',
              delay: 0.26
            });
          }
        }

        return {
          spawns,
          summary: summarizeSpawns(spawns)
        };
      }

      function weightedEnemyPick(pool, wave) {
        const weightMap = {
          munch: Math.max(1.2, 9 - wave * 0.25),
          zip: Math.max(1.2, 6.8 - wave * 0.08),
          chunk: Math.max(1, 1.5 + wave * 0.09),
          shell: Math.max(1, 0.8 + wave * 0.1),
          wisp: Math.max(1, 0.7 + wave * 0.12),
          brute: Math.max(0.65, 0.4 + wave * 0.1)
        };

        let total = 0;
        for (const key of pool) {
          total += weightMap[key] || 1;
        }

        let roll = Math.random() * total;
        for (const key of pool) {
          roll -= weightMap[key] || 1;
          if (roll <= 0) {
            return key;
          }
        }

        return pool[pool.length - 1];
      }

      function summarizeSpawns(spawns) {
        const summary = {};
        for (const spawn of spawns) {
          summary[spawn.type] = (summary[spawn.type] || 0) + 1;
        }
        return summary;
      }

      function formatWaveSummary(index) {
        if (index >= MAX_WAVES) {
          return 'All waves complete.';
        }

        const wave = state.waves[index];
        if (!wave) {
          return 'Preparing...';
        }

        const entries = Object.entries(wave.summary)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 6)
          .map(([key, count]) => count + ' ' + ENEMY_DEFS[key].name);

        return entries.join(' | ');
      }

      function startWave(isAuto) {
        if (state.status !== 'running' || state.phase !== 'build') {
          return;
        }

        if (state.wave >= MAX_WAVES) {
          return;
        }

        state.phase = 'wave';
        state.buildCountdown = null;
        state.wave += 1;

        const waveDef = state.waves[state.wave - 1];
        state.spawnQueue = waveDef.spawns.map((spawn) => ({ ...spawn }));
        state.spawnTimer = 0.35;

        if (isAuto) {
          pushLog('Auto-launched wave ' + state.wave + '.');
        } else {
          pushLog('Wave ' + state.wave + ' deployed.');
        }

        syncUI();
      }

      function completeWave() {
        if (state.wave >= MAX_WAVES) {
          state.status = 'victory';
          pushLog('All waves cleared. Victory!');
          syncUI();
          return;
        }

        state.phase = 'build';
        state.buildCountdown = 16;
        pushLog('Wave ' + state.wave + ' cleared. Build phase active.');
        syncUI();
      }

      function onCanvasClick(x, y) {
        if (state.status !== 'running') {
          return;
        }

        const clickedTower = getTowerAt(x, y);
        if (clickedTower) {
          state.selectedTowerId = clickedTower.id;
          state.selectedShop = null;
          syncUI();
          return;
        }

        state.selectedTowerId = null;

        if (state.phase !== 'build' || !state.selectedShop) {
          syncUI();
          return;
        }

        const def = TOWER_DEFS[state.selectedShop];
        if (state.coins < def.cost) {
          pushLog('Not enough coins for ' + def.name + '.');
          syncUI();
          return;
        }

        if (!canPlaceTower(x, y)) {
          pushLog('Cannot build there. Keep clear of road and towers.');
          syncUI();
          return;
        }

        state.coins -= def.cost;
        const tower = {
          id: state.ids.tower++,
          type: state.selectedShop,
          x,
          y,
          level: 0,
          cooldown: rand(0.02, 0.18),
          rotation: 0
        };
        state.towers.push(tower);
        state.selectedTowerId = tower.id;
        pushLog(def.name + ' built.');
        syncUI();
      }

      function getSelectedTower() {
        return state.towers.find((tower) => tower.id === state.selectedTowerId) || null;
      }

      function upgradeSelectedTower() {
        if (state.status !== 'running' || state.phase !== 'build') {
          return;
        }

        const tower = getSelectedTower();
        if (!tower) {
          return;
        }

        const def = TOWER_DEFS[tower.type];
        if (tower.level >= 4) {
          return;
        }

        const cost = def.upgradeCosts[tower.level];
        if (state.coins < cost) {
          pushLog('Need more coins to upgrade ' + def.name + '.');
          syncUI();
          return;
        }

        state.coins -= cost;
        tower.level += 1;
        pushLog(def.name + ' upgraded to L' + (tower.level + 1) + '.');
        syncUI();
      }

      function sellSelectedTower() {
        if (state.status !== 'running' || state.phase !== 'build') {
          return;
        }

        const tower = getSelectedTower();
        if (!tower) {
          return;
        }

        const value = Math.round(calculateTowerInvestment(tower) * 0.7);
        state.coins += value;
        state.towers = state.towers.filter((entry) => entry.id !== tower.id);
        state.selectedTowerId = null;
        pushLog('Tower sold for $' + value + '.');
        syncUI();
      }

      function calculateTowerInvestment(tower) {
        const def = TOWER_DEFS[tower.type];
        let total = def.cost;
        for (let i = 0; i < tower.level; i += 1) {
          total += def.upgradeCosts[i];
        }
        return total;
      }

      function canPlaceTower(x, y) {
        if (x < 22 || x > WORLD_WIDTH - 22 || y < 22 || y > WORLD_HEIGHT - 22) {
          return false;
        }

        for (const tower of state.towers) {
          if (distanceSquared(x, y, tower.x, tower.y) < 42 * 42) {
            return false;
          }
        }

        const minPathDistance = PATH_WIDTH * 0.55 + 12;
        for (const segment of state.path.segments) {
          const d = distancePointToSegment(x, y, segment.a.x, segment.a.y, segment.b.x, segment.b.y);
          if (d < minPathDistance) {
            return false;
          }
        }

        return true;
      }

      function getTowerAt(x, y) {
        for (let i = state.towers.length - 1; i >= 0; i -= 1) {
          const tower = state.towers[i];
          if (distanceSquared(x, y, tower.x, tower.y) <= 18 * 18) {
            return tower;
          }
        }
        return null;
      }

      function spawnEnemy(typeKey) {
        const def = ENEMY_DEFS[typeKey];
        const start = pointOnPath(0);
        state.enemies.push({
          id: state.ids.enemy++,
          type: typeKey,
          name: def.name,
          hp: def.hp,
          maxHp: def.hp,
          speed: def.speed,
          reward: def.reward,
          radius: def.radius,
          color: def.color,
          outline: def.outline,
          armor: def.armor,
          leak: def.leak,
          progress: 0,
          x: start.x,
          y: start.y,
          dead: false,
          slowPct: 0,
          slowTimer: 0,
          wobble: Math.random() * Math.PI * 2
        });
      }

      function update(delta) {
        state.time += delta;

        if (state.status === 'running') {
          const gameDelta = delta * state.gameSpeed;

          if (state.phase === 'wave') {
            updateSpawns(gameDelta);
          }

          updateEnemies(gameDelta);
          updateTowers(gameDelta);

          if (state.phase === 'build' && state.buildCountdown !== null) {
            state.buildCountdown -= delta;
            if (state.buildCountdown <= 0) {
              startWave(true);
            }
          }

          if (state.phase === 'wave' && state.spawnQueue.length === 0 && state.enemies.length === 0) {
            completeWave();
          }
        }

        updateEffects(delta);
        syncHUDOnly();
      }

      function updateSpawns(delta) {
        state.spawnTimer -= delta;

        while (state.spawnQueue.length > 0 && state.spawnTimer <= 0) {
          const next = state.spawnQueue.shift();
          spawnEnemy(next.type);
          state.spawnTimer += next.delay;
        }
      }

      function updateEnemies(delta) {
        for (const enemy of state.enemies) {
          if (enemy.dead) {
            continue;
          }

          if (enemy.slowTimer > 0) {
            enemy.slowTimer -= delta;
            if (enemy.slowTimer <= 0) {
              enemy.slowTimer = 0;
              enemy.slowPct = 0;
            }
          }

          const speedFactor = 1 - enemy.slowPct;
          enemy.progress += enemy.speed * speedFactor * delta;

          const pos = pointOnPath(enemy.progress);
          enemy.x = pos.x;
          enemy.y = pos.y;

          if (enemy.progress >= state.path.length) {
            enemy.dead = true;
            state.lives -= enemy.leak;
            addBurst(enemy.x, enemy.y, enemy.radius + 6, '#ffe38a', 0.34);
            if (enemy.leak > 1) {
              pushLog(enemy.name + ' leaked through for ' + enemy.leak + ' damage.');
            }

            if (state.lives <= 0) {
              state.lives = 0;
              state.status = 'defeat';
              state.phase = 'build';
              state.spawnQueue = [];
              pushLog('The village was overrun.');
            }
          }
        }

        state.enemies = state.enemies.filter((enemy) => !enemy.dead);
      }

      function updateTowers(delta) {
        if (state.enemies.length === 0) {
          for (const tower of state.towers) {
            tower.cooldown = Math.max(0, tower.cooldown - delta);
          }
          return;
        }

        for (const tower of state.towers) {
          const def = TOWER_DEFS[tower.type];
          const stats = def.stats[tower.level];
          const target = pickTarget(tower, stats.range);
          tower.cooldown -= delta;

          if (!target) {
            continue;
          }

          tower.rotation = Math.atan2(target.y - tower.y, target.x - tower.x);

          if (tower.cooldown > 0) {
            continue;
          }

          executeTowerAttack(tower, def, stats, target);
          tower.cooldown += 1 / stats.rate;
        }

        state.enemies = state.enemies.filter((enemy) => !enemy.dead);
      }

      function pickTarget(tower, range) {
        let best = null;
        let bestProgress = -Infinity;
        const rangeSq = range * range;

        for (const enemy of state.enemies) {
          if (enemy.dead) {
            continue;
          }
          if (distanceSquared(tower.x, tower.y, enemy.x, enemy.y) > rangeSq) {
            continue;
          }
          if (enemy.progress > bestProgress) {
            bestProgress = enemy.progress;
            best = enemy;
          }
        }

        return best;
      }

      function executeTowerAttack(tower, def, stats, primaryTarget) {
        switch (def.behavior) {
          case 'single':
            addBeam(tower.x, tower.y, primaryTarget.x, primaryTarget.y, '#78e07a', 2.1, 0.1);
            addBurst(primaryTarget.x, primaryTarget.y, 15, '#8be38f', 0.22);
            damageEnemy(primaryTarget, stats.damage);
            break;

          case 'splash': {
            addBeam(tower.x, tower.y, primaryTarget.x, primaryTarget.y, '#ffbd76', 3.2, 0.12);
            addBurst(primaryTarget.x, primaryTarget.y, stats.splash, '#ffc17f', 0.28);
            for (const enemy of state.enemies) {
              if (enemy.dead) {
                continue;
              }
              const d = Math.hypot(enemy.x - primaryTarget.x, enemy.y - primaryTarget.y);
              if (d <= stats.splash) {
                const falloff = 1 - d / stats.splash;
                const amount = stats.damage * (0.55 + falloff * 0.45);
                damageEnemy(enemy, amount);
              }
            }
            break;
          }

          case 'chain': {
            let jumpsLeft = stats.chains;
            let current = primaryTarget;
            let damage = stats.damage;
            let fromX = tower.x;
            let fromY = tower.y;
            const hit = new Set();

            while (current && jumpsLeft > 0) {
              addBeam(fromX, fromY, current.x, current.y, '#74e4ff', 2.5, 0.1);
              addBurst(current.x, current.y, 12, '#99ecff', 0.18);
              damageEnemy(current, damage);
              hit.add(current.id);

              fromX = current.x;
              fromY = current.y;
              damage *= 0.82;
              jumpsLeft -= 1;
              current = findChainTarget(fromX, fromY, stats.chainRange, hit);
            }
            break;
          }

          case 'slow':
            addBeam(tower.x, tower.y, primaryTarget.x, primaryTarget.y, '#a4c8ff', 2.4, 0.12);
            addBurst(primaryTarget.x, primaryTarget.y, 20, '#b8d7ff', 0.24);
            damageEnemy(primaryTarget, stats.damage);
            primaryTarget.slowPct = Math.max(primaryTarget.slowPct, stats.slow);
            primaryTarget.slowTimer = Math.max(primaryTarget.slowTimer, stats.slowDuration);
            break;

          case 'sniper': {
            const crit = Math.random() < stats.crit;
            const amount = crit ? stats.damage * 1.85 : stats.damage;
            addBeam(tower.x, tower.y, primaryTarget.x, primaryTarget.y, crit ? '#ffe36f' : '#fff0b2', crit ? 3.6 : 2.6, 0.11);
            addBurst(primaryTarget.x, primaryTarget.y, crit ? 28 : 16, crit ? '#ffec95' : '#fff4c9', 0.22);
            damageEnemy(primaryTarget, amount);
            break;
          }

          default:
            break;
        }
      }

      function findChainTarget(x, y, range, ignoreSet) {
        let best = null;
        let bestDistance = Infinity;
        const rangeSq = range * range;

        for (const enemy of state.enemies) {
          if (enemy.dead || ignoreSet.has(enemy.id)) {
            continue;
          }
          const dSq = distanceSquared(x, y, enemy.x, enemy.y);
          if (dSq > rangeSq) {
            continue;
          }
          if (dSq < bestDistance) {
            bestDistance = dSq;
            best = enemy;
          }
        }

        return best;
      }

      function damageEnemy(enemy, rawDamage) {
        if (enemy.dead) {
          return 0;
        }

        const actual = rawDamage * (1 - enemy.armor);
        enemy.hp -= actual;

        if (enemy.hp <= 0) {
          enemy.dead = true;
          state.coins += enemy.reward;
          addBurst(enemy.x, enemy.y, enemy.radius + 9, enemy.color, 0.26);
          if (enemy.type === 'boss') {
            pushLog('Boss defeated!');
          }
        }

        return actual;
      }

      function addBeam(x1, y1, x2, y2, color, width, life) {
        state.effects.push({
          kind: 'beam',
          x1,
          y1,
          x2,
          y2,
          color,
          width,
          life,
          maxLife: life
        });
      }

      function addBurst(x, y, radius, color, life) {
        state.effects.push({
          kind: 'burst',
          x,
          y,
          radius,
          color,
          life,
          maxLife: life
        });
      }

      function updateEffects(delta) {
        for (const effect of state.effects) {
          effect.life -= delta;
        }
        state.effects = state.effects.filter((effect) => effect.life > 0);
      }

      function loop(timestamp) {
        const delta = Math.min(0.05, (timestamp - lastFrame) / 1000);
        lastFrame = timestamp;

        update(delta);
        draw();

        requestAnimationFrame(loop);
      }

      function draw() {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.setTransform(canvas.width / WORLD_WIDTH, 0, 0, canvas.height / WORLD_HEIGHT, 0, 0);

        drawBackdrop();
        drawTrack();
        drawPlacementPreview();
        drawTowers();
        drawEnemies();
        drawEffects();

        if (state.status !== 'running') {
          drawEndOverlay();
        }
      }

      function drawBackdrop() {
        const gradient = ctx.createLinearGradient(0, 0, 0, WORLD_HEIGHT);
        gradient.addColorStop(0, '#c4eeff');
        gradient.addColorStop(1, '#daffd5');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

        ctx.fillStyle = '#fff3b0';
        ctx.beginPath();
        ctx.arc(100, 78, 36, 0, Math.PI * 2);
        ctx.fill();

        if (state.decor) {
          for (const hill of state.decor.hills) {
            ctx.fillStyle = hill.color;
            ctx.beginPath();
            ctx.moveTo(hill.x - hill.width, WORLD_HEIGHT);
            ctx.quadraticCurveTo(hill.x, hill.y, hill.x + hill.width, WORLD_HEIGHT);
            ctx.closePath();
            ctx.fill();
          }

          for (const cloud of state.decor.clouds) {
            const drift = (state.time * cloud.speed) % (WORLD_WIDTH + 140);
            const cx = (cloud.x + drift) % (WORLD_WIDTH + 140) - 70;
            drawCloud(cx, cloud.y, cloud.scale);
          }
        }
      }

      function drawCloud(x, y, scale) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
        ctx.beginPath();
        ctx.arc(-18, 0, 16, 0, Math.PI * 2);
        ctx.arc(0, -6, 19, 0, Math.PI * 2);
        ctx.arc(20, -2, 14, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      function drawTrack() {
        const points = state.path.points;
        strokeSmoothPath(points, PATH_WIDTH + 16, '#a8764f', null);
        strokeSmoothPath(points, PATH_WIDTH, '#d8b580', null);
        strokeSmoothPath(points, 5.5, 'rgba(255, 240, 205, 0.8)', [14, 12]);
      }

      function strokeSmoothPath(points, width, color, dash) {
        ctx.save();
        ctx.lineWidth = width;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.strokeStyle = color;
        if (dash) {
          ctx.setLineDash(dash);
          ctx.lineDashOffset = -(state.time * 30);
        }

        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length - 1; i += 1) {
          const midX = (points[i].x + points[i + 1].x) / 2;
          const midY = (points[i].y + points[i + 1].y) / 2;
          ctx.quadraticCurveTo(points[i].x, points[i].y, midX, midY);
        }
        const last = points[points.length - 1];
        ctx.lineTo(last.x, last.y);
        ctx.stroke();

        ctx.restore();
      }

      function drawPlacementPreview() {
        if (state.status !== 'running' || state.phase !== 'build' || !state.selectedShop || !state.hover) {
          return;
        }

        const tower = TOWER_DEFS[state.selectedShop];
        const levelOne = tower.stats[0];
        const valid = canPlaceTower(state.hover.x, state.hover.y);

        ctx.save();
        ctx.beginPath();
        ctx.arc(state.hover.x, state.hover.y, levelOne.range, 0, Math.PI * 2);
        ctx.fillStyle = valid ? 'rgba(108, 208, 115, 0.16)' : 'rgba(226, 106, 106, 0.16)';
        ctx.strokeStyle = valid ? 'rgba(63, 150, 70, 0.45)' : 'rgba(190, 65, 65, 0.46)';
        ctx.lineWidth = 2;
        ctx.fill();
        ctx.stroke();

        drawTowerShape(state.hover.x, state.hover.y, tower.key, 0, 0, valid ? 0.58 : 0.35);
        ctx.restore();
      }

      function drawTowers() {
        for (const tower of state.towers) {
          drawTowerShape(tower.x, tower.y, tower.type, tower.level, tower.rotation, 1);

          if (tower.id === state.selectedTowerId) {
            const towerStats = TOWER_DEFS[tower.type].stats[tower.level];
            ctx.save();
            ctx.beginPath();
            ctx.arc(tower.x, tower.y, towerStats.range, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 185, 88, 0.1)';
            ctx.strokeStyle = 'rgba(255, 157, 58, 0.55)';
            ctx.setLineDash([8, 7]);
            ctx.lineWidth = 2;
            ctx.fill();
            ctx.stroke();
            ctx.restore();
          }
        }
      }

      function drawTowerShape(x, y, type, level, rotation, alpha) {
        const def = TOWER_DEFS[type];
        const size = 14 + level * 0.9;

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(x, y);
        ctx.rotate(rotation || 0);

        ctx.fillStyle = '#82644a';
        ctx.beginPath();
        ctx.arc(0, 0, size + 5, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = def.color;
        ctx.beginPath();
        ctx.arc(0, 0, size + 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = def.accent;
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
        ctx.lineWidth = 1.4;

        if (type === 'sprout') {
          ctx.beginPath();
          ctx.arc(0, 0, size - 1, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = '#83e286';
          ctx.beginPath();
          ctx.ellipse(4, -size + 3, 7, 4, 0.55, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = '#ffffff';
          ctx.beginPath();
          ctx.arc(3, -2, 2.2, 0, Math.PI * 2);
          ctx.arc(7, 0, 2.2, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = '#1f2e43';
          ctx.beginPath();
          ctx.arc(3.3, -1.7, 1, 0, Math.PI * 2);
          ctx.arc(7.2, 0.2, 1, 0, Math.PI * 2);
          ctx.fill();
        } else if (type === 'puff') {
          roundedRectPath(-size + 2, -size + 4, size * 1.55, size * 1.55, 5);
          ctx.fill();
          ctx.stroke();

          ctx.fillStyle = '#ffd8a9';
          ctx.fillRect(4, -4, size + 7, 8);

          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(1, -2, 2.2, 0, Math.PI * 2);
          ctx.arc(1, 2, 2.2, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = '#2a3346';
          ctx.beginPath();
          ctx.arc(1.2, -2, 1, 0, Math.PI * 2);
          ctx.arc(1.2, 2, 1, 0, Math.PI * 2);
          ctx.fill();
        } else if (type === 'spark') {
          drawStar(0, 0, size + 1, size - 4, 8, def.accent);
          ctx.fillStyle = '#b9f0ff';
          ctx.beginPath();
          ctx.arc(0, 0, 4, 0, Math.PI * 2);
          ctx.fill();
        } else if (type === 'chill') {
          roundedRectPath(-size, -size + 2, size * 1.5, size * 1.5, 7);
          ctx.fill();
          ctx.stroke();

          ctx.fillStyle = '#cfe5ff';
          ctx.fillRect(5, -2, size + 6, 4);
          ctx.beginPath();
          ctx.arc(2, -7, 3.5, 0, Math.PI * 2);
          ctx.fill();
        } else if (type === 'luma') {
          drawStar(0, 0, size + 4, size - 2, 5, def.accent);
          ctx.fillStyle = '#fff2a9';
          ctx.beginPath();
          ctx.arc(0, 0, 5.5, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillRect(6, -3, size + 10, 6);
        }

        ctx.restore();
      }

      function drawStar(cx, cy, outerRadius, innerRadius, points, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        for (let i = 0; i < points * 2; i += 1) {
          const angle = (i * Math.PI) / points - Math.PI / 2;
          const r = i % 2 === 0 ? outerRadius : innerRadius;
          const x = cx + Math.cos(angle) * r;
          const y = cy + Math.sin(angle) * r;
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.closePath();
        ctx.fill();
      }

      function roundedRectPath(x, y, width, height, radius) {
        const r = Math.min(radius, width * 0.5, height * 0.5);
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + width - r, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + r);
        ctx.lineTo(x + width, y + height - r);
        ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
        ctx.lineTo(x + r, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
      }

      function drawEnemies() {
        for (const enemy of state.enemies) {
          const bob = Math.sin(state.time * 6 + enemy.wobble) * 1.4;
          const y = enemy.y + bob;

          ctx.save();
          ctx.translate(enemy.x, y);

          ctx.fillStyle = enemy.color;
          ctx.strokeStyle = enemy.outline;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(-enemy.radius * 0.24, -enemy.radius * 0.15, enemy.radius * 0.26, 0, Math.PI * 2);
          ctx.arc(enemy.radius * 0.21, -enemy.radius * 0.08, enemy.radius * 0.24, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = '#222d40';
          ctx.beginPath();
          ctx.arc(-enemy.radius * 0.2, -enemy.radius * 0.12, Math.max(1.6, enemy.radius * 0.1), 0, Math.PI * 2);
          ctx.arc(enemy.radius * 0.24, -enemy.radius * 0.05, Math.max(1.6, enemy.radius * 0.1), 0, Math.PI * 2);
          ctx.fill();

          if (enemy.slowTimer > 0) {
            ctx.strokeStyle = 'rgba(180, 221, 255, 0.85)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, enemy.radius + 4, 0, Math.PI * 2);
            ctx.stroke();
          }

          const hpRatio = Math.max(0, enemy.hp / enemy.maxHp);
          const barWidth = enemy.radius * 2.2;
          const barY = -enemy.radius - 10;

          ctx.fillStyle = 'rgba(40, 40, 50, 0.28)';
          ctx.fillRect(-barWidth / 2, barY, barWidth, 4);
          ctx.fillStyle = '#7be07f';
          ctx.fillRect(-barWidth / 2, barY, barWidth * hpRatio, 4);

          ctx.restore();
        }
      }

      function drawEffects() {
        for (const effect of state.effects) {
          const ratio = effect.life / effect.maxLife;

          if (effect.kind === 'beam') {
            ctx.save();
            ctx.globalAlpha = ratio;
            ctx.strokeStyle = effect.color;
            ctx.lineWidth = effect.width;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(effect.x1, effect.y1);
            ctx.lineTo(effect.x2, effect.y2);
            ctx.stroke();
            ctx.restore();
          } else if (effect.kind === 'burst') {
            ctx.save();
            ctx.globalAlpha = ratio;
            ctx.strokeStyle = effect.color;
            ctx.lineWidth = 2;
            const progress = 1 - ratio;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, 6 + effect.radius * progress, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
          }
        }
      }

      function drawEndOverlay() {
        ctx.save();
        ctx.fillStyle = 'rgba(26, 40, 58, 0.5)';
        ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 52px Trebuchet MS';
        ctx.fillText(state.status === 'victory' ? 'Victory!' : 'Defeat', WORLD_WIDTH / 2, WORLD_HEIGHT / 2 - 24);

        ctx.font = 'bold 20px Trebuchet MS';
        ctx.fillText(
          state.status === 'victory'
            ? 'You protected the kingdom through all ' + MAX_WAVES + ' waves.'
            : 'Try a new setup and hold the line longer.',
          WORLD_WIDTH / 2,
          WORLD_HEIGHT / 2 + 20
        );

        ctx.restore();
      }

      function generateRandomPath() {
        let candidate = null;
        for (let attempt = 0; attempt < 35; attempt += 1) {
          const points = [];
          const margin = 70;
          const innerPoints = 7;
          let y = rand(margin, WORLD_HEIGHT - margin);
          points.push({ x: -55, y });

          for (let i = 1; i <= innerPoints; i += 1) {
            const x = (i / (innerPoints + 1)) * WORLD_WIDTH + rand(-34, 34);
            y = clamp(y + rand(-130, 130), margin, WORLD_HEIGHT - margin);
            points.push({ x, y });
          }

          points.push({ x: WORLD_WIDTH + 55, y: clamp(y + rand(-90, 90), margin, WORLD_HEIGHT - margin) });

          if (hasGoodVariance(points)) {
            candidate = points;
            break;
          }

          candidate = points;
        }

        return buildPath(candidate);
      }

      function hasGoodVariance(points) {
        let movement = 0;
        for (let i = 1; i < points.length; i += 1) {
          movement += Math.abs(points[i].y - points[i - 1].y);
        }
        return movement > WORLD_HEIGHT * 0.75;
      }

      function buildPath(points) {
        const segments = [];
        let length = 0;

        for (let i = 0; i < points.length - 1; i += 1) {
          const a = points[i];
          const b = points[i + 1];
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const segLength = Math.hypot(dx, dy);

          segments.push({
            a,
            b,
            dx,
            dy,
            length: segLength,
            start: length,
            end: length + segLength
          });

          length += segLength;
        }

        return { points, segments, length };
      }

      function pointOnPath(distance) {
        if (distance <= 0) {
          const first = state.path.points[0];
          return { x: first.x, y: first.y };
        }

        if (distance >= state.path.length) {
          const last = state.path.points[state.path.points.length - 1];
          return { x: last.x, y: last.y };
        }

        for (const segment of state.path.segments) {
          if (distance <= segment.end) {
            const t = (distance - segment.start) / segment.length;
            return {
              x: segment.a.x + segment.dx * t,
              y: segment.a.y + segment.dy * t
            };
          }
        }

        const fallback = state.path.points[state.path.points.length - 1];
        return { x: fallback.x, y: fallback.y };
      }

      function generateDecor() {
        const clouds = [];
        const hills = [];

        for (let i = 0; i < 7; i += 1) {
          clouds.push({
            x: rand(-100, WORLD_WIDTH + 80),
            y: rand(34, 175),
            scale: rand(0.68, 1.24),
            speed: rand(4, 10)
          });
        }

        for (let i = 0; i < 5; i += 1) {
          hills.push({
            x: rand(0, WORLD_WIDTH),
            y: rand(WORLD_HEIGHT - 150, WORLD_HEIGHT - 90),
            width: rand(150, 260),
            color: i % 2 === 0 ? 'rgba(142, 210, 132, 0.9)' : 'rgba(128, 198, 122, 0.85)'
          });
        }

        return { clouds, hills };
      }

      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.max(1, Math.round(rect.width * dpr));
        canvas.height = Math.max(1, Math.round(rect.height * dpr));
      }

      function screenToWorld(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        return {
          x: ((clientX - rect.left) / rect.width) * WORLD_WIDTH,
          y: ((clientY - rect.top) / rect.height) * WORLD_HEIGHT
        };
      }

      function syncUI() {
        syncHUDOnly();
        syncShopUI();
        syncSelectionInfo();
        syncLog();
      }

      function syncHUDOnly() {
        els.coin.textContent = 'Coins: ' + Math.floor(state.coins);
        els.life.textContent = 'Lives: ' + state.lives;
        els.wave.textContent = 'Wave: ' + state.wave + '/' + MAX_WAVES;

        let phaseText = '';
        if (state.status === 'victory') {
          phaseText = 'Victory';
        } else if (state.status === 'defeat') {
          phaseText = 'Defeat';
        } else if (state.phase === 'wave') {
          phaseText = 'Wave In Progress';
        } else if (state.wave === 0) {
          phaseText = 'Opening Build';
        } else if (state.buildCountdown !== null) {
          phaseText = 'Build ' + Math.max(0, Math.ceil(state.buildCountdown)) + 's';
        } else {
          phaseText = 'Build Phase';
        }

        els.phase.textContent = phaseText;
        els.phase.classList.toggle('good', state.status === 'victory');
        els.phase.classList.toggle('danger', state.status === 'defeat');

        els.speed.textContent = state.gameSpeed === 1 ? 'Speed x1' : 'Speed x2';

        const canStart = state.status === 'running' && state.phase === 'build' && state.wave < MAX_WAVES;
        els.startWave.disabled = !canStart;

        if (state.status !== 'running') {
          els.startWave.textContent = 'Start Wave';
        } else if (state.phase === 'build' && state.buildCountdown !== null) {
          els.startWave.textContent = 'Start Wave (' + Math.ceil(state.buildCountdown) + ')';
        } else {
          els.startWave.textContent = 'Start Wave';
        }

        els.nextWaveInfo.textContent = formatWaveSummary(state.wave);

        if (state.status === 'victory') {
          els.centerBanner.textContent = 'Victory! Press Restart Run or New Track to play again.';
        } else if (state.status === 'defeat') {
          els.centerBanner.textContent = 'Defeat. Rebuild your strategy and try again.';
        } else if (state.phase === 'wave') {
          const remaining = state.spawnQueue.length + state.enemies.length;
          els.centerBanner.textContent = 'Wave ' + state.wave + ' active. ' + remaining + ' enemies remaining.';
        } else if (state.wave === 0) {
          els.centerBanner.textContent = 'Build your first defenses and press Start Wave.';
        } else if (state.buildCountdown !== null) {
          els.centerBanner.textContent = 'Build phase. Next wave auto-starts in ' + Math.ceil(state.buildCountdown) + 's.';
        } else {
          els.centerBanner.textContent = 'Build phase active. Upgrade and place towers.';
        }
      }

      function syncShopUI() {
        const cards = els.towerShop.querySelectorAll('.tower-card');
        cards.forEach((card) => {
          const type = card.dataset.type;
          const def = TOWER_DEFS[type];
          card.classList.toggle('selected', state.selectedShop === type);

          const locked = state.phase !== 'build' || state.status !== 'running' || state.coins < def.cost;
          card.classList.toggle('locked', locked);
        });
      }

      function syncSelectionInfo() {
        const tower = getSelectedTower();
        const canManageTower = state.status === 'running' && state.phase === 'build';

        if (!tower) {
          els.selectionInfo.innerHTML =
            '<strong>No tower selected</strong><br>' +
            '<span class="muted">Tip: click a built tower to view stats and upgrades.</span>';
          els.upgrade.disabled = true;
          els.sell.disabled = true;
          return;
        }

        const def = TOWER_DEFS[tower.type];
        const stats = def.stats[tower.level];
        const levelLabel = 'L' + (tower.level + 1);

        let extra = '';
        if (def.behavior === 'splash') {
          extra = 'Splash: ' + Math.round(stats.splash);
        } else if (def.behavior === 'chain') {
          extra = 'Chains: ' + stats.chains + ' | Jump: ' + Math.round(stats.chainRange);
        } else if (def.behavior === 'slow') {
          extra = 'Slow: ' + Math.round(stats.slow * 100) + '% for ' + stats.slowDuration.toFixed(1) + 's';
        } else if (def.behavior === 'sniper') {
          extra = 'Crit: ' + Math.round(stats.crit * 100) + '%';
        } else {
          extra = 'Precision single-target';
        }

        let nextLine = 'MAX LEVEL';
        let nextCost = null;
        if (tower.level < 4) {
          nextCost = def.upgradeCosts[tower.level];
          nextLine = 'Upgrade cost: $' + nextCost;
        }

        els.selectionInfo.innerHTML =
          '<strong>' + def.name + ' (' + levelLabel + ')</strong><br>' +
          'Range: ' + Math.round(stats.range) + '<br>' +
          'Damage: ' + Math.round(stats.damage) + '<br>' +
          'Rate: ' + stats.rate.toFixed(2) + '/s<br>' +
          extra + '<br>' +
          '<span class="muted">' + nextLine + '</span>';

        const canUpgrade =
          canManageTower &&
          tower.level < 4 &&
          nextCost !== null &&
          state.coins >= nextCost;

        els.upgrade.disabled = !canUpgrade;
        els.sell.disabled = !canManageTower;
      }

      function syncLog() {
        els.eventLog.textContent = '';
        const fragment = document.createDocumentFragment();
        for (const line of state.log) {
          const item = document.createElement('li');
          item.textContent = line;
          fragment.appendChild(item);
        }
        els.eventLog.appendChild(fragment);
      }

      function pushLog(message) {
        state.log.unshift(message);
        if (state.log.length > 7) {
          state.log.length = 7;
        }
        syncLog();
      }

      function distanceSquared(ax, ay, bx, by) {
        const dx = bx - ax;
        const dy = by - ay;
        return dx * dx + dy * dy;
      }

      function distancePointToSegment(px, py, x1, y1, x2, y2) {
        const l2 = distanceSquared(x1, y1, x2, y2);
        if (l2 === 0) {
          return Math.hypot(px - x1, py - y1);
        }
        let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
        t = clamp(t, 0, 1);
        const cx = x1 + t * (x2 - x1);
        const cy = y1 + t * (y2 - y1);
        return Math.hypot(px - cx, py - cy);
      }

      function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }

      function rand(min, max) {
        return min + Math.random() * (max - min);
      }
    })();
  </script>
</body>
</html>
