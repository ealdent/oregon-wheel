<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>üè∞ Critter Crush TD</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&family=Nunito:wght@400;600;700;800&display=swap');

*{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#1a1a2e;--panel:#16213e;--accent:#e94560;--gold:#f5c518;
  --green:#2ecc71;--blue:#3498db;--purple:#9b59b6;--cyan:#1abc9c;
  --orange:#e67e22;--red:#e74c3c;--pink:#fd79a8;
  --text:#ecf0f1;--text-dim:#7f8c8d;--border:rgba(255,255,255,0.08);
  --shadow:0 4px 20px rgba(0,0,0,0.4);
  --radius:12px;
}
html,body{height:100%;overflow:hidden;background:var(--bg);color:var(--text);font-family:'Nunito',sans-serif}
#app{display:flex;height:100vh;width:100vw}
#game-area{flex:1;display:flex;align-items:center;justify-content:center;position:relative;min-width:0}
canvas{border-radius:var(--radius);cursor:crosshair;image-rendering:auto}

/* Side Panel */
#side-panel{width:280px;background:var(--panel);border-left:1px solid var(--border);display:flex;flex-direction:column;overflow-y:auto;flex-shrink:0}
#side-panel::-webkit-scrollbar{width:6px}
#side-panel::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.15);border-radius:3px}

.panel-section{padding:14px 16px;border-bottom:1px solid var(--border)}
.panel-title{font-family:'Fredoka',sans-serif;font-size:13px;font-weight:600;text-transform:uppercase;letter-spacing:1.5px;color:var(--text-dim);margin-bottom:10px}

/* Stats Bar */
#stats-bar{display:flex;gap:10px;flex-wrap:wrap}
.stat{display:flex;align-items:center;gap:6px;background:rgba(255,255,255,0.05);padding:6px 12px;border-radius:8px;font-weight:700;font-size:14px;flex:1;min-width:80px;justify-content:center}
.stat .icon{font-size:16px}
.stat.gold .icon{color:var(--gold)}
.stat.lives .icon{color:var(--accent)}
.stat.wave .icon{color:var(--cyan)}

/* Tower Shop */
.tower-btn{display:flex;align-items:center;gap:10px;width:100%;padding:10px 12px;border:2px solid transparent;border-radius:10px;background:rgba(255,255,255,0.04);cursor:pointer;transition:all .2s;color:var(--text);font-family:'Nunito',sans-serif;font-size:13px;margin-bottom:6px;text-align:left}
.tower-btn:hover{background:rgba(255,255,255,0.1);border-color:rgba(255,255,255,0.15);transform:translateY(-1px)}
.tower-btn.selected{border-color:var(--gold);background:rgba(245,197,24,0.1)}
.tower-btn .emoji{font-size:24px;width:36px;height:36px;display:flex;align-items:center;justify-content:center;border-radius:8px;background:rgba(255,255,255,0.06)}
.tower-btn .info{flex:1}
.tower-btn .name{font-weight:700;font-size:13px}
.tower-btn .desc{font-size:11px;color:var(--text-dim);margin-top:1px}
.tower-btn .cost{color:var(--gold);font-weight:800;font-size:12px;white-space:nowrap}

/* Tower Info Panel */
#tower-info{display:none}
#tower-info.active{display:block}
.tower-detail-header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
.tower-detail-header .big-emoji{font-size:36px}
.tower-detail-header .detail-text .name{font-family:'Fredoka',sans-serif;font-size:18px;font-weight:700}
.tower-detail-header .detail-text .level{font-size:12px;color:var(--cyan)}
.stat-row{display:flex;justify-content:space-between;padding:4px 0;font-size:13px}
.stat-row .label{color:var(--text-dim)}
.stat-row .value{font-weight:700}
#upgrade-btn,#sell-btn{width:100%;padding:10px;border:none;border-radius:8px;font-family:'Fredoka',sans-serif;font-size:14px;font-weight:600;cursor:pointer;transition:all .2s;margin-top:6px}
#upgrade-btn{background:linear-gradient(135deg,var(--green),#27ae60);color:#fff}
#upgrade-btn:hover{transform:translateY(-1px);box-shadow:0 4px 15px rgba(46,204,113,0.4)}
#upgrade-btn:disabled{background:#555;cursor:not-allowed;transform:none;box-shadow:none}
#sell-btn{background:rgba(231,76,60,0.2);color:var(--red);border:1px solid rgba(231,76,60,0.3)}
#sell-btn:hover{background:rgba(231,76,60,0.3)}

/* Wave Controls */
#wave-controls{text-align:center;padding:16px}
#start-wave-btn{width:100%;padding:12px;border:none;border-radius:10px;font-family:'Fredoka',sans-serif;font-size:16px;font-weight:700;cursor:pointer;transition:all .2s;background:linear-gradient(135deg,var(--accent),#c0392b);color:#fff;letter-spacing:0.5px}
#start-wave-btn:hover{transform:translateY(-2px);box-shadow:0 6px 20px rgba(233,69,96,0.5)}
#start-wave-btn:disabled{background:#555;cursor:not-allowed;transform:none;box-shadow:none}
#wave-info{font-size:12px;color:var(--text-dim);margin-top:8px}
#speed-toggle{margin-top:8px;padding:8px 16px;border:1px solid var(--border);border-radius:8px;background:transparent;color:var(--text);font-family:'Nunito',sans-serif;font-size:12px;cursor:pointer;width:100%}
#speed-toggle:hover{background:rgba(255,255,255,0.05)}

/* Top Bar */
#top-bar{position:absolute;top:12px;left:12px;right:12px;display:flex;justify-content:space-between;align-items:center;pointer-events:none;z-index:10}
#game-title{font-family:'Fredoka',sans-serif;font-size:22px;font-weight:700;text-shadow:0 2px 8px rgba(0,0,0,0.5);pointer-events:auto}
#wave-banner{font-family:'Fredoka',sans-serif;font-size:15px;font-weight:600;background:rgba(0,0,0,0.5);padding:6px 16px;border-radius:20px;backdrop-filter:blur(8px)}

/* Overlays */
.overlay{position:fixed;inset:0;background:rgba(0,0,0,0.7);display:flex;align-items:center;justify-content:center;z-index:100;backdrop-filter:blur(4px)}
.overlay-box{background:var(--panel);border:1px solid var(--border);border-radius:20px;padding:40px;text-align:center;max-width:440px;width:90%;box-shadow:var(--shadow)}
.overlay-box h1{font-family:'Fredoka',sans-serif;font-size:32px;margin-bottom:8px}
.overlay-box p{color:var(--text-dim);margin-bottom:24px;font-size:14px;line-height:1.6}
.overlay-box button{padding:14px 40px;border:none;border-radius:12px;font-family:'Fredoka',sans-serif;font-size:18px;font-weight:700;cursor:pointer;transition:all .2s}
.overlay-box button:hover{transform:translateY(-2px)}
.btn-play{background:linear-gradient(135deg,var(--green),#27ae60);color:#fff}
.btn-retry{background:linear-gradient(135deg,var(--accent),#c0392b);color:#fff}

/* Tooltip */
#tooltip{position:fixed;background:var(--panel);border:1px solid var(--border);border-radius:8px;padding:8px 12px;font-size:12px;pointer-events:none;z-index:50;display:none;box-shadow:var(--shadow);max-width:200px}

/* Responsive */
@media(max-width:900px){
  #app{flex-direction:column}
  #side-panel{width:100%;max-height:45vh;border-left:none;border-top:1px solid var(--border);flex-direction:row;flex-wrap:wrap;overflow-x:auto}
  .panel-section{min-width:200px;flex:1}
  #wave-controls{min-width:180px}
}
@media(max-width:600px){
  #game-title{font-size:16px}
  #wave-banner{font-size:12px;padding:4px 10px}
  .tower-btn .emoji{font-size:20px;width:30px;height:30px}
  .tower-btn{padding:8px 10px}
}

/* Animations */
@keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.05)}}
@keyframes fadeIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}
.fade-in{animation:fadeIn .4s ease}
</style>
</head>
<body>
<div id="app">
  <div id="game-area">
    <div id="top-bar">
      <div id="game-title">üè∞ Critter Crush</div>
      <div id="wave-banner">Wave 0 / 20</div>
    </div>
    <canvas id="gameCanvas"></canvas>
  </div>
  <div id="side-panel">
    <div class="panel-section">
      <div class="panel-title">Resources</div>
      <div id="stats-bar">
        <div class="stat gold"><span class="icon">üí∞</span><span id="gold-display">100</span></div>
        <div class="stat lives"><span class="icon">‚ù§Ô∏è</span><span id="lives-display">20</span></div>
        <div class="stat wave"><span class="icon">üåä</span><span id="wave-display">0</span></div>
      </div>
    </div>
    <div class="panel-section" id="shop-section">
      <div class="panel-title">Towers</div>
      <div id="tower-shop"></div>
    </div>
    <div class="panel-section" id="tower-info">
      <div class="panel-title">Selected Tower</div>
      <div class="tower-detail-header">
        <div class="big-emoji" id="detail-emoji"></div>
        <div class="detail-text">
          <div class="name" id="detail-name"></div>
          <div class="level" id="detail-level"></div>
        </div>
      </div>
      <div id="detail-stats"></div>
      <button id="upgrade-btn">Upgrade</button>
      <button id="sell-btn">Sell</button>
    </div>
    <div id="wave-controls">
      <button id="start-wave-btn">‚ñ∂ Start Wave 1</button>
      <div id="wave-info">Place towers, then start!</div>
      <button id="speed-toggle">‚è© Speed: 1x</button>
    </div>
  </div>
</div>

<div class="overlay" id="start-overlay">
  <div class="overlay-box fade-in">
    <h1>üè∞ Critter Crush</h1>
    <p>Defend your castle from waves of adorable but relentless critters! Place towers along the path, upgrade them between waves, and survive all 20 waves!</p>
    <button class="btn-play" onclick="startGame()">‚ñ∂ Play!</button>
  </div>
</div>

<div class="overlay" id="gameover-overlay" style="display:none">
  <div class="overlay-box fade-in">
    <h1 id="gameover-title">üíÄ Defeated!</h1>
    <p id="gameover-text">The critters overran your defenses!</p>
    <button class="btn-retry" onclick="location.reload()">üîÑ Try Again</button>
  </div>
</div>

<div id="tooltip"></div>

<script>
// ============================================
// GAME CONFIG
// ============================================
const TILE = 40;
const COLS = 20, ROWS = 14;
const W = COLS * TILE, H = ROWS * TILE;

const TOWER_TYPES = [
  {
    id:'arrow', emoji:'üèπ', name:'Arrow Tower', desc:'Fast shots, single target',
    baseCost:50, color:'#e67e22', range:120, damage:8, fireRate:0.8, projSpeed:6, projColor:'#e67e22',
    upgrades:[
      {cost:40, damage:14, range:130, fireRate:0.7, name:'Long Bow'},
      {cost:80, damage:22, range:145, fireRate:0.6, name:'Crossbow'},
      {cost:150, damage:35, range:160, fireRate:0.45, name:'Repeater'},
      {cost:280, damage:55, range:180, fireRate:0.3, name:'Ballista'}
    ]
  },
  {
    id:'cannon', emoji:'üí£', name:'Cannon Tower', desc:'Splash damage, slow fire',
    baseCost:80, color:'#e74c3c', range:110, damage:25, fireRate:2.0, projSpeed:4, projColor:'#e74c3c',
    splash:40, upgrades:[
      {cost:60, damage:40, range:120, splash:50, name:'Big Cannon'},
      {cost:120, damage:65, range:130, splash:60, name:'Mortar'},
      {cost:200, damage:100, range:145, splash:75, name:'Howitzer'},
      {cost:350, damage:160, range:160, splash:90, name:'Mega Bomb'}
    ]
  },
  {
    id:'ice', emoji:'‚ùÑÔ∏è', name:'Ice Tower', desc:'Slows enemies down',
    baseCost:60, color:'#3498db', range:100, damage:5, fireRate:1.2, projSpeed:5, projColor:'#3498db',
    slow:0.5, slowDur:2, upgrades:[
      {cost:50, damage:9, slow:0.45, slowDur:2.5, name:'Frost Tower'},
      {cost:100, damage:15, slow:0.35, slowDur:3, range:115, name:'Blizzard'},
      {cost:180, damage:24, slow:0.25, slowDur:3.5, range:130, name:'Glacier'},
      {cost:300, damage:40, slow:0.15, slowDur:4, range:150, name:'Absolute Zero'}
    ]
  },
  {
    id:'lightning', emoji:'‚ö°', name:'Lightning Tower', desc:'Chains to nearby enemies',
    baseCost:100, color:'#9b59b6', range:120, damage:15, fireRate:1.5, projSpeed:99, projColor:'#9b59b6',
    chain:2, chainRange:60, upgrades:[
      {cost:70, damage:24, chain:3, name:'Tesla Coil'},
      {cost:130, damage:38, chain:4, chainRange:75, name:'Storm Spire'},
      {cost:220, damage:58, chain:5, chainRange:90, range:135, name:'Thunder Keep'},
      {cost:380, damage:85, chain:7, chainRange:110, range:150, name:'Tempest'}
    ]
  },
  {
    id:'poison', emoji:'‚ò†Ô∏è', name:'Poison Tower', desc:'Damage over time',
    baseCost:70, color:'#2ecc71', range:105, damage:6, fireRate:1.4, projSpeed:4.5, projColor:'#2ecc71',
    dot:4, dotDur:3, upgrades:[
      {cost:55, damage:10, dot:7, dotDur:3.5, name:'Toxic Tower'},
      {cost:110, damage:16, dot:12, dotDur:4, range:115, name:'Venom Spire'},
      {cost:190, damage:25, dot:20, dotDur:4.5, range:130, name:'Plague Tower'},
      {cost:330, damage:40, dot:35, dotDur:5, range:150, name:'Blight Keep'}
    ]
  }
];

const ENEMY_TYPES = [
  {id:'slime', emoji:'üü¢', name:'Slime', hp:30, speed:1.2, reward:5, color:'#2ecc71', size:0.6},
  {id:'bat', emoji:'ü¶á', name:'Bat', hp:20, speed:2.2, reward:6, color:'#9b59b6', size:0.5},
  {id:'goblin', emoji:'üë∫', name:'Goblin', hp:60, speed:1.5, reward:8, color:'#e67e22', size:0.65},
  {id:'skeleton', emoji:'üíÄ', name:'Skeleton', hp:100, speed:1.0, reward:12, color:'#bdc3c7', size:0.7},
  {id:'orc', emoji:'üëπ', name:'Orc', hp:180, speed:0.8, reward:18, color:'#27ae60', size:0.85},
  {id:'wizard', emoji:'üßô', name:'Dark Wizard', hp:80, speed:1.8, reward:15, color:'#8e44ad', size:0.6},
  {id:'golem', emoji:'üóø', name:'Golem', hp:400, speed:0.5, reward:30, color:'#7f8c8d', size:1.0},
  {id:'dragon', emoji:'üêâ', name:'Dragon', hp:250, speed:1.4, reward:25, color:'#e74c3c', size:0.9},
  {id:'ghost', emoji:'üëª', name:'Ghost', hp:60, speed:2.5, reward:12, color:'#ecf0f1', size:0.55},
  {id:'boss', emoji:'üëë', name:'Boss', hp:800, speed:0.6, reward:80, color:'#f1c40f', size:1.2}
];

function genWaves(){
  const waves = [];
  for(let i=1;i<=20;i++){
    const w = {num:i, groups:[]};
    const diff = i;
    if(i<=3){
      w.groups.push({type:0, count:5+i*2, delay:0.8});
      if(i>=2) w.groups.push({type:1, count:3+i, delay:0.6});
    } else if(i<=6){
      w.groups.push({type:0, count:8+i, delay:0.6});
      w.groups.push({type:2, count:4+i, delay:0.7});
      if(i>=5) w.groups.push({type:3, count:3+i-4, delay:0.9});
    } else if(i<=10){
      w.groups.push({type:2, count:6+i, delay:0.5});
      w.groups.push({type:3, count:5+i-5, delay:0.7});
      w.groups.push({type:4, count:2+i-6, delay:1.0});
      if(i>=9) w.groups.push({type:5, count:3, delay:0.8});
    } else if(i<=14){
      w.groups.push({type:3, count:8+i-8, delay:0.5});
      w.groups.push({type:4, count:5+i-9, delay:0.7});
      w.groups.push({type:5, count:4+i-10, delay:0.6});
      w.groups.push({type:6, count:1+(i-10), delay:1.5});
    } else if(i<=18){
      w.groups.push({type:4, count:10+i-12, delay:0.4});
      w.groups.push({type:5, count:6+i-13, delay:0.5});
      w.groups.push({type:7, count:3+i-14, delay:0.8});
      w.groups.push({type:6, count:2+i-13, delay:1.2});
      if(i>=17) w.groups.push({type:8, count:5+i-16, delay:0.4});
    } else if(i===19){
      w.groups.push({type:7, count:12, delay:0.4});
      w.groups.push({type:6, count:6, delay:0.8});
      w.groups.push({type:8, count:10, delay:0.35});
      w.groups.push({type:5, count:8, delay:0.5});
    } else {
      w.groups.push({type:9, count:3, delay:3.0}); // 3 bosses
      w.groups.push({type:7, count:15, delay:0.3});
      w.groups.push({type:6, count:8, delay:0.6});
      w.groups.push({type:8, count:12, delay:0.3});
    }
    // Scale HP with wave
    const hpMult = 1 + (i-1)*0.12;
    w.hpMult = hpMult;
    waves.push(w);
  }
  return waves;
}

// ============================================
// MAP GENERATION
// ============================================
function generatePath(){
  // Generate a random winding path
  const grid = Array.from({length:ROWS},()=>Array(COLS).fill(0));
  const path = [];

  // Start from left edge at a random row
  let y = 2 + Math.floor(Math.random()*(ROWS-4));
  let x = 0;
  path.push({x,y});
  grid[y][x]=1;

  const endX = COLS-1;
  let dir = 0; // 0=right, 1=down, 2=up
  let segLen = 0;

  while(x < endX){
    // Decide direction
    if(segLen > 2 + Math.floor(Math.random()*4)){
      // Change direction
      if(dir===0){
        // Go up or down
        if(y < 3) dir=1;
        else if(y > ROWS-4) dir=2;
        else dir = Math.random()<0.5?1:2;
      } else {
        dir=0; // Go right again
      }
      segLen=0;
    }

    let nx=x, ny=y;
    if(dir===0) nx++;
    else if(dir===1) ny++;
    else ny--;

    // Bounds check
    if(nx<0||nx>=COLS||ny<1||ny>=ROWS-1){
      dir=0;
      nx=x+1; ny=y;
    }

    // Avoid self-intersection (check neighbors)
    if(grid[ny]&&grid[ny][nx]){
      dir=0;
      nx=x+1; ny=y;
      if(nx>=COLS) break;
    }

    x=nx; y=ny;
    path.push({x,y});
    grid[y][x]=1;
    segLen++;

    if(x>=endX) break;
  }

  return {path, grid};
}

// ============================================
// GAME STATE
// ============================================
let canvas, ctx;
let gameState = {
  gold:150, lives:20, wave:0, score:0,
  towers:[], enemies:[], projectiles:[], particles:[],
  path:[], grid:[], placeable:[],
  selectedTowerType:null, selectedTower:null,
  waveActive:false, waveEnemies:[], spawnTimer:0, spawnGroup:0, spawnIdx:0,
  speed:1, gameOver:false, victory:false, waves:[]
};

function initGame(){
  canvas = document.getElementById('gameCanvas');
  ctx = canvas.getContext('2d');

  // Responsive sizing
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // Generate map
  const {path, grid} = generatePath();
  gameState.path = path;
  gameState.grid = grid;

  // Calculate placeable tiles
  gameState.placeable = [];
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if(!grid[r][c]){
        // Check if adjacent to path (makes it strategic)
        let adj=false;
        for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
          if(grid[r+dr]&&grid[r+dr][c+dc]) adj=true;
        }
        if(adj) gameState.placeable.push({x:c,y:r});
      }
    }
  }

  gameState.waves = genWaves();

  // Build shop UI
  buildShop();

  // Events
  canvas.addEventListener('click', onCanvasClick);
  canvas.addEventListener('mousemove', onCanvasMove);
  canvas.addEventListener('mouseleave', ()=>{gameState.hoverTile=null});
  document.getElementById('start-wave-btn').addEventListener('click', startWave);
  document.getElementById('upgrade-btn').addEventListener('click', upgradeTower);
  document.getElementById('sell-btn').addEventListener('click', sellTower);
  document.getElementById('speed-toggle').addEventListener('click', toggleSpeed);

  requestAnimationFrame(gameLoop);
}

function resizeCanvas(){
  const area = document.getElementById('game-area');
  const maxW = area.clientWidth - 24;
  const maxH = area.clientHeight - 60;
  const scale = Math.min(maxW/W, maxH/H, 1.5);
  canvas.width = W;
  canvas.height = H;
  canvas.style.width = (W*scale)+'px';
  canvas.style.height = (H*scale)+'px';
  gameState.canvasScale = scale;
  gameState.canvasRect = null;
}

function getCanvasPos(e){
  if(!gameState.canvasRect) gameState.canvasRect = canvas.getBoundingClientRect();
  const r = gameState.canvasRect;
  return {
    x:(e.clientX - r.left)*(W/r.width),
    y:(e.clientY - r.top)*(H/r.height)
  };
}

// ============================================
// UI
// ============================================
function buildShop(){
  const shop = document.getElementById('tower-shop');
  shop.innerHTML='';
  TOWER_TYPES.forEach((t,i)=>{
    const btn = document.createElement('button');
    btn.className='tower-btn';
    btn.dataset.idx=i;
    btn.innerHTML=`
      <div class="emoji">${t.emoji}</div>
      <div class="info"><div class="name">${t.name}</div><div class="desc">${t.desc}</div></div>
      <div class="cost">üí∞${t.baseCost}</div>
    `;
    btn.addEventListener('click',()=>selectTowerType(i));
    shop.appendChild(btn);
  });
}

function selectTowerType(idx){
  if(gameState.selectedTowerType===idx){
    gameState.selectedTowerType=null;
  } else {
    gameState.selectedTowerType=idx;
    gameState.selectedTower=null;
    updateTowerInfo();
  }
  document.querySelectorAll('.tower-btn').forEach((b,i)=>{
    b.classList.toggle('selected',i===gameState.selectedTowerType);
  });
}

function updateUI(){
  document.getElementById('gold-display').textContent=gameState.gold;
  document.getElementById('lives-display').textContent=gameState.lives;
  document.getElementById('wave-display').textContent=gameState.wave;
  document.getElementById('wave-banner').textContent=`Wave ${gameState.wave} / 20`;

  const btn = document.getElementById('start-wave-btn');
  if(gameState.waveActive){
    btn.disabled=true;
    btn.textContent='‚öîÔ∏è Wave in Progress...';
  } else if(gameState.wave>=20){
    btn.disabled=true;
    btn.textContent='üéâ All Waves Complete!';
  } else {
    btn.disabled=false;
    btn.textContent=`‚ñ∂ Start Wave ${gameState.wave+1}`;
  }

  // Update shop affordability
  document.querySelectorAll('.tower-btn').forEach((b,i)=>{
    b.style.opacity = gameState.gold >= TOWER_TYPES[i].baseCost ? 1 : 0.5;
  });
}

function updateTowerInfo(){
  const panel = document.getElementById('tower-info');
  const t = gameState.selectedTower;
  if(!t){panel.classList.remove('active');return;}
  panel.classList.add('active');

  const type = TOWER_TYPES[t.typeIdx];
  const lvl = t.level;
  document.getElementById('detail-emoji').textContent=type.emoji;
  document.getElementById('detail-name').textContent= lvl>0 ? type.upgrades[lvl-1].name : type.name;
  document.getElementById('detail-level').textContent=`Level ${lvl+1} / 5`;

  const stats = document.getElementById('detail-stats');
  stats.innerHTML=`
    <div class="stat-row"><span class="label">Damage</span><span class="value">${t.damage.toFixed(0)}</span></div>
    <div class="stat-row"><span class="label">Range</span><span class="value">${t.range.toFixed(0)}</span></div>
    <div class="stat-row"><span class="label">Fire Rate</span><span class="value">${(1/t.fireRate).toFixed(1)}/s</span></div>
    ${t.splash?`<div class="stat-row"><span class="label">Splash</span><span class="value">${t.splash.toFixed(0)}</span></div>`:''}
    ${t.slow?`<div class="stat-row"><span class="label">Slow</span><span class="value">${((1-t.slow)*100).toFixed(0)}%</span></div>`:''}
    ${t.chain?`<div class="stat-row"><span class="label">Chain</span><span class="value">${t.chain} targets</span></div>`:''}
    ${t.dot?`<div class="stat-row"><span class="label">Poison</span><span class="value">${t.dot}/s for ${t.dotDur}s</span></div>`:''}
  `;

  const upgradeBtn = document.getElementById('upgrade-btn');
  if(lvl < 4){
    const upg = type.upgrades[lvl];
    upgradeBtn.disabled = gameState.gold < upg.cost;
    upgradeBtn.textContent=`‚¨Ü Upgrade: ${upg.name} (üí∞${upg.cost})`;
  } else {
    upgradeBtn.disabled=true;
    upgradeBtn.textContent='Max Level!';
  }

  const sellValue = Math.floor(t.totalCost * 0.6);
  document.getElementById('sell-btn').textContent=`üóë Sell (üí∞${sellValue})`;
}

// ============================================
// GAME ACTIONS
// ============================================
function onCanvasClick(e){
  const pos = getCanvasPos(e);
  const tx = Math.floor(pos.x/TILE);
  const ty = Math.floor(pos.y/TILE);

  // Check if clicking existing tower
  const existingTower = gameState.towers.find(t=>t.gx===tx&&t.gy===ty);
  if(existingTower){
    gameState.selectedTower = existingTower;
    gameState.selectedTowerType = null;
    document.querySelectorAll('.tower-btn').forEach(b=>b.classList.remove('selected'));
    updateTowerInfo();
    return;
  }

  // Place new tower
  if(gameState.selectedTowerType!==null){
    const type = TOWER_TYPES[gameState.selectedTowerType];
    if(gameState.gold < type.baseCost) return;

    // Check if placeable
    const isOnPath = gameState.grid[ty]&&gameState.grid[ty][tx];
    if(isOnPath) return;
    if(tx<0||tx>=COLS||ty<0||ty>=ROWS) return;

    // Check not already occupied
    if(gameState.towers.find(t=>t.gx===tx&&t.gy===ty)) return;

    // Check if adjacent to path or another tower
    const isPlaceable = gameState.placeable.find(p=>p.x===tx&&p.y===ty);
    if(!isPlaceable){
      // Allow placing adjacent to other towers too
      let nearTower = gameState.towers.some(t=>Math.abs(t.gx-tx)<=1&&Math.abs(t.gy-ty)<=1);
      if(!nearTower) return;
    }

    placeTower(tx, ty, gameState.selectedTowerType);
  } else {
    gameState.selectedTower = null;
    updateTowerInfo();
  }
}

let hoverPos = null;
function onCanvasMove(e){
  const pos = getCanvasPos(e);
  hoverPos = pos;
  const tx = Math.floor(pos.x/TILE);
  const ty = Math.floor(pos.y/TILE);
  gameState.hoverTile = {x:tx, y:ty};
  gameState.canvasRect = null; // refresh on next click
}

function placeTower(gx, gy, typeIdx){
  const type = TOWER_TYPES[typeIdx];
  if(gameState.gold < type.baseCost) return;

  gameState.gold -= type.baseCost;
  const tower = {
    gx, gy,
    x: gx*TILE + TILE/2,
    y: gy*TILE + TILE/2,
    typeIdx,
    level:0,
    damage: type.damage,
    range: type.range,
    fireRate: type.fireRate,
    cooldown:0,
    totalCost: type.baseCost,
    splash: type.splash||0,
    slow: type.slow||0,
    slowDur: type.slowDur||0,
    chain: type.chain||0,
    chainRange: type.chainRange||0,
    dot: type.dot||0,
    dotDur: type.dotDur||0,
    angle:0
  };
  gameState.towers.push(tower);
  gameState.selectedTower = tower;

  // Particle effect
  for(let i=0;i<12;i++){
    gameState.particles.push({
      x:tower.x, y:tower.y,
      vx:(Math.random()-0.5)*3, vy:(Math.random()-0.5)*3,
      life:0.6, maxLife:0.6, color:type.color, size:4
    });
  }

  updateTowerInfo();
  updateUI();
}

function upgradeTower(){
  const t = gameState.selectedTower;
  if(!t||t.level>=4) return;

  const type = TOWER_TYPES[t.typeIdx];
  const upg = type.upgrades[t.level];
  if(gameState.gold < upg.cost) return;

  gameState.gold -= upg.cost;
  t.totalCost += upg.cost;
  t.level++;

  // Apply upgrade stats
  if(upg.damage) t.damage = upg.damage;
  if(upg.range) t.range = upg.range;
  if(upg.fireRate) t.fireRate = upg.fireRate;
  if(upg.splash) t.splash = upg.splash;
  if(upg.slow) t.slow = upg.slow;
  if(upg.slowDur) t.slowDur = upg.slowDur;
  if(upg.chain) t.chain = upg.chain;
  if(upg.chainRange) t.chainRange = upg.chainRange;
  if(upg.dot) t.dot = upg.dot;
  if(upg.dotDur) t.dotDur = upg.dotDur;

  // Particle effect
  for(let i=0;i<16;i++){
    gameState.particles.push({
      x:t.x, y:t.y,
      vx:(Math.random()-0.5)*4, vy:(Math.random()-0.5)*4,
      life:0.8, maxLife:0.8, color:'#f5c518', size:5
    });
  }

  updateTowerInfo();
  updateUI();
}

function sellTower(){
  const t = gameState.selectedTower;
  if(!t) return;
  const refund = Math.floor(t.totalCost * 0.6);
  gameState.gold += refund;
  gameState.towers = gameState.towers.filter(tw=>tw!==t);
  gameState.selectedTower = null;
  updateTowerInfo();
  updateUI();
}

function startWave(){
  if(gameState.waveActive || gameState.wave>=20) return;
  gameState.wave++;
  gameState.waveActive = true;

  const waveDef = gameState.waves[gameState.wave-1];
  gameState.waveEnemies = [];

  // Flatten groups into spawn queue
  let spawnDelay = 0;
  waveDef.groups.forEach(g=>{
    for(let i=0;i<g.count;i++){
      gameState.waveEnemies.push({
        typeIdx: g.type,
        spawnAt: spawnDelay,
        hpMult: waveDef.hpMult
      });
      spawnDelay += g.delay;
    }
  });

  gameState.spawnTimer=0;
  gameState.spawnIdx=0;

  updateUI();
}

function toggleSpeed(){
  const speeds = [1,2,3];
  const idx = speeds.indexOf(gameState.speed);
  gameState.speed = speeds[(idx+1)%speeds.length];
  document.getElementById('speed-toggle').textContent=`‚è© Speed: ${gameState.speed}x`;
}

// ============================================
// GAME LOOP
// ============================================
let lastTime = 0;
function gameLoop(time){
  if(gameState.gameOver || gameState.victory) return;

  const rawDt = Math.min((time-lastTime)/1000, 0.05);
  lastTime = time;
  const dt = rawDt * gameState.speed;

  update(dt);
  render();
  updateUI();

  requestAnimationFrame(gameLoop);
}

function update(dt){
  // Spawn enemies
  if(gameState.waveActive && gameState.spawnIdx < gameState.waveEnemies.length){
    gameState.spawnTimer += dt;
    while(gameState.spawnIdx < gameState.waveEnemies.length &&
          gameState.spawnTimer >= gameState.waveEnemies[gameState.spawnIdx].spawnAt){
      spawnEnemy(gameState.waveEnemies[gameState.spawnIdx]);
      gameState.spawnIdx++;
    }
  }

  // Check wave complete
  if(gameState.waveActive && gameState.spawnIdx >= gameState.waveEnemies.length && gameState.enemies.length===0){
    gameState.waveActive = false;
    // Wave bonus
    gameState.gold += 10 + gameState.wave * 3;

    if(gameState.wave >= 20){
      gameState.victory = true;
      showGameOver(true);
    }
    updateUI();
  }

  // Update enemies
  gameState.enemies.forEach(e=>{
    if(e.dead) return;

    // DOT damage
    if(e.dotTimer>0){
      e.dotTimer -= dt;
      e.hp -= e.dotDmg * dt;
      if(e.hp<=0){e.dead=true; e.killedByDot=true;}
    }

    // Slow
    let speedMult = 1;
    if(e.slowTimer > 0){
      e.slowTimer -= dt;
      speedMult = e.slowAmount;
    }

    // Move along path
    if(e.pathIdx < gameState.path.length-1){
      const target = gameState.path[e.pathIdx+1];
      const tx = target.x*TILE+TILE/2;
      const ty = target.y*TILE+TILE/2;
      const dx = tx-e.x;
      const dy = ty-e.y;
      const dist = Math.sqrt(dx*dx+dy*dy);
      const speed = e.speed * speedMult * TILE * dt;

      if(dist < speed){
        e.x = tx;
        e.y = ty;
        e.pathIdx++;
      } else {
        e.x += (dx/dist)*speed;
        e.y += (dy/dist)*speed;
      }
      e.angle = Math.atan2(dy,dx);
    }

    // Reached end
    if(e.pathIdx >= gameState.path.length-1){
      e.dead=true;
      gameState.lives--;
      // Red flash particles
      for(let i=0;i<8;i++){
        gameState.particles.push({
          x:e.x, y:e.y,
          vx:(Math.random()-0.5)*3, vy:(Math.random()-0.5)*3,
          life:0.5, maxLife:0.5, color:'#e74c3c', size:6
        });
      }
      if(gameState.lives<=0){
        gameState.gameOver=true;
        showGameOver(false);
      }
    }
  });

  // Remove dead enemies & reward
  gameState.enemies = gameState.enemies.filter(e=>{
    if(e.dead && !e.reachedEnd && e.hp<=0){
      gameState.gold += e.reward;
      gameState.score += e.reward;
      // Death particles
      for(let i=0;i<8;i++){
        gameState.particles.push({
          x:e.x, y:e.y,
          vx:(Math.random()-0.5)*4, vy:(Math.random()-0.5)*4,
          life:0.5, maxLife:0.5, color:e.color, size:4
        });
      }
      return false;
    }
    if(e.dead) return false;
    return true;
  });

  // Tower AI
  gameState.towers.forEach(t=>{
    t.cooldown -= dt;
    if(t.cooldown > 0) return;

    // Find target
    let target = null;
    let bestProgress = -1;
    gameState.enemies.forEach(e=>{
      if(e.dead) return;
      const dx=e.x-t.x, dy=e.y-t.y;
      const dist=Math.sqrt(dx*dx+dy*dy);
      if(dist <= t.range && e.pathIdx > bestProgress){
        bestProgress = e.pathIdx;
        target = e;
      }
    });

    if(target){
      t.cooldown = t.fireRate;
      t.angle = Math.atan2(target.y-t.y, target.x-t.x);
      fireProjectile(t, target);
    }
  });

  // Update projectiles
  gameState.projectiles.forEach(p=>{
    if(p.dead) return;

    if(p.instant){
      // Lightning - instant hit
      p.dead=true;
      hitEnemy(p.target, p);

      // Chain lightning
      if(p.chain > 0){
        let chained = [p.target];
        let current = p.target;
        for(let c=0;c<p.chain;c++){
          let nearest=null, nearDist=p.chainRange||60;
          gameState.enemies.forEach(e=>{
            if(e.dead||chained.includes(e)) return;
            const d=Math.sqrt((e.x-current.x)**2+(e.y-current.y)**2);
            if(d<nearDist){nearDist=d;nearest=e;}
          });
          if(nearest){
            chained.push(nearest);
            hitEnemy(nearest, p);
            // Lightning visual
            gameState.particles.push({
              x:current.x, y:current.y,
              tx:nearest.x, ty:nearest.y,
              life:0.2, maxLife:0.2, type:'lightning', color:p.color
            });
            current = nearest;
          } else break;
        }
      }
      return;
    }

    // Regular projectile
    const dx=p.target.x-p.x, dy=p.target.y-p.y;
    const dist=Math.sqrt(dx*dx+dy*dy);
    const speed = p.speed * TILE * (1/60) * gameState.speed;

    if(dist < speed+8 || p.target.dead){
      if(!p.target.dead) hitEnemy(p.target, p);
      p.dead=true;

      // Splash
      if(p.splash){
        gameState.enemies.forEach(e=>{
          if(e===p.target||e.dead) return;
          const sd=Math.sqrt((e.x-p.target.x)**2+(e.y-p.target.y)**2);
          if(sd<=p.splash){
            const falloff = 1 - sd/p.splash;
            e.hp -= p.damage * falloff * 0.6;
            if(e.hp<=0) e.dead=true;
          }
        });
        // Explosion particles
        for(let i=0;i<12;i++){
          gameState.particles.push({
            x:p.x, y:p.y,
            vx:(Math.random()-0.5)*5, vy:(Math.random()-0.5)*5,
            life:0.4, maxLife:0.4, color:p.color, size:6
          });
        }
      }
    } else {
      p.x += (dx/dist)*speed;
      p.y += (dy/dist)*speed;
    }
  });
  gameState.projectiles = gameState.projectiles.filter(p=>!p.dead);

  // Update particles
  gameState.particles.forEach(p=>{
    p.life -= dt;
    if(p.type!=='lightning'){
      p.x += (p.vx||0)*dt*60;
      p.y += (p.vy||0)*dt*60;
    }
  });
  gameState.particles = gameState.particles.filter(p=>p.life>0);
}

function spawnEnemy(def){
  const type = ENEMY_TYPES[def.typeIdx];
  const start = gameState.path[0];
  gameState.enemies.push({
    x: start.x*TILE+TILE/2,
    y: start.y*TILE+TILE/2,
    pathIdx:0,
    hp: type.hp * def.hpMult,
    maxHp: type.hp * def.hpMult,
    speed: type.speed,
    reward: type.reward,
    color: type.color,
    size: type.size,
    emoji: type.emoji,
    name: type.name,
    angle:0,
    dead:false,
    slowTimer:0, slowAmount:1,
    dotTimer:0, dotDmg:0
  });
}

function fireProjectile(tower, target){
  const type = TOWER_TYPES[tower.typeIdx];
  const p = {
    x:tower.x, y:tower.y,
    target, damage:tower.damage,
    speed: type.projSpeed,
    color: type.projColor,
    splash: tower.splash,
    slow: tower.slow,
    slowDur: tower.slowDur,
    chain: tower.chain,
    chainRange: tower.chainRange,
    dot: tower.dot,
    dotDur: tower.dotDur,
    instant: type.projSpeed >= 50,
    dead:false
  };
  gameState.projectiles.push(p);

  // Lightning visual from tower to target
  if(p.instant){
    gameState.particles.push({
      x:tower.x, y:tower.y,
      tx:target.x, ty:target.y,
      life:0.15, maxLife:0.15, type:'lightning', color:p.color
    });
  }
}

function hitEnemy(enemy, proj){
  if(enemy.dead) return;
  enemy.hp -= proj.damage;
  if(proj.slow && (!enemy.slowTimer || enemy.slowTimer<=0 || proj.slow < enemy.slowAmount)){
    enemy.slowTimer = proj.slowDur;
    enemy.slowAmount = proj.slow;
  }
  if(proj.dot && (!enemy.dotTimer || enemy.dotTimer<=0 || proj.dot > enemy.dotDmg)){
    enemy.dotTimer = proj.dotDur;
    enemy.dotDmg = proj.dot;
  }
  if(enemy.hp<=0) enemy.dead=true;
}

function showGameOver(victory){
  const overlay = document.getElementById('gameover-overlay');
  overlay.style.display='flex';
  document.getElementById('gameover-title').textContent = victory ? 'üéâ Victory!' : 'üíÄ Defeated!';
  document.getElementById('gameover-text').textContent = victory
    ? `You survived all 20 waves! Score: ${gameState.score}`
    : `You were overrun on wave ${gameState.wave}. Score: ${gameState.score}`;
}

// ============================================
// RENDERING
// ============================================
function render(){
  ctx.clearRect(0,0,W,H);

  drawBackground();
  drawPath();
  drawTowers();
  drawEnemies();
  drawProjectiles();
  drawParticles();
  drawHoverPreview();
  drawRangeCircle();
}

function drawBackground(){
  // Grass
  ctx.fillStyle='#2d5016';
  ctx.fillRect(0,0,W,H);

  // Subtle grid pattern
  ctx.strokeStyle='rgba(255,255,255,0.03)';
  ctx.lineWidth=1;
  for(let x=0;x<=COLS;x++){
    ctx.beginPath();ctx.moveTo(x*TILE,0);ctx.lineTo(x*TILE,H);ctx.stroke();
  }
  for(let y=0;y<=ROWS;y++){
    ctx.beginPath();ctx.moveTo(0,y*TILE);ctx.lineTo(W,y*TILE);ctx.stroke();
  }

  // Decorative grass tufts (deterministic based on position)
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
    if(gameState.grid[r]&&gameState.grid[r][c]) continue;
    const hash = (r*31+c*17)%100;
    if(hash<15){
      const cx=c*TILE+TILE/2, cy=r*TILE+TILE/2;
      ctx.fillStyle=hash<7?'#3a6b1e':'#245510';
      ctx.font='10px serif';
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillText(hash<5?'üåø':'üå±',cx+(hash%3)*4-4,cy);
    }
  }
}

function drawPath(){
  const path = gameState.path;
  if(path.length<2) return;

  // Path shadow
  ctx.strokeStyle='rgba(0,0,0,0.3)';
  ctx.lineWidth=TILE+4;
  ctx.lineCap='round';
  ctx.lineJoin='round';
  ctx.beginPath();
  ctx.moveTo(path[0].x*TILE+TILE/2+2, path[0].y*TILE+TILE/2+2);
  for(let i=1;i<path.length;i++){
    ctx.lineTo(path[i].x*TILE+TILE/2+2, path[i].y*TILE+TILE/2+2);
  }
  ctx.stroke();

  // Main path
  ctx.strokeStyle='#c4956a';
  ctx.lineWidth=TILE-4;
  ctx.beginPath();
  ctx.moveTo(path[0].x*TILE+TILE/2, path[0].y*TILE+TILE/2);
  for(let i=1;i<path.length;i++){
    ctx.lineTo(path[i].x*TILE+TILE/2, path[i].y*TILE+TILE/2);
  }
  ctx.stroke();

  // Inner path detail
  ctx.strokeStyle='#d4a574';
  ctx.lineWidth=TILE-12;
  ctx.beginPath();
  ctx.moveTo(path[0].x*TILE+TILE/2, path[0].y*TILE+TILE/2);
  for(let i=1;i<path.length;i++){
    ctx.lineTo(path[i].x*TILE+TILE/2, path[i].y*TILE+TILE/2);
  }
  ctx.stroke();

  // Start & End markers
  const s = path[0], e = path[path.length-1];
  ctx.font='24px serif';
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  ctx.fillText('üö™', s.x*TILE+TILE/2, s.y*TILE+TILE/2);
  ctx.fillText('üè∞', e.x*TILE+TILE/2, e.y*TILE+TILE/2);
}

function drawTowers(){
  gameState.towers.forEach(t=>{
    const type = TOWER_TYPES[t.typeIdx];
    const x = t.x, y = t.y;

    // Base
    const baseSize = TILE*0.85;
    ctx.fillStyle='rgba(0,0,0,0.2)';
    ctx.beginPath();
    ctx.arc(x+2, y+2, baseSize/2, 0, Math.PI*2);
    ctx.fill();

    // Tower body colored by type
    const grad = ctx.createRadialGradient(x-3,y-3,0,x,y,baseSize/2);
    grad.addColorStop(0, lightenColor(type.color, 30));
    grad.addColorStop(1, type.color);
    ctx.fillStyle=grad;
    ctx.beginPath();
    ctx.arc(x, y, baseSize/2, 0, Math.PI*2);
    ctx.fill();

    // Border
    ctx.strokeStyle='rgba(0,0,0,0.3)';
    ctx.lineWidth=2;
    ctx.stroke();

    // Level indicators (small dots)
    for(let i=0;i<t.level;i++){
      const a = (-Math.PI/2) + (i/(Math.max(t.level-1,1)))*Math.PI - (t.level>1?Math.PI/2:0);
      const r = baseSize/2 + 4;
      ctx.fillStyle='#f5c518';
      ctx.beginPath();
      ctx.arc(x + Math.cos(a)*r*0.7, y-baseSize/2-3+i*4, 2.5, 0, Math.PI*2);
      ctx.fill();
    }

    // Emoji
    ctx.font=`${16+t.level*1.5}px serif`;
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.fillText(type.emoji, x, y);

    // Selected indicator
    if(gameState.selectedTower === t){
      ctx.strokeStyle='#f5c518';
      ctx.lineWidth=2.5;
      ctx.setLineDash([4,4]);
      ctx.beginPath();
      ctx.arc(x, y, baseSize/2+4, 0, Math.PI*2);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  });
}

function drawEnemies(){
  gameState.enemies.forEach(e=>{
    if(e.dead) return;
    const size = TILE * e.size;

    // Shadow
    ctx.fillStyle='rgba(0,0,0,0.2)';
    ctx.beginPath();
    ctx.ellipse(e.x+1, e.y+size/3, size/3, size/6, 0, 0, Math.PI*2);
    ctx.fill();

    // Emoji
    ctx.font=`${size*0.8}px serif`;
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.fillText(e.emoji, e.x, e.y);

    // HP bar
    const barW = size*0.9;
    const barH = 4;
    const barX = e.x-barW/2;
    const barY = e.y-size/2-6;
    const hpPct = e.hp/e.maxHp;

    ctx.fillStyle='rgba(0,0,0,0.5)';
    roundRect(ctx,barX-1,barY-1,barW+2,barH+2,2);ctx.fill();

    ctx.fillStyle = hpPct>0.5?'#2ecc71':hpPct>0.25?'#f39c12':'#e74c3c';
    if(hpPct>0){
      roundRect(ctx,barX,barY,barW*hpPct,barH,2);ctx.fill();
    }

    // Slow indicator
    if(e.slowTimer>0){
      ctx.fillStyle='rgba(52,152,219,0.5)';
      ctx.beginPath();
      ctx.arc(e.x, e.y, size/2.5, 0, Math.PI*2);
      ctx.fill();
    }

    // Poison indicator
    if(e.dotTimer>0){
      ctx.fillStyle='rgba(46,204,113,0.4)';
      ctx.beginPath();
      ctx.arc(e.x, e.y, size/2.8, 0, Math.PI*2);
      ctx.fill();
    }
  });
}

function drawProjectiles(){
  gameState.projectiles.forEach(p=>{
    if(p.dead||p.instant) return;
    ctx.fillStyle=p.color;
    ctx.shadowColor=p.color;
    ctx.shadowBlur=6;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur=0;
  });
}

function drawParticles(){
  gameState.particles.forEach(p=>{
    const alpha = p.life/p.maxLife;

    if(p.type==='lightning'){
      // Lightning bolt
      ctx.strokeStyle=`rgba(${hexToRgb(p.color)},${alpha})`;
      ctx.lineWidth=2;
      ctx.shadowColor=p.color;
      ctx.shadowBlur=8;
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      const dx=p.tx-p.x, dy=p.ty-p.y;
      const steps=5;
      for(let i=1;i<=steps;i++){
        const t=i/steps;
        const jx=(Math.random()-0.5)*15*(1-t);
        const jy=(Math.random()-0.5)*15*(1-t);
        ctx.lineTo(p.x+dx*t+jx, p.y+dy*t+jy);
      }
      ctx.stroke();
      ctx.shadowBlur=0;
    } else {
      ctx.fillStyle=`rgba(${hexToRgb(p.color)},${alpha})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size*alpha, 0, Math.PI*2);
      ctx.fill();
    }
  });
}

function drawHoverPreview(){
  if(!gameState.hoverTile || gameState.selectedTowerType===null) return;
  const {x:tx,y:ty} = gameState.hoverTile;
  if(tx<0||tx>=COLS||ty<0||ty>=ROWS) return;

  const isOnPath = gameState.grid[ty]&&gameState.grid[ty][tx];
  const isOccupied = gameState.towers.find(t=>t.gx===tx&&t.gy===ty);
  const isPlaceable = gameState.placeable.find(p=>p.x===tx&&p.y===ty) ||
    gameState.towers.some(t=>Math.abs(t.gx-tx)<=1&&Math.abs(t.gy-ty)<=1);

  const canPlace = !isOnPath && !isOccupied && isPlaceable;

  const cx = tx*TILE+TILE/2, cy = ty*TILE+TILE/2;

  // Range preview
  const type = TOWER_TYPES[gameState.selectedTowerType];
  ctx.fillStyle = canPlace ? 'rgba(46,204,113,0.1)' : 'rgba(231,76,60,0.1)';
  ctx.strokeStyle = canPlace ? 'rgba(46,204,113,0.3)' : 'rgba(231,76,60,0.3)';
  ctx.lineWidth=1;
  ctx.beginPath();
  ctx.arc(cx, cy, type.range, 0, Math.PI*2);
  ctx.fill();
  ctx.stroke();

  // Tile highlight
  ctx.fillStyle = canPlace ? 'rgba(46,204,113,0.3)' : 'rgba(231,76,60,0.3)';
  ctx.fillRect(tx*TILE, ty*TILE, TILE, TILE);

  // Preview emoji
  if(canPlace){
    ctx.globalAlpha=0.6;
    ctx.font='16px serif';
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.fillText(type.emoji, cx, cy);
    ctx.globalAlpha=1;
  }
}

function drawRangeCircle(){
  const t = gameState.selectedTower;
  if(!t) return;

  ctx.strokeStyle='rgba(245,197,24,0.3)';
  ctx.fillStyle='rgba(245,197,24,0.05)';
  ctx.lineWidth=1.5;
  ctx.setLineDash([6,4]);
  ctx.beginPath();
  ctx.arc(t.x, t.y, t.range, 0, Math.PI*2);
  ctx.fill();
  ctx.stroke();
  ctx.setLineDash([]);
}

// ============================================
// HELPERS
// ============================================
function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.lineTo(x+w-r,y);ctx.quadraticCurveTo(x+w,y,x+w,y+r);
  ctx.lineTo(x+w,y+h-r);ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  ctx.lineTo(x+r,y+h);ctx.quadraticCurveTo(x,y+h,x,y+h-r);
  ctx.lineTo(x,y+r);ctx.quadraticCurveTo(x,y,x+r,y);
  ctx.closePath();
}

function hexToRgb(hex){
  const r=parseInt(hex.slice(1,3),16);
  const g=parseInt(hex.slice(3,5),16);
  const b=parseInt(hex.slice(5,7),16);
  return `${r},${g},${b}`;
}

function lightenColor(hex,pct){
  let r=parseInt(hex.slice(1,3),16);
  let g=parseInt(hex.slice(3,5),16);
  let b=parseInt(hex.slice(5,7),16);
  r=Math.min(255,r+pct);g=Math.min(255,g+pct);b=Math.min(255,b+pct);
  return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
}

function startGame(){
  document.getElementById('start-overlay').style.display='none';
  initGame();
}
</script>
</body>
</html>
