<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sky & Weather Infographic</title>
  <meta name="color-scheme" content="dark light" />
  <style>
    :root{
      --bg0:#070A12;
      --bg1:#0B1433;
      --card: rgba(255,255,255,.08);
      --card2: rgba(255,255,255,.06);
      --stroke: rgba(255,255,255,.14);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.68);
      --faint: rgba(255,255,255,.48);
      --good: #66e3b4;
      --warn: #ffd166;
      --bad:  #ff6b6b;
      --shadow: 0 24px 70px rgba(0,0,0,.45);
      --radius: 22px;
      --radius2: 16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--text);
      background:
        radial-gradient(1200px 900px at 15% 10%, rgba(103, 77, 255, .30), transparent 55%),
        radial-gradient(1000px 800px at 85% 25%, rgba(0, 205, 255, .22), transparent 60%),
        radial-gradient(900px 700px at 60% 100%, rgba(255, 179, 71, .18), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x:hidden;
    }

    /* Subtle noise (pure CSS) */
    body:before{
      content:"";
      position:fixed;
      inset:-200px;
      background-image:
        radial-gradient(circle at 20% 20%, rgba(255,255,255,.035) 0 1px, transparent 2px),
        radial-gradient(circle at 70% 50%, rgba(255,255,255,.030) 0 1px, transparent 2px),
        radial-gradient(circle at 40% 80%, rgba(255,255,255,.028) 0 1px, transparent 2px);
      background-size: 90px 90px, 120px 120px, 150px 150px;
      pointer-events:none;
      filter: blur(.2px);
      opacity:.35;
      transform: rotate(-2deg);
    }

    .wrap{
      max-width: 1120px;
      margin: 0 auto;
      padding: 26px 18px 34px;
      position: relative;
    }

    .topbar{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:14px;
      margin-bottom: 18px;
    }

    .brand{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width: 240px;
    }

    .titleRow{
      display:flex;
      align-items:center;
      gap:10px;
    }

    .pin{
      width: 14px; height: 14px;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.35));
      opacity:.95;
    }

    h1{
      font-size: 20px;
      line-height: 1.15;
      margin:0;
      letter-spacing: .2px;
      font-weight: 720;
    }

    .sub{
      color: var(--muted);
      font-size: 13px;
      line-height: 1.25;
      margin:0;
      letter-spacing:.2px;
    }

    .controls{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap: wrap;
      justify-content:flex-end;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,.07);
      border: 1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 18px 50px rgba(0,0,0,.25);
      user-select:none;
    }

    .pill small{ color: var(--muted); font-size: 12px; }
    .pill .mono{ font-family: var(--mono); font-size: 12.5px; color: var(--text); }
    .btn{
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.08);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 999px;
      cursor:pointer;
      font-weight: 650;
      letter-spacing:.2px;
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .btn:hover{ background: rgba(255,255,255,.11); border-color: rgba(255,255,255,.22); }
    .btn:active{ transform: translateY(1px) scale(.99); }

    .grid{
      display:grid;
      grid-template-columns: 1.25fr .95fr;
      gap: 16px;
    }

    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
      .controls{ justify-content:flex-start; }
      .brand{ min-width: unset; }
    }

    .card{
      border-radius: var(--radius);
      background: linear-gradient(180deg, var(--card), var(--card2));
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      overflow:hidden;
      position:relative;
    }

    .card .hd{
      padding: 16px 18px 12px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 12px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
    }

    .card .hd .label{
      display:flex;
      flex-direction:column;
      gap:4px;
    }

    .card .hd h2{
      margin:0;
      font-size: 14px;
      font-weight: 780;
      letter-spacing: .24em;
      text-transform: uppercase;
      color: rgba(255,255,255,.82);
    }

    .card .hd p{
      margin:0;
      color: var(--muted);
      font-size: 12.5px;
      line-height: 1.35;
    }

    .content{ padding: 16px 18px 18px; }

    /* Weather hero */
    .hero{
      display:flex;
      gap: 18px;
      align-items: center;
      flex-wrap: wrap;
    }

    .bigTime{
      display:flex;
      flex-direction:column;
      gap:6px;
      flex: 1 1 300px;
      min-width: 280px;
    }
    .bigTime .time{
      font-size: clamp(32px, 4.5vw, 52px);
      letter-spacing: -0.02em;
      font-weight: 820;
      line-height: 1.05;
    }
    .bigTime .date{
      color: var(--muted);
      font-size: 14px;
      letter-spacing: .2px;
    }

    .wx{
      flex: 1 1 320px;
      min-width: 280px;
      display:flex;
      gap: 14px;
      align-items:center;
      justify-content:flex-end;
    }
    .wxIcon{
      width: 62px; height: 62px;
      flex: 0 0 auto;
      filter: drop-shadow(0 18px 35px rgba(0,0,0,.40));
      opacity:.98;
    }
    .wxMain{
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap: 5px;
    }
    .temp{
      font-size: 34px;
      font-weight: 830;
      letter-spacing: -0.02em;
      line-height: 1;
    }
    .desc{
      font-size: 13.5px;
      color: var(--muted);
      letter-spacing: .2px;
      text-align:right;
      max-width: 360px;
    }
    .smallLine{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(255,255,255,.75);
      text-align:right;
    }

    .statGrid{
      margin-top: 14px;
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
    }
    @media (max-width: 740px){
      .statGrid{ grid-template-columns: repeat(2, 1fr); }
      .wx{ justify-content:flex-start; }
      .wxMain{ align-items:flex-start; }
      .desc, .smallLine{ text-align:left; }
    }

    .stat{
      padding: 12px 12px 11px;
      border-radius: var(--radius2);
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.12);
    }
    .stat .k{
      font-size: 11px;
      letter-spacing: .18em;
      text-transform: uppercase;
      color: rgba(255,255,255,.62);
      margin-bottom: 6px;
      font-weight: 720;
    }
    .stat .v{
      font-size: 16px;
      font-weight: 800;
      letter-spacing: .1px;
      line-height: 1.1;
    }
    .stat .s{
      font-size: 12px;
      color: rgba(255,255,255,.62);
      margin-top: 4px;
      font-family: var(--mono);
    }

    /* Tables */
    .rows{
      display:grid;
      gap: 10px;
    }

    .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      padding: 12px 12px;
      border-radius: var(--radius2);
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.12);
    }

    .left{
      display:flex;
      align-items:center;
      gap: 10px;
      min-width: 0;
    }

    .ico{
      width: 22px; height: 22px;
      flex: 0 0 auto;
      opacity:.95;
      filter: drop-shadow(0 14px 20px rgba(0,0,0,.28));
    }

    .what{
      display:flex;
      flex-direction:column;
      gap: 2px;
      min-width: 0;
    }

    .what b{
      font-size: 13px;
      letter-spacing:.2px;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .what span{
      font-size: 12px;
      color: var(--muted);
      letter-spacing:.2px;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }

    .when{
      font-family: var(--mono);
      font-size: 13px;
      color: rgba(255,255,255,.86);
      white-space: nowrap;
    }

    .fine{
      margin-top: 12px;
      color: rgba(255,255,255,.60);
      font-size: 12px;
      line-height: 1.4;
    }

    .fine a{
      color: rgba(255,255,255,.70);
      text-decoration: none;
      border-bottom: 1px dashed rgba(255,255,255,.35);
    }
    .fine a:hover{ color: rgba(255,255,255,.88); border-bottom-color: rgba(255,255,255,.55); }

    .err{
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: var(--radius2);
      border: 1px solid rgba(255, 107, 107, .28);
      background: rgba(255, 107, 107, .10);
      color: rgba(255,255,255,.88);
      font-size: 12.5px;
      display:none;
    }

    /* tiny sparkle */
    .sparkle{
      position:absolute;
      top: -110px;
      right: -120px;
      width: 260px; height: 260px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.22), transparent 55%),
                  radial-gradient(circle at 60% 70%, rgba(255,255,255,.12), transparent 55%);
      border-radius: 50%;
      filter: blur(1px);
      opacity:.65;
      pointer-events:none;
      transform: rotate(10deg);
    }

    .location-status {
      font-size: 11px;
      color: var(--faint);
      margin-top: 2px;
    }

    /* Sky Clock Styles */
    .clock-container {
      display: flex;
      flex-wrap: wrap;
      gap: 24px;
      align-items: center;
      justify-content: center;
    }

    .sky-clock {
      width: 100%;
      max-width: 360px;
      height: auto;
      filter: drop-shadow(0 20px 40px rgba(0,0,0,.4));
    }

    .clock-legend {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 140px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
      color: var(--muted);
    }

    .legend-swatch {
      width: 20px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid rgba(255,255,255,.2);
      flex-shrink: 0;
    }

    .moon-swatch {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      background: transparent !important;
      border: none !important;
      color: #f0e68c;
    }

    @media (max-width: 600px) {
      .clock-legend {
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: center;
        min-width: unset;
      }
      .legend-item {
        font-size: 11px;
      }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="titleRow">
          <svg class="pin" viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M12 22s7-4.6 7-12a7 7 0 1 0-14 0c0 7.4 7 12 7 12Z" stroke="rgba(255,255,255,.92)" stroke-width="1.8"/>
            <circle cx="12" cy="10" r="2.5" fill="rgba(255,255,255,.92)"/>
          </svg>
          <h1 id="locationName">Loading location...</h1>
        </div>
        <p class="sub">Local dashboard: weather + sun, twilight & moon times.</p>
        <p class="location-status" id="locationStatus"></p>
      </div>

      <div class="controls">
        <div class="pill" title="Local time zone and current offset (handles daylight saving automatically)">
          <small>Time zone</small>
          <span class="mono" id="tzLine">Detecting...</span>
        </div>
        <div class="pill" title="Last successful refresh">
          <small>Updated</small>
          <span class="mono" id="updatedLine">-</span>
        </div>
        <button class="btn" id="refreshBtn" type="button">Refresh</button>
      </div>
    </div>

    <div class="grid">
      <!-- LEFT: Weather + Sun/Twilight -->
      <div class="card">
        <div class="sparkle" aria-hidden="true"></div>
        <div class="hd">
          <div class="label">
            <h2>Now</h2>
            <p id="nowSub">Local time + current conditions</p>
          </div>
        </div>
        <div class="content">
          <div class="hero">
            <div class="bigTime">
              <div class="time" id="clock">-</div>
              <div class="date" id="dateLine">-</div>
            </div>

            <div class="wx">
              <svg class="wxIcon" id="wxIcon" viewBox="0 0 64 64" aria-hidden="true"></svg>
              <div class="wxMain">
                <div class="temp" id="temp">-</div>
                <div class="desc" id="wxDesc">Loading weather...</div>
                <div class="smallLine" id="wxSmall">-</div>
              </div>
            </div>
          </div>

          <div class="statGrid">
            <div class="stat">
              <div class="k">Feels like</div>
              <div class="v" id="feels">-</div>
              <div class="s" id="cloud">Clouds: -</div>
            </div>
            <div class="stat">
              <div class="k">Humidity</div>
              <div class="v" id="hum">-</div>
              <div class="s" id="precip">Precip: -</div>
            </div>
            <div class="stat">
              <div class="k">Wind</div>
              <div class="v" id="wind">-</div>
              <div class="s" id="windDir">Dir: -</div>
            </div>
            <div class="stat">
              <div class="k">Coords</div>
              <div class="v" id="coords">-</div>
              <div class="s" id="elev">TZ offset: -</div>
            </div>
          </div>

          <div class="err" id="errWeather"></div>
        </div>
      </div>

      <!-- RIGHT: Moon -->
      <div class="card">
        <div class="hd">
          <div class="label">
            <h2>Moon</h2>
            <p>Rise & set for today</p>
          </div>
        </div>
        <div class="content">
          <div class="rows" id="moonRows">
            <div class="row">
              <div class="left">
                <svg class="ico" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                  <path d="M3 17c3.2-3.8 6-5.7 9-5.7S17.8 13.2 21 17" stroke="rgba(255,255,255,.82)" stroke-width="1.8" stroke-linecap="round"/>
                  <path d="M12 3v12" stroke="rgba(255,255,255,.82)" stroke-width="1.8" stroke-linecap="round"/>
                  <path d="M8.7 6.4 12 3l3.3 3.4" stroke="rgba(255,255,255,.82)" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <div class="what">
                  <b>Moonrise</b>
                  <span>Next rise time</span>
                </div>
              </div>
              <div class="when" id="moonrise">-</div>
            </div>

            <div class="row">
              <div class="left">
                <svg class="ico" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                  <path d="M3 17c3.2-3.8 6-5.7 9-5.7S17.8 13.2 21 17" stroke="rgba(255,255,255,.82)" stroke-width="1.8" stroke-linecap="round"/>
                  <path d="M12 21V9" stroke="rgba(255,255,255,.82)" stroke-width="1.8" stroke-linecap="round"/>
                  <path d="M8.7 17.6 12 21l3.3-3.4" stroke="rgba(255,255,255,.82)" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <div class="what">
                  <b>Moonset</b>
                  <span>Next set time</span>
                </div>
              </div>
              <div class="when" id="moonset">-</div>
            </div>

            <div class="row">
              <div class="left">
                <svg class="ico" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                  <path d="M16.9 14.2A7.5 7.5 0 0 1 9.8 4.9 7.6 7.6 0 1 0 19 16.1c-.7-.1-1.4-.3-2.1-.6Z" stroke="rgba(255,255,255,.82)" stroke-width="1.8" stroke-linejoin="round"/>
                </svg>
                <div class="what">
                  <b>Phase</b>
                  <span id="moonPhaseSub">-</span>
                </div>
              </div>
              <div class="when" id="moonIllum">-</div>
            </div>
          </div>

          <div class="err" id="errMoon"></div>

          <div class="fine">
            Moon data: U.S. Naval Observatory Astronomical Applications "rstt/oneday" API.
          </div>
        </div>
      </div>

      <!-- CLOCK VISUALIZATION -->
      <div class="card" style="grid-column: 1 / -1;">
        <div class="hd">
          <div class="label">
            <h2>24-Hour Sky Clock</h2>
            <p>Visual timeline of daylight, twilight phases, and moon position</p>
          </div>
        </div>
        <div class="content">
          <div class="clock-container">
            <svg id="skyClock" viewBox="-20 -20 440 440" class="sky-clock">
              <!-- Clock will be drawn by JS -->
            </svg>
            <div class="clock-legend">
              <div class="legend-item"><span class="legend-swatch" style="background: #1a1a2e;"></span> Night</div>
              <div class="legend-item"><span class="legend-swatch" style="background: #2d2d5a;"></span> Astronomical</div>
              <div class="legend-item"><span class="legend-swatch" style="background: #4a4a8a;"></span> Nautical</div>
              <div class="legend-item"><span class="legend-swatch" style="background: #7a6aa0;"></span> Civil</div>
              <div class="legend-item"><span class="legend-swatch" style="background: linear-gradient(90deg, #ffb347, #87ceeb);"></span> Day</div>
              <div class="legend-item"><span class="legend-swatch moon-swatch">☽</span> Moon</div>
            </div>
          </div>
        </div>
      </div>

      <!-- LEFT (full width row): Sun & Twilight -->
      <div class="card" style="grid-column: 1 / -1;">
        <div class="hd">
          <div class="label">
            <h2>Sun + Twilight</h2>
            <p>Morning begin & evening end times for twilight phases</p>
          </div>
        </div>
        <div class="content">
          <div class="rows">
            <div class="row">
              <div class="left">
                <svg class="ico" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                  <path d="M3 17c3.2-3.8 6-5.7 9-5.7S17.8 13.2 21 17" stroke="rgba(255,255,255,.82)" stroke-width="1.8" stroke-linecap="round"/>
                  <path d="M12 3v6" stroke="rgba(255,255,255,.82)" stroke-width="1.8" stroke-linecap="round"/>
                  <path d="M8.7 6.4 12 3l3.3 3.4" stroke="rgba(255,255,255,.82)" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
                  <circle cx="12" cy="12" r="3" fill="rgba(255,255,255,.20)"/>
                </svg>
                <div class="what">
                  <b>Sunrise</b>
                  <span>Sun's upper limb appears</span>
                </div>
              </div>
              <div class="when" id="sunrise">-</div>
            </div>

            <div class="row">
              <div class="left">
                <svg class="ico" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                  <path d="M3 17c3.2-3.8 6-5.7 9-5.7S17.8 13.2 21 17" stroke="rgba(255,255,255,.82)" stroke-width="1.8" stroke-linecap="round"/>
                  <path d="M12 21v-6" stroke="rgba(255,255,255,.82)" stroke-width="1.8" stroke-linecap="round"/>
                  <path d="M8.7 17.6 12 21l3.3-3.4" stroke="rgba(255,255,255,.82)" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
                  <circle cx="12" cy="12" r="3" fill="rgba(255,255,255,.20)"/>
                </svg>
                <div class="what">
                  <b>Sunset</b>
                  <span>Sun disappears below horizon</span>
                </div>
              </div>
              <div class="when" id="sunset">-</div>
            </div>

            <div class="row">
              <div class="left">
                <svg class="ico" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                  <path d="M12 3a8 8 0 0 0 0 16" stroke="rgba(255,255,255,.82)" stroke-width="1.8" stroke-linecap="round"/>
                  <path d="M12 5a6 6 0 0 0 0 12" stroke="rgba(255,255,255,.55)" stroke-width="1.8" stroke-linecap="round"/>
                </svg>
                <div class="what">
                  <b>Civil twilight</b>
                  <span>Morning begin / evening end</span>
                </div>
              </div>
              <div class="when"><span id="civilBegin">-</span> / <span id="civilEnd">-</span></div>
            </div>

            <div class="row">
              <div class="left">
                <svg class="ico" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                  <path d="M12 3a8 8 0 0 0 0 16" stroke="rgba(255,255,255,.82)" stroke-width="1.8" stroke-linecap="round"/>
                  <path d="M12 7a4 4 0 0 0 0 8" stroke="rgba(255,255,255,.55)" stroke-width="1.8" stroke-linecap="round"/>
                </svg>
                <div class="what">
                  <b>Nautical twilight</b>
                  <span>Morning begin / evening end</span>
                </div>
              </div>
              <div class="when"><span id="nauticalBegin">-</span> / <span id="nauticalEnd">-</span></div>
            </div>

            <div class="row">
              <div class="left">
                <svg class="ico" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                  <path d="M12 3a8 8 0 0 0 0 16" stroke="rgba(255,255,255,.82)" stroke-width="1.8" stroke-linecap="round"/>
                  <circle cx="12" cy="12" r="2.2" fill="rgba(255,255,255,.18)"/>
                </svg>
                <div class="what">
                  <b>Astronomical twilight</b>
                  <span>Morning begin / evening end</span>
                </div>
              </div>
              <div class="when"><span id="astroBegin">-</span> / <span id="astroEnd">-</span></div>
            </div>
          </div>

          <div class="err" id="errSun"></div>

          <div class="fine">
            Sun & twilight times: sunrise-sunset.org API (includes civil/nautical/astronomical twilight).
          </div>
        </div>
      </div>
    </div>

    <div class="fine" style="margin-top: 14px;">
      Weather: Open-Meteo (no API key). &nbsp;·&nbsp;
      Tip: if you're offline, astronomy blocks still show the last loaded values - but weather will fail fast.
    </div>
  </div>

<script>
(() => {
  'use strict';

  // Default location: Atlanta, GA (used when geolocation fails)
  const DEFAULT_LOCATION = { name: 'Atlanta, GA', lat: 33.749, lon: -84.388 };

  // Current location state (will be updated by geolocation)
  let LOCATION = { name: 'Loading...', lat: DEFAULT_LOCATION.lat, lon: DEFAULT_LOCATION.lon, tz: null };

  // Store astronomical data for clock visualization
  let clockData = {
    sunrise: null,
    sunset: null,
    civilBegin: null,
    civilEnd: null,
    nauticalBegin: null,
    nauticalEnd: null,
    astroBegin: null,
    astroEnd: null,
    moonrise: null,
    moonset: null,
    moonPhase: null,
    moonIllum: null
  };

  const $ = (id) => document.getElementById(id);

  // Get browser's timezone
  function getBrowserTimezone() {
    try {
      return Intl.DateTimeFormat().resolvedOptions().timeZone;
    } catch (e) {
      return 'America/New_York'; // fallback
    }
  }

  // Get standard timezone offset in hours for USNO API
  function getStandardTzOffsetHours(tz) {
    // Create a date in January (standard time) to get the standard offset
    const jan = new Date(new Date().getFullYear(), 0, 1);
    const janOffset = getOffsetMinutesForDate(jan, tz);
    return Math.round(janOffset / 60);
  }

  function getOffsetMinutesForDate(date, tz) {
    const dtf = new Intl.DateTimeFormat('en-US', {
      timeZone: tz,
      hour12: false,
      year: 'numeric', month: '2-digit', day: '2-digit',
      hour: '2-digit', minute: '2-digit', second: '2-digit'
    });
    const parts = dtf.formatToParts(date);
    const map = {};
    for (const p of parts) map[p.type] = p.value;
    const asUTC = Date.UTC(+map.year, +map.month - 1, +map.day, +map.hour, +map.minute, +map.second);
    return (asUTC - date.getTime()) / 60000;
  }

  function createDateFormatters() {
    const tz = LOCATION.tz;
    return {
      dtfTime: new Intl.DateTimeFormat(undefined, { timeZone: tz, hour: '2-digit', minute: '2-digit', second: '2-digit' }),
      dtfDate: new Intl.DateTimeFormat(undefined, { timeZone: tz, weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }),
      dtfYMD: new Intl.DateTimeFormat('en-CA', { timeZone: tz, year:'numeric', month:'2-digit', day:'2-digit' })
    };
  }

  let formatters = null;

  function partsForTZ(date) {
    const dtf = new Intl.DateTimeFormat('en-US', {
      timeZone: LOCATION.tz,
      hour12: false,
      year: 'numeric', month: '2-digit', day: '2-digit',
      hour: '2-digit', minute: '2-digit', second: '2-digit'
    });
    const parts = dtf.formatToParts(date);
    const map = {};
    for (const p of parts) map[p.type] = p.value;
    return map;
  }

  // Returns offset minutes: local(timeZone) - UTC
  function tzOffsetMinutes(date) {
    return getOffsetMinutesForDate(date, LOCATION.tz);
  }

  function offsetToStr(mins) {
    const sign = mins >= 0 ? '+' : '-';
    const abs = Math.abs(mins);
    const hh = String(Math.floor(abs / 60)).padStart(2,'0');
    const mm = String(abs % 60).padStart(2,'0');
    return `UTC${sign}${hh}:${mm}`;
  }

  function ymdString(date) {
    // en-CA gives YYYY-MM-DD in most modern browsers; fallback to parts if needed.
    const s = formatters.dtfYMD.format(date);
    if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
    const p = partsForTZ(date);
    return `${p.year}-${p.month}-${p.day}`;
  }

  function fmtClock(date) { return formatters.dtfTime.format(date); }
  function fmtDate(date) { return formatters.dtfDate.format(date); }

  function setText(id, value) {
    const el = $(id);
    if (!el) return;
    el.textContent = value;
  }

  function showErr(id, msg) {
    const el = $(id);
    if (!el) return;
    el.style.display = msg ? 'block' : 'none';
    el.textContent = msg || '';
  }

  function degToCompass(deg) {
    if (deg == null || Number.isNaN(deg)) return '-';
    const dirs = ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'];
    const i = Math.round(((deg % 360) / 22.5)) % 16;
    return `${dirs[i]} (${Math.round(deg)}deg)`;
  }

  function round1(x) { return (x == null || Number.isNaN(x)) ? null : Math.round(x*10)/10; }

  const WX_CODE = {
    0:  { t:'Clear sky', i:'clear' },
    1:  { t:'Mainly clear', i:'partly' },
    2:  { t:'Partly cloudy', i:'partly' },
    3:  { t:'Overcast', i:'cloud' },
    45: { t:'Fog', i:'fog' },
    48: { t:'Rime fog', i:'fog' },
    51: { t:'Light drizzle', i:'drizzle' },
    53: { t:'Moderate drizzle', i:'drizzle' },
    55: { t:'Dense drizzle', i:'drizzle' },
    56: { t:'Freezing drizzle (light)', i:'sleet' },
    57: { t:'Freezing drizzle (dense)', i:'sleet' },
    61: { t:'Rain (slight)', i:'rain' },
    63: { t:'Rain (moderate)', i:'rain' },
    65: { t:'Rain (heavy)', i:'rain' },
    66: { t:'Freezing rain (light)', i:'sleet' },
    67: { t:'Freezing rain (heavy)', i:'sleet' },
    71: { t:'Snow fall (slight)', i:'snow' },
    73: { t:'Snow fall (moderate)', i:'snow' },
    75: { t:'Snow fall (heavy)', i:'snow' },
    77: { t:'Snow grains', i:'snow' },
    80: { t:'Rain showers (slight)', i:'showers' },
    81: { t:'Rain showers (moderate)', i:'showers' },
    82: { t:'Rain showers (violent)', i:'showers' },
    85: { t:'Snow showers (slight)', i:'snow' },
    86: { t:'Snow showers (heavy)', i:'snow' },
    95: { t:'Thunderstorm', i:'storm' },
    96: { t:'Thunderstorm w/ hail (slight)', i:'storm' },
    99: { t:'Thunderstorm w/ hail (heavy)', i:'storm' }
  };

  // Open-Meteo weather codes table (WMO interpretation)
  function wxLabel(code) {
    return (WX_CODE[code] && WX_CODE[code].t) ? WX_CODE[code].t : `Weather code ${code}`;
  }

  function svgIcon(kind, isNight) {
    // Inline icons (simple, pretty, no external assets)
    const stroke = 'rgba(255,255,255,.88)';
    const faint = 'rgba(255,255,255,.18)';
    const accent = isNight ? 'rgba(169, 144, 255, .55)' : 'rgba(255, 196, 117, .58)';

    const common = (inner) => `
      <defs>
        <linearGradient id="g1" x1="0" x2="1">
          <stop offset="0" stop-color="${accent}"/>
          <stop offset="1" stop-color="rgba(0, 205, 255, .40)"/>
        </linearGradient>
      </defs>
      ${inner}
    `;

    if (kind === 'clear') return common(isNight
      ? `<path d="M40 17a16 16 0 1 1-14 23.7A14 14 0 1 0 40 17Z" fill="url(#g1)"/><circle cx="18" cy="19" r="2" fill="${faint}"/><circle cx="24" cy="13" r="1.4" fill="${faint}"/><circle cx="14" cy="30" r="1.2" fill="${faint}"/>`
      : `<circle cx="32" cy="30" r="12" fill="url(#g1)"/><g stroke="${stroke}" stroke-width="2" stroke-linecap="round"><path d="M32 8v6"/><path d="M32 46v6"/><path d="M10 30h6"/><path d="M48 30h6"/><path d="M16.5 14.5l4.2 4.2"/><path d="M43.3 41.3l4.2 4.2"/><path d="M47.5 14.5l-4.2 4.2"/><path d="M20.7 41.3l-4.2 4.2"/></g>`
    );

    if (kind === 'partly') return common(isNight
      ? `<path d="M42 18a13 13 0 1 1-11.4 19.2A11 11 0 1 0 42 18Z" fill="url(#g1)"/>
         <path d="M20 45c-6 0-10-3.8-10-8.6 0-4 3-7.4 7.3-8.2A11 11 0 0 1 38 30.5c4.7.3 8.7 3.8 8.7 8.4 0 4.9-4.3 6.1-7.7 6.1H20Z" fill="rgba(255,255,255,.16)" stroke="rgba(255,255,255,.26)"/>`
      : `<circle cx="24" cy="24" r="10" fill="url(#g1)"/>
         <path d="M20 46c-6.4 0-11-4-11-9.2 0-4.2 3.2-7.9 7.8-8.7A12 12 0 0 1 40 30.7c5 .3 9.2 4.1 9.2 9 0 5.2-4.7 6.3-8.1 6.3H20Z" fill="rgba(255,255,255,.16)" stroke="rgba(255,255,255,.26)"/>`
    );

    if (kind === 'cloud') return common(
      `<path d="M18 46c-6.8 0-12-4.2-12-9.8 0-4.8 3.6-8.9 8.7-9.8A14 14 0 0 1 42 30.2c5.6.4 10.3 4.5 10.3 9.8 0 5.7-5 6-8.7 6H18Z" fill="rgba(255,255,255,.16)" stroke="rgba(255,255,255,.26)"/>`
    );

    if (kind === 'fog') return common(
      `<path d="M18 40c-6.8 0-12-4.2-12-9.8 0-4.8 3.6-8.9 8.7-9.8A14 14 0 0 1 42 24.2c5.6.4 10.3 4.5 10.3 9.8 0 5.7-5 6-8.7 6H18Z" fill="rgba(255,255,255,.16)" stroke="rgba(255,255,255,.26)"/>
       <g stroke="rgba(255,255,255,.55)" stroke-width="2" stroke-linecap="round">
         <path d="M12 48h40"/>
         <path d="M18 54h28"/>
       </g>`
    );

    if (kind === 'drizzle') return common(
      `<path d="M18 36c-6.8 0-12-4.2-12-9.8 0-4.8 3.6-8.9 8.7-9.8A14 14 0 0 1 42 20.2c5.6.4 10.3 4.5 10.3 9.8 0 5.7-5 6-8.7 6H18Z" fill="rgba(255,255,255,.16)" stroke="rgba(255,255,255,.26)"/>
       <g stroke="rgba(0,205,255,.65)" stroke-width="2" stroke-linecap="round">
         <path d="M22 42l-2 6"/><path d="M32 42l-2 6"/><path d="M42 42l-2 6"/>
       </g>`
    );

    if (kind === 'rain') return common(
      `<path d="M18 34c-6.8 0-12-4.2-12-9.8 0-4.8 3.6-8.9 8.7-9.8A14 14 0 0 1 42 18.2c5.6.4 10.3 4.5 10.3 9.8 0 5.7-5 6-8.7 6H18Z" fill="rgba(255,255,255,.16)" stroke="rgba(255,255,255,.26)"/>
       <g stroke="rgba(0,205,255,.70)" stroke-width="2.4" stroke-linecap="round">
         <path d="M22 40l-3 10"/><path d="M32 40l-3 10"/><path d="M42 40l-3 10"/>
       </g>`
    );

    if (kind === 'showers') return common(
      `<path d="M18 34c-6.8 0-12-4.2-12-9.8 0-4.8 3.6-8.9 8.7-9.8A14 14 0 0 1 42 18.2c5.6.4 10.3 4.5 10.3 9.8 0 5.7-5 6-8.7 6H18Z" fill="rgba(255,255,255,.16)" stroke="rgba(255,255,255,.26)"/>
       <g stroke="rgba(0,205,255,.75)" stroke-width="2.4" stroke-linecap="round">
         <path d="M20 40l-2 7"/><path d="M28 42l-2 8"/><path d="M38 40l-2 7"/><path d="M46 42l-2 8"/>
       </g>`
    );

    if (kind === 'snow') return common(
      `<path d="M18 34c-6.8 0-12-4.2-12-9.8 0-4.8 3.6-8.9 8.7-9.8A14 14 0 0 1 42 18.2c5.6.4 10.3 4.5 10.3 9.8 0 5.7-5 6-8.7 6H18Z" fill="rgba(255,255,255,.16)" stroke="rgba(255,255,255,.26)"/>
       <g stroke="rgba(255,255,255,.75)" stroke-width="2" stroke-linecap="round">
         <path d="M22 42v10"/><path d="M17 47h10"/><path d="M18.5 44.5l7 7"/><path d="M25.5 44.5l-7 7"/>
         <path d="M40 42v10"/><path d="M35 47h10"/><path d="M36.5 44.5l7 7"/><path d="M43.5 44.5l-7 7"/>
       </g>`
    );

    if (kind === 'sleet') return common(
      `<path d="M18 34c-6.8 0-12-4.2-12-9.8 0-4.8 3.6-8.9 8.7-9.8A14 14 0 0 1 42 18.2c5.6.4 10.3 4.5 10.3 9.8 0 5.7-5 6-8.7 6H18Z" fill="rgba(255,255,255,.16)" stroke="rgba(255,255,255,.26)"/>
       <g stroke="rgba(0,205,255,.70)" stroke-width="2.4" stroke-linecap="round">
         <path d="M24 40l-3 10"/><path d="M40 40l-3 10"/>
       </g>
       <g stroke="rgba(255,255,255,.75)" stroke-width="2" stroke-linecap="round">
         <path d="M32 43v8"/><path d="M28 47h8"/><path d="M29.5 44.5l5 5"/><path d="M34.5 44.5l-5 5"/>
       </g>`
    );

    if (kind === 'storm') return common(
      `<path d="M18 34c-6.8 0-12-4.2-12-9.8 0-4.8 3.6-8.9 8.7-9.8A14 14 0 0 1 42 18.2c5.6.4 10.3 4.5 10.3 9.8 0 5.7-5 6-8.7 6H18Z" fill="rgba(255,255,255,.16)" stroke="rgba(255,255,255,.26)"/>
       <path d="M30 40l-6 11h6l-2 9 9-14h-6l2-6z" fill="rgba(255, 209, 102, .85)"/>
       <g stroke="rgba(0,205,255,.70)" stroke-width="2.4" stroke-linecap="round">
         <path d="M44 42l-2 8"/>
       </g>`
    );

    return common(`<circle cx="32" cy="32" r="12" fill="url(#g1)"/>`);
  }

  function isNightLocal(now, sunriseDate, sunsetDate) {
    if (!(sunriseDate instanceof Date) || !(sunsetDate instanceof Date)) return false;
    const t = now.getTime();
    return (t < sunriseDate.getTime()) || (t > sunsetDate.getTime());
  }

  async function fetchWeather(now) {
    showErr('errWeather', '');
    const url =
      `https://api.open-meteo.com/v1/forecast?latitude=${encodeURIComponent(LOCATION.lat)}&longitude=${encodeURIComponent(LOCATION.lon)}` +
      `&current=temperature_2m,relative_humidity_2m,apparent_temperature,precipitation,weather_code,cloud_cover,wind_speed_10m,wind_direction_10m` +
      `&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=${encodeURIComponent(LOCATION.tz)}`;

    const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
    if (!res.ok) throw new Error(`Open-Meteo HTTP ${res.status}`);
    const data = await res.json();
    const c = data.current || {};

    const code = c.weather_code;
    const label = wxLabel(code);

    setText('temp', (c.temperature_2m == null) ? '-' : `${Math.round(c.temperature_2m)}F`);
    setText('wxDesc', label);
    setText('wxSmall', (c.time ? `Observed @ ${c.time.replace('T',' ')}` : ''));
    setText('feels', (c.apparent_temperature == null) ? '-' : `${Math.round(c.apparent_temperature)}F`);
    setText('hum', (c.relative_humidity_2m == null) ? '-' : `${Math.round(c.relative_humidity_2m)}%`);
    setText('wind', (c.wind_speed_10m == null) ? '-' : `${Math.round(c.wind_speed_10m)} mph`);
    setText('windDir', `Dir: ${degToCompass(c.wind_direction_10m)}`);
    setText('cloud', (c.cloud_cover == null) ? 'Clouds: -' : `Clouds: ${Math.round(c.cloud_cover)}%`);
    setText('precip', (c.precipitation == null) ? 'Precip: -' : `Precip: ${round1(c.precipitation)} in`);

    return { code, label };
  }

  async function fetchSunAndTwilight(now) {
    showErr('errSun', '');
    const dateStr = ymdString(now);
    const url = `https://api.sunrise-sunset.org/json?lat=${encodeURIComponent(LOCATION.lat)}&lng=${encodeURIComponent(LOCATION.lon)}&date=${encodeURIComponent(dateStr)}&formatted=0`;
    const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
    if (!res.ok) throw new Error(`sunrise-sunset.org HTTP ${res.status}`);
    const data = await res.json();
    if (data.status && data.status !== 'OK') throw new Error(`sunrise-sunset.org status: ${data.status}`);

    const r = data.results || {};
    const sunrise = r.sunrise ? new Date(r.sunrise) : null;
    const sunset  = r.sunset  ? new Date(r.sunset)  : null;

    const fmt = (d) => {
      if (!d || isNaN(d.getTime())) return '-';
      return new Intl.DateTimeFormat(undefined, { timeZone: LOCATION.tz, hour: '2-digit', minute:'2-digit' }).format(d);
    };

    setText('sunrise', fmt(sunrise));
    setText('sunset', fmt(sunset));
    setText('civilBegin', fmt(r.civil_twilight_begin ? new Date(r.civil_twilight_begin) : null));
    setText('civilEnd', fmt(r.civil_twilight_end ? new Date(r.civil_twilight_end) : null));
    setText('nauticalBegin', fmt(r.nautical_twilight_begin ? new Date(r.nautical_twilight_begin) : null));
    setText('nauticalEnd', fmt(r.nautical_twilight_end ? new Date(r.nautical_twilight_end) : null));
    setText('astroBegin', fmt(r.astronomical_twilight_begin ? new Date(r.astronomical_twilight_begin) : null));
    setText('astroEnd', fmt(r.astronomical_twilight_end ? new Date(r.astronomical_twilight_end) : null));

    // Store for clock visualization
    clockData.sunrise = sunrise;
    clockData.sunset = sunset;
    clockData.civilBegin = r.civil_twilight_begin ? new Date(r.civil_twilight_begin) : null;
    clockData.civilEnd = r.civil_twilight_end ? new Date(r.civil_twilight_end) : null;
    clockData.nauticalBegin = r.nautical_twilight_begin ? new Date(r.nautical_twilight_begin) : null;
    clockData.nauticalEnd = r.nautical_twilight_end ? new Date(r.nautical_twilight_end) : null;
    clockData.astroBegin = r.astronomical_twilight_begin ? new Date(r.astronomical_twilight_begin) : null;
    clockData.astroEnd = r.astronomical_twilight_end ? new Date(r.astronomical_twilight_end) : null;

    return { sunrise, sunset };
  }

  async function fetchMoon(now, isDst) {
    showErr('errMoon', '');
    const dateStr = ymdString(now);

    // USNO expects tz = standard time zone offset, with DST passed separately.
    const tz = getStandardTzOffsetHours(LOCATION.tz);
    const url = `https://aa.usno.navy.mil/api/rstt/oneday?date=${encodeURIComponent(dateStr)}&coords=${encodeURIComponent(`${LOCATION.lat},${LOCATION.lon}`)}&tz=${encodeURIComponent(tz)}&dst=${encodeURIComponent(isDst)}`;

    const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
    if (!res.ok) throw new Error(`USNO HTTP ${res.status}`);
    const data = await res.json();

    const d = data?.properties?.data || {};
    const moondata = d.moondata || [];
    const curphase = d.curphase || null;
    const fracillum = d.fracillum || null;

    const pick = (arr, needle) => {
      const it = arr.find(x => (x.phen || '').toLowerCase().includes(needle));
      return it ? it.time : null;
    };

    // Phenomenon labels vary; "rise"/"set" matching is robust enough.
    const rise = pick(moondata, 'rise');
    const set = pick(moondata, 'set');

    setText('moonrise', rise || '-');
    setText('moonset', set || '-');
    setText('moonPhaseSub', curphase ? `Current: ${curphase}` : '-');
    setText('moonIllum', fracillum ? fracillum : '-');

    // Store for clock visualization - parse time strings like "6:35 AM" to Date objects
    clockData.moonrise = parseUSNOTime(rise, now);
    clockData.moonset = parseUSNOTime(set, now);
    clockData.moonPhase = curphase;
    clockData.moonIllum = fracillum;
  }

  // Parse USNO time string like "14:29" (24h) or "6:35 AM" (12h) to a Date object for today
  function parseUSNOTime(timeStr, referenceDate) {
    if (!timeStr || timeStr === '-') return null;

    let hours, minutes;

    // Try 12-hour format with AM/PM first
    const match12 = timeStr.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i);
    if (match12) {
      hours = parseInt(match12[1], 10);
      minutes = parseInt(match12[2], 10);
      const period = match12[3].toUpperCase();
      if (period === 'PM' && hours !== 12) hours += 12;
      if (period === 'AM' && hours === 12) hours = 0;
    } else {
      // Try 24-hour format (e.g., "14:29")
      const match24 = timeStr.match(/(\d{1,2}):(\d{2})/);
      if (!match24) return null;
      hours = parseInt(match24[1], 10);
      minutes = parseInt(match24[2], 10);
    }

    const d = new Date(referenceDate);
    // Set time in local timezone
    const parts = partsForTZ(referenceDate);
    d.setFullYear(+parts.year, +parts.month - 1, +parts.day);
    d.setHours(hours, minutes, 0, 0);
    return d;
  }

  let lastClockDrawSecond = -1;

  function updateClock() {
    if (!formatters) return;
    const now = new Date();
    setText('clock', fmtClock(now));
    setText('dateLine', fmtDate(now));

    // Redraw sky clock every 10 seconds to update current time marker
    const currentSecond = Math.floor(now.getTime() / 10000);
    if (currentSecond !== lastClockDrawSecond) {
      lastClockDrawSecond = currentSecond;
      drawSkyClock();
    }
  }

  // ===== SKY CLOCK VISUALIZATION =====

  // Convert a Date to angle on 24-hour clock (0° = midnight at top, clockwise)
  function timeToAngle(date) {
    if (!date || isNaN(date.getTime())) return null;
    const parts = partsForTZ(date);
    const hours = +parts.hour + (+parts.minute / 60) + (+parts.second / 3600);
    // 24 hours = 360°, so 1 hour = 15°
    // Midnight (0:00) is at top (0°/360°)
    return (hours / 24) * 360;
  }

  // Create SVG arc path for a band between two angles
  function describeArc(cx, cy, innerR, outerR, startAngle, endAngle) {
    // Convert angles to radians, adjust so 0° is at top
    const toRad = (deg) => (deg - 90) * Math.PI / 180;

    // Handle wrap-around (e.g., 350° to 10°)
    let sweep = endAngle - startAngle;
    if (sweep < 0) sweep += 360;

    const largeArc = sweep > 180 ? 1 : 0;

    const startRad = toRad(startAngle);
    const endRad = toRad(endAngle);

    const x1Outer = cx + outerR * Math.cos(startRad);
    const y1Outer = cy + outerR * Math.sin(startRad);
    const x2Outer = cx + outerR * Math.cos(endRad);
    const y2Outer = cy + outerR * Math.sin(endRad);

    const x1Inner = cx + innerR * Math.cos(startRad);
    const y1Inner = cy + innerR * Math.sin(startRad);
    const x2Inner = cx + innerR * Math.cos(endRad);
    const y2Inner = cy + innerR * Math.sin(endRad);

    // Path: outer arc, line to inner, inner arc (reverse), close
    return [
      `M ${x1Outer} ${y1Outer}`,
      `A ${outerR} ${outerR} 0 ${largeArc} 1 ${x2Outer} ${y2Outer}`,
      `L ${x2Inner} ${y2Inner}`,
      `A ${innerR} ${innerR} 0 ${largeArc} 0 ${x1Inner} ${y1Inner}`,
      'Z'
    ].join(' ');
  }

  // Get point on circle at given angle and radius
  function pointOnCircle(cx, cy, r, angle) {
    const rad = (angle - 90) * Math.PI / 180;
    return { x: cx + r * Math.cos(rad), y: cy + r * Math.sin(rad) };
  }

  // Draw moon phase icon - accurate representation
  function getMoonPhaseSVG(phase, illum, size) {
    // Parse illumination like "45%" to number
    let illumPct = 50;
    if (illum) {
      const match = illum.match(/(\d+)/);
      if (match) illumPct = parseInt(match[1], 10);
    }

    const r = size / 2;
    const cx = r, cy = r;

    // Determine phase from name
    const phaseLower = (phase || '').toLowerCase();
    const isNew = phaseLower.includes('new');
    const isFull = phaseLower.includes('full');
    const isFirstQuarter = phaseLower.includes('first quarter');
    const isLastQuarter = phaseLower.includes('last quarter') || phaseLower.includes('third quarter');
    const isWaxingCrescent = phaseLower.includes('waxing crescent');
    const isWaxingGibbous = phaseLower.includes('waxing gibbous');
    const isWaningGibbous = phaseLower.includes('waning gibbous');
    const isWaningCrescent = phaseLower.includes('waning crescent');

    // Fallback detection if specific phase not found
    const isWaxing = phaseLower.includes('waxing') || phaseLower.includes('first');
    const isWaning = phaseLower.includes('waning') || phaseLower.includes('last') || phaseLower.includes('third');

    const darkFill = 'rgba(30,30,50,.85)';
    const lightFill = '#f5f0d0';
    const strokeColor = 'rgba(255,255,255,.35)';

    if (isNew) {
      // New moon - dark with subtle outline
      return `<circle cx="${cx}" cy="${cy}" r="${r-1}" fill="${darkFill}" stroke="${strokeColor}" stroke-width="1.5"/>`;
    }

    if (isFull) {
      // Full moon - fully illuminated
      return `<circle cx="${cx}" cy="${cy}" r="${r-1}" fill="${lightFill}" stroke="${strokeColor}" stroke-width="1"/>`;
    }

    // For partial phases, we draw the moon using a path
    // The terminator (shadow line) is drawn as an ellipse arc
    // illumPct determines how much is lit: 0% = new, 50% = quarter, 100% = full

    const rad = r - 1;

    // Calculate the terminator curve
    // At 50% (quarter), terminator is a straight line (ellipse rx = 0)
    // At 0% or 100%, terminator matches the outer edge
    // The curve bulges left or right depending on crescent vs gibbous

    let terminatorRx;
    let isGibbous = illumPct > 50;

    if (isGibbous) {
      // Gibbous: more than half lit, terminator curves inward on dark side
      terminatorRx = ((illumPct - 50) / 50) * rad;
    } else {
      // Crescent: less than half lit, terminator curves inward on lit side
      terminatorRx = ((50 - illumPct) / 50) * rad;
    }

    // Determine which side is illuminated based on phase
    // Northern hemisphere convention:
    // - Waxing (growing): right side illuminated
    // - Waning (shrinking): left side illuminated
    const rightSideLit = isWaxing || isWaxingCrescent || isWaxingGibbous || isFirstQuarter;
    const leftSideLit = isWaning || isWaningCrescent || isWaningGibbous || isLastQuarter;

    // Default to right side lit if we can't determine (early waxing)
    const litOnRight = rightSideLit || (!leftSideLit && illumPct < 50);

    // Build the moon path
    // We draw the full circle, then overlay the shadow portion

    if (litOnRight) {
      // Right side is illuminated
      if (isGibbous || illumPct >= 50) {
        // Gibbous or quarter: draw dark crescent on left
        // Dark area: left arc of circle + terminator curve
        return `
          <circle cx="${cx}" cy="${cy}" r="${rad}" fill="${lightFill}" stroke="${strokeColor}" stroke-width="1"/>
          <path d="M ${cx} ${cy - rad}
                   A ${rad} ${rad} 0 0 0 ${cx} ${cy + rad}
                   A ${terminatorRx} ${rad} 0 0 1 ${cx} ${cy - rad} Z"
                fill="${darkFill}"/>
        `;
      } else {
        // Crescent: draw light crescent on right
        // Light area: right arc of circle + terminator curve
        return `
          <circle cx="${cx}" cy="${cy}" r="${rad}" fill="${darkFill}" stroke="${strokeColor}" stroke-width="1"/>
          <path d="M ${cx} ${cy - rad}
                   A ${rad} ${rad} 0 0 1 ${cx} ${cy + rad}
                   A ${terminatorRx} ${rad} 0 0 1 ${cx} ${cy - rad} Z"
                fill="${lightFill}"/>
        `;
      }
    } else {
      // Left side is illuminated (waning)
      if (isGibbous || illumPct >= 50) {
        // Gibbous or quarter: draw dark crescent on right
        return `
          <circle cx="${cx}" cy="${cy}" r="${rad}" fill="${lightFill}" stroke="${strokeColor}" stroke-width="1"/>
          <path d="M ${cx} ${cy - rad}
                   A ${rad} ${rad} 0 0 1 ${cx} ${cy + rad}
                   A ${terminatorRx} ${rad} 0 0 0 ${cx} ${cy - rad} Z"
                fill="${darkFill}"/>
        `;
      } else {
        // Crescent: draw light crescent on left
        return `
          <circle cx="${cx}" cy="${cy}" r="${rad}" fill="${darkFill}" stroke="${strokeColor}" stroke-width="1"/>
          <path d="M ${cx} ${cy - rad}
                   A ${rad} ${rad} 0 0 0 ${cx} ${cy + rad}
                   A ${terminatorRx} ${rad} 0 0 0 ${cx} ${cy - rad} Z"
                fill="${lightFill}"/>
        `;
      }
    }
  }

  // Main function to draw the sky clock
  function drawSkyClock() {
    const svg = $('skyClock');
    if (!svg) return;

    const cx = 200, cy = 200;
    const outerR = 180;

    // Colors for each band (wedge-style from center)
    const colors = {
      night: '#1a1a2e',
      astro: '#2d2d5a',
      nautical: '#4a4a8a',
      civil: '#7a6aa0',
      day: 'url(#dayGradient)'
    };

    let paths = [];
    let currentTimeMarker = '';
    let moonMarker = '';
    let hourMarkers = '';

    // Gradient definition for day
    const defs = `
      <defs>
        <linearGradient id="dayGradient" x1="0%" y1="0%" x2="100%" y2="100%">
          <stop offset="0%" stop-color="#87ceeb"/>
          <stop offset="50%" stop-color="#fffacd"/>
          <stop offset="100%" stop-color="#ffb347"/>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
          <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
          <feMerge>
            <feMergeNode in="coloredBlur"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
      </defs>
    `;

    // Get angles for all times
    const angles = {
      astroBegin: timeToAngle(clockData.astroBegin),
      nauticalBegin: timeToAngle(clockData.nauticalBegin),
      civilBegin: timeToAngle(clockData.civilBegin),
      sunrise: timeToAngle(clockData.sunrise),
      sunset: timeToAngle(clockData.sunset),
      civilEnd: timeToAngle(clockData.civilEnd),
      nauticalEnd: timeToAngle(clockData.nauticalEnd),
      astroEnd: timeToAngle(clockData.astroEnd),
      moonrise: timeToAngle(clockData.moonrise),
      moonset: timeToAngle(clockData.moonset)
    };

    // Check if we have valid data
    const hasData = angles.sunrise !== null && angles.sunset !== null;

    if (hasData) {
      // Draw wedges from center outward for each time period
      // Each wedge represents a time period colored by what type of light exists

      // 1. NIGHT - from astronomical twilight end (evening) to astronomical twilight begin (morning)
      // This wraps around midnight
      if (angles.astroEnd !== null && angles.astroBegin !== null) {
        paths.push(`<path d="${describeArc(cx, cy, 0, outerR, angles.astroEnd, angles.astroBegin)}" fill="${colors.night}" opacity="0.95"/>`);
      }

      // 2. ASTRONOMICAL TWILIGHT - morning (astro begin to nautical begin)
      if (angles.astroBegin !== null && angles.nauticalBegin !== null) {
        paths.push(`<path d="${describeArc(cx, cy, 0, outerR, angles.astroBegin, angles.nauticalBegin)}" fill="${colors.astro}" opacity="0.95"/>`);
      }

      // 3. NAUTICAL TWILIGHT - morning (nautical begin to civil begin)
      if (angles.nauticalBegin !== null && angles.civilBegin !== null) {
        paths.push(`<path d="${describeArc(cx, cy, 0, outerR, angles.nauticalBegin, angles.civilBegin)}" fill="${colors.nautical}" opacity="0.95"/>`);
      }

      // 4. CIVIL TWILIGHT - morning (civil begin to sunrise)
      if (angles.civilBegin !== null && angles.sunrise !== null) {
        paths.push(`<path d="${describeArc(cx, cy, 0, outerR, angles.civilBegin, angles.sunrise)}" fill="${colors.civil}" opacity="0.95"/>`);
      }

      // 5. DAY - sunrise to sunset
      paths.push(`<path d="${describeArc(cx, cy, 0, outerR, angles.sunrise, angles.sunset)}" fill="${colors.day}" opacity="0.95"/>`);

      // 6. CIVIL TWILIGHT - evening (sunset to civil end)
      if (angles.sunset !== null && angles.civilEnd !== null) {
        paths.push(`<path d="${describeArc(cx, cy, 0, outerR, angles.sunset, angles.civilEnd)}" fill="${colors.civil}" opacity="0.95"/>`);
      }

      // 7. NAUTICAL TWILIGHT - evening (civil end to nautical end)
      if (angles.civilEnd !== null && angles.nauticalEnd !== null) {
        paths.push(`<path d="${describeArc(cx, cy, 0, outerR, angles.civilEnd, angles.nauticalEnd)}" fill="${colors.nautical}" opacity="0.95"/>`);
      }

      // 8. ASTRONOMICAL TWILIGHT - evening (nautical end to astro end)
      if (angles.nauticalEnd !== null && angles.astroEnd !== null) {
        paths.push(`<path d="${describeArc(cx, cy, 0, outerR, angles.nauticalEnd, angles.astroEnd)}" fill="${colors.astro}" opacity="0.95"/>`);
      }

      // Add subtle dividing lines at key transitions
      const dividerAngles = [
        { angle: angles.astroBegin, label: null },
        { angle: angles.nauticalBegin, label: null },
        { angle: angles.civilBegin, label: null },
        { angle: angles.sunrise, label: 'Sunrise' },
        { angle: angles.sunset, label: 'Sunset' },
        { angle: angles.civilEnd, label: null },
        { angle: angles.nauticalEnd, label: null },
        { angle: angles.astroEnd, label: null }
      ];

      dividerAngles.forEach(({ angle, label }) => {
        if (angle !== null) {
          const p1 = pointOnCircle(cx, cy, 0, angle);
          const p2 = pointOnCircle(cx, cy, outerR, angle);
          paths.push(`<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}"
            stroke="rgba(255,255,255,.15)" stroke-width="1"/>`);
        }
      });

    } else {
      // No data yet - draw placeholder
      paths.push(`<circle cx="${cx}" cy="${cy}" r="${outerR}" fill="${colors.night}" opacity="0.6"/>`);
      paths.push(`<text x="${cx}" y="${cy}" text-anchor="middle" fill="rgba(255,255,255,.5)" font-size="14">Loading...</text>`);
    }

    // Hour markers around the edge
    for (let h = 0; h < 24; h++) {
      const angle = (h / 24) * 360;
      const isMainHour = h % 6 === 0;
      const markerR1 = outerR + 5;
      const markerR2 = isMainHour ? outerR + 18 : outerR + 12;
      const p1 = pointOnCircle(cx, cy, markerR1, angle);
      const p2 = pointOnCircle(cx, cy, markerR2, angle);

      hourMarkers += `<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}"
        stroke="rgba(255,255,255,${isMainHour ? '.6' : '.3'})" stroke-width="${isMainHour ? '2' : '1'}"/>`;

      // Labels for main hours
      if (isMainHour) {
        const labelR = outerR + 28;
        const p = pointOnCircle(cx, cy, labelR, angle);
        const label = h === 0 ? '12AM' : h === 6 ? '6AM' : h === 12 ? '12PM' : '6PM';
        hourMarkers += `<text x="${p.x}" y="${p.y}" text-anchor="middle" dominant-baseline="middle"
          fill="rgba(255,255,255,.7)" font-size="11" font-weight="600">${label}</text>`;
      }
    }

    // Current time marker
    const now = new Date();
    const nowAngle = timeToAngle(now);
    if (nowAngle !== null) {
      const p1 = pointOnCircle(cx, cy, 0, nowAngle);
      const p2 = pointOnCircle(cx, cy, outerR + 3, nowAngle);
      currentTimeMarker = `
        <line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}"
          stroke="rgba(255,255,255,.9)" stroke-width="2" filter="url(#glow)"/>
        <circle cx="${p2.x}" cy="${p2.y}" r="4" fill="#fff" filter="url(#glow)"/>
      `;
    }

    // Moon visibility arc - shows when moon is above horizon
    let moonArc = '';
    if (angles.moonrise !== null && angles.moonset !== null) {
      // Draw arc from moonrise to moonset
      moonArc = `<path d="${describeArc(cx, cy, outerR + 8, outerR + 14, angles.moonrise, angles.moonset)}"
        fill="rgba(240, 230, 140, .35)" stroke="rgba(240, 230, 140, .6)" stroke-width="1"/>`;
    }

    // Moon marker - position based on current time relative to rise/set
    if (clockData.moonrise || clockData.moonset) {
      // Calculate moon's current position
      // If moon is up (between rise and set), interpolate position
      // Otherwise show at rise or set location with dimmed appearance

      let moonAngle = null;
      let moonVisible = false;

      const nowMs = now.getTime();
      const riseMs = clockData.moonrise ? clockData.moonrise.getTime() : null;
      const setMs = clockData.moonset ? clockData.moonset.getTime() : null;

      if (riseMs && setMs) {
        if (riseMs < setMs) {
          // Normal case: rise before set
          if (nowMs >= riseMs && nowMs <= setMs) {
            // Moon is up - interpolate
            const progress = (nowMs - riseMs) / (setMs - riseMs);
            const riseAngle = angles.moonrise;
            const setAngle = angles.moonset;
            let angleDiff = setAngle - riseAngle;
            if (angleDiff < 0) angleDiff += 360;
            moonAngle = riseAngle + progress * angleDiff;
            moonVisible = true;
          } else {
            moonAngle = nowMs < riseMs ? angles.moonrise : angles.moonset;
          }
        } else {
          // Rise after set (moon visible overnight, wrapping)
          if (nowMs >= riseMs || nowMs <= setMs) {
            moonVisible = true;
            if (nowMs >= riseMs) {
              // After rise, before midnight
              const msToMidnight = new Date(now).setHours(24,0,0,0) - nowMs;
              const riseToMidnight = new Date(clockData.moonrise).setHours(24,0,0,0) - riseMs;
              const progress = 1 - (msToMidnight / riseToMidnight);
              const angleDiff = (360 - angles.moonrise + angles.moonset);
              moonAngle = (angles.moonrise + progress * angleDiff * 0.5) % 360;
            } else {
              // After midnight, before set
              const progress = nowMs / setMs;
              moonAngle = progress * angles.moonset;
            }
          } else {
            moonAngle = angles.moonrise;
          }
        }
      } else if (riseMs) {
        moonAngle = angles.moonrise;
        moonVisible = nowMs >= riseMs;
      } else if (setMs) {
        moonAngle = angles.moonset;
        moonVisible = nowMs <= setMs;
      }

      if (moonAngle !== null) {
        const moonR = outerR * 0.5; // Position moon in middle area of clock
        const mp = pointOnCircle(cx, cy, moonR, moonAngle);
        const moonSize = 42;

        moonMarker = `
          <g transform="translate(${mp.x - moonSize/2}, ${mp.y - moonSize/2})"
             opacity="${moonVisible ? '1' : '0.5'}" filter="${moonVisible ? 'url(#glow)' : ''}">
            ${getMoonPhaseSVG(clockData.moonPhase, clockData.moonIllum, moonSize)}
          </g>
        `;
      }
    }

    // Add clock border and center
    const border = `
      <circle cx="${cx}" cy="${cy}" r="${outerR}" fill="none" stroke="rgba(255,255,255,.25)" stroke-width="2"/>
      <circle cx="${cx}" cy="${cy}" r="6" fill="rgba(255,255,255,.3)"/>
    `;

    // Add sunrise/sunset icons on the edge
    let sunMarkers = '';
    if (hasData) {
      const sunriseP = pointOnCircle(cx, cy, outerR - 15, angles.sunrise);
      const sunsetP = pointOnCircle(cx, cy, outerR - 15, angles.sunset);
      sunMarkers = `
        <circle cx="${sunriseP.x}" cy="${sunriseP.y}" r="8" fill="#ffb347" opacity="0.9" filter="url(#glow)"/>
        <circle cx="${sunsetP.x}" cy="${sunsetP.y}" r="8" fill="#ff7b54" opacity="0.9" filter="url(#glow)"/>
      `;
    }

    // Assemble final SVG
    svg.innerHTML = `
      ${defs}
      <g>
        ${paths.join('\n')}
      </g>
      ${border}
      ${moonArc}
      ${hourMarkers}
      ${sunMarkers}
      ${moonMarker}
      ${currentTimeMarker}
    `;
  }

  function setTZLine(now) {
    const off = tzOffsetMinutes(now);
    const offStr = offsetToStr(off);
    const standardOff = getStandardTzOffsetHours(LOCATION.tz) * 60;
    const dst = (off !== standardOff) ? 'Daylight' : 'Standard';
    setText('tzLine', `${LOCATION.tz} - ${offStr} - ${dst}`);
    setText('elev', `TZ offset: ${offStr}`);
    return { off, isDst: (dst === 'Daylight') };
  }

  function stampUpdated(now) {
    const t = new Intl.DateTimeFormat(undefined, { timeZone: LOCATION.tz, hour:'2-digit', minute:'2-digit', second:'2-digit' }).format(now);
    setText('updatedLine', t);
  }

  async function refreshAll() {
    const now = new Date();
    const tzInfo = setTZLine(now);
    setText('coords', `${LOCATION.lat.toFixed(4)}, ${LOCATION.lon.toFixed(4)}`);

    setText('nowSub', `Local time + current conditions - ${ymdString(now)}`);

    let sun = { sunrise: null, sunset: null };
    try {
      sun = await fetchSunAndTwilight(now);
    } catch (e) {
      showErr('errSun', `Sun/twilight failed: ${e.message}`);
    }

    try {
      const wx = await fetchWeather(now);
      const iconKind = (WX_CODE[wx.code]?.i) || 'cloud';
      const night = isNightLocal(now, sun.sunrise, sun.sunset);
      $('wxIcon').innerHTML = svgIcon(iconKind, night);
    } catch (e) {
      showErr('errWeather', `Weather failed: ${e.message} (check internet)`);
      // Still render an icon
      $('wxIcon').innerHTML = svgIcon('cloud', true);
      setText('wxDesc', 'Weather unavailable');
      setText('wxSmall', '');
    }

    try {
      await fetchMoon(now, tzInfo.isDst);
    } catch (e) {
      showErr('errMoon', `Moon data failed: ${e.message}`);
    }

    // Draw the sky clock visualization
    drawSkyClock();

    stampUpdated(new Date());
  }

  // Reverse geocode to get location name
  async function reverseGeocode(lat, lon) {
    try {
      const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=10`;
      const res = await fetch(url, {
        headers: { 'Accept': 'application/json', 'User-Agent': 'SkyWeatherInfographic/1.0' }
      });
      if (!res.ok) return null;
      const data = await res.json();

      const addr = data.address || {};
      const city = addr.city || addr.town || addr.village || addr.municipality || addr.county || '';
      const state = addr.state || addr.region || '';

      if (city && state) {
        // Try to get state abbreviation for US states
        const stateAbbr = getStateAbbreviation(state);
        return `${city}, ${stateAbbr || state}`;
      } else if (city) {
        return city;
      } else if (data.display_name) {
        // Use first two parts of display name
        const parts = data.display_name.split(',').slice(0, 2).map(s => s.trim());
        return parts.join(', ');
      }
      return null;
    } catch (e) {
      console.warn('Reverse geocoding failed:', e);
      return null;
    }
  }

  // US state abbreviations
  function getStateAbbreviation(stateName) {
    const states = {
      'Alabama': 'AL', 'Alaska': 'AK', 'Arizona': 'AZ', 'Arkansas': 'AR', 'California': 'CA',
      'Colorado': 'CO', 'Connecticut': 'CT', 'Delaware': 'DE', 'Florida': 'FL', 'Georgia': 'GA',
      'Hawaii': 'HI', 'Idaho': 'ID', 'Illinois': 'IL', 'Indiana': 'IN', 'Iowa': 'IA',
      'Kansas': 'KS', 'Kentucky': 'KY', 'Louisiana': 'LA', 'Maine': 'ME', 'Maryland': 'MD',
      'Massachusetts': 'MA', 'Michigan': 'MI', 'Minnesota': 'MN', 'Mississippi': 'MS', 'Missouri': 'MO',
      'Montana': 'MT', 'Nebraska': 'NE', 'Nevada': 'NV', 'New Hampshire': 'NH', 'New Jersey': 'NJ',
      'New Mexico': 'NM', 'New York': 'NY', 'North Carolina': 'NC', 'North Dakota': 'ND', 'Ohio': 'OH',
      'Oklahoma': 'OK', 'Oregon': 'OR', 'Pennsylvania': 'PA', 'Rhode Island': 'RI', 'South Carolina': 'SC',
      'South Dakota': 'SD', 'Tennessee': 'TN', 'Texas': 'TX', 'Utah': 'UT', 'Vermont': 'VT',
      'Virginia': 'VA', 'Washington': 'WA', 'West Virginia': 'WV', 'Wisconsin': 'WI', 'Wyoming': 'WY',
      'District of Columbia': 'DC'
    };
    return states[stateName] || null;
  }

  // Get user's location
  async function initLocation() {
    setText('locationStatus', 'Detecting your location...');

    // Use browser timezone
    LOCATION.tz = getBrowserTimezone();

    if ('geolocation' in navigator) {
      try {
        const position = await new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject, {
            enableHighAccuracy: false,
            timeout: 10000,
            maximumAge: 300000 // 5 minutes cache
          });
        });

        LOCATION.lat = position.coords.latitude;
        LOCATION.lon = position.coords.longitude;

        // Try to get location name via reverse geocoding
        const name = await reverseGeocode(LOCATION.lat, LOCATION.lon);
        LOCATION.name = name || `${LOCATION.lat.toFixed(2)}, ${LOCATION.lon.toFixed(2)}`;

        setText('locationStatus', 'Location detected from browser');

      } catch (err) {
        console.warn('Geolocation failed:', err.message);
        // Use default location (Atlanta, GA)
        LOCATION.lat = DEFAULT_LOCATION.lat;
        LOCATION.lon = DEFAULT_LOCATION.lon;
        LOCATION.name = DEFAULT_LOCATION.name;
        setText('locationStatus', 'Using default location (geolocation unavailable)');
      }
    } else {
      // Geolocation not supported
      LOCATION.lat = DEFAULT_LOCATION.lat;
      LOCATION.lon = DEFAULT_LOCATION.lon;
      LOCATION.name = DEFAULT_LOCATION.name;
      setText('locationStatus', 'Using default location (geolocation not supported)');
    }

    // Update UI with location name
    setText('locationName', LOCATION.name);
    document.title = `${LOCATION.name} - Sky & Weather`;

    // Initialize formatters after timezone is set
    formatters = createDateFormatters();
  }

  // Initialize
  async function init() {
    await initLocation();
    updateClock();
    setInterval(updateClock, 1000);
    $('refreshBtn').addEventListener('click', () => refreshAll());
    refreshAll();
  }

  init();

})();
</script>
</body>
</html>
