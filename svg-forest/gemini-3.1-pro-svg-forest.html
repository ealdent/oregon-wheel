<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bioluminescent Fungi Forest - Pure SVG</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050510;
            touch-action: none; /* Prevent all mobile browser defaults */
            user-select: none;
            -webkit-user-select: none;
        }

        #game-svg {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Layer */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to document */
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 20px;
            box-sizing: border-box;
        }

        .joystick-zone {
            width: 50%;
            height: 100%;
            position: absolute;
            top: 0;
            pointer-events: auto;
        }
        #left-zone { left: 0; }
        #right-zone { right: 0; }

        .joystick-base {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            display: none;
            pointer-events: none;
        }

        .joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.6);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.7);
            font-family: sans-serif;
            font-size: 14px;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>

    <svg id="game-svg" preserveAspectRatio="xMidYMid slice">
        <defs>
            <linearGradient id="skyGrad" x1="0" y1="0" x2="0" y2="1">
                <stop offset="0%" stop-color="#020111" />
                <stop offset="100%" stop-color="#20124d" />
            </linearGradient>
            <linearGradient id="groundGrad" x1="0" y1="0" x2="0" y2="1">
                <stop offset="0%" stop-color="#0a2a2a" />
                <stop offset="100%" stop-color="#020808" />
            </linearGradient>

            <g id="mushroom">
                <path d="M -8 0 Q -5 -40 0 -60 Q 5 -40 8 0 Z" fill="#1a4c40" />
                <ellipse cx="0" cy="-60" rx="35" ry="10" fill="#0d8e7b" />
                <path d="M -40 -60 C -40 -100 40 -100 40 -60 Z" fill="#00ffcc" opacity="0.85" />
                <circle cx="-15" cy="-75" r="4" fill="#ffffff" filter="blur(1px)"/>
                <circle cx="10" cy="-85" r="6" fill="#ffffff" filter="blur(1px)"/>
                <circle cx="20" cy="-65" r="3" fill="#ffffff" filter="blur(1px)"/>
            </g>

            <g id="spire">
                <polygon points="-15,0 0,-140 15,0" fill="url(#spireGrad)" />
                <polygon points="-5,0 0,-140 5,0" fill="#ff66ff" opacity="0.6" />
                <circle cx="0" cy="-145" r="8" fill="#ff00aa" filter="blur(2px)"/>
            </g>
            <linearGradient id="spireGrad" x1="0" y1="0" x2="0" y2="1">
                <stop offset="0%" stop-color="#ff0066" />
                <stop offset="100%" stop-color="#220033" />
            </linearGradient>

            <g id="spore">
                <circle cx="0" cy="-30" r="15" fill="url(#sporeGrad)" opacity="0.7"/>
                <circle cx="0" cy="-30" r="5" fill="#ffffff"/>
            </g>
            <radialGradient id="sporeGrad">
                <stop offset="0%" stop-color="#ffaa00" />
                <stop offset="100%" stop-color="#ff3300" stop-opacity="0" />
            </radialGradient>
        </defs>

        <g id="world-container">
            <rect id="sky" x="-50%" y="-100%" width="200%" height="150%" fill="url(#skyGrad)" />
            <rect id="ground" x="-50%" y="0" width="200%" height="150%" fill="url(#groundGrad)" />
            <g id="scene"></g>
        </g>
    </svg>

    <div id="ui-layer">
        <div id="instructions">
            Desktop: WASD / Arrows + Mouse Drag<br>
            Mobile: Left & Right Virtual Joysticks
        </div>
        <div id="crosshair"></div>
        <div id="left-zone" class="joystick-zone"></div>
        <div id="right-zone" class="joystick-zone"></div>

        <div id="joy-left-base" class="joystick-base"><div id="joy-left-knob" class="joystick-knob"></div></div>
        <div id="joy-right-base" class="joystick-base"><div id="joy-right-knob" class="joystick-knob"></div></div>
    </div>

<script>
    /** --- Configuration & State --- */
    const svg = document.getElementById('game-svg');
    const scene = document.getElementById('scene');
    const worldContainer = document.getElementById('world-container');

    // Engine constants
    const POOL_SIZE = 150;
    const CHUNK_SIZE = 400;
    const DRAW_DISTANCE = 1800;
    const CAMERA_HEIGHT = 60;

    let fov = 400;
    let cx = 0, cy = 0;

    // Player state
    const player = {
        x: 0,
        z: 0,
        rot: 0,
        walkDist: 0, // Used for head bob
        speed: 0,
        turnSpeed: 0,
        strafeSpeed: 0
    };

    // Input state
    const keys = { w: false, a: false, s: false, d: false, ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
    let isDragging = false;
    let previousMouseX = 0;

    // DOM Object Pool
    const domPool = [];
    const propTypes = ['#mushroom', '#spire', '#spore', '#mushroom'];

    // Infinite World State
    const activeObjects = new Map(); // id -> object data

    /** --- Initialization --- */
    function init() {
        resize();
        window.addEventListener('resize', resize);

        // Build DOM Object Pool
        for (let i = 0; i < POOL_SIZE; i++) {
            const useEl = document.createElementNS("http://www.w3.org/2000/svg", "use");
            useEl.setAttribute("display", "none");
            scene.appendChild(useEl);
            domPool.push(useEl);
        }

        setupDesktopControls();
        setupMobileControls();

        requestAnimationFrame(gameLoop);
    }

    function resize() {
        cx = window.innerWidth / 2;
        cy = window.innerHeight / 2;
        fov = Math.max(window.innerWidth, window.innerHeight) * 0.6;

        // Setup horizon line centered
        document.getElementById('sky').setAttribute('y', -window.innerHeight);
        document.getElementById('sky').setAttribute('height', window.innerHeight);
        document.getElementById('ground').setAttribute('y', 0);
        document.getElementById('ground').setAttribute('height', window.innerHeight);
    }

    /** --- Procedural World Generation --- */
    // Deterministic random based on coordinates
    function pseudoRandom(x, z) {
        let n = Math.sin(x * 12.9898 + z * 78.233) * 43758.5453;
        return n - Math.floor(n);
    }

    function updateChunks() {
        const chunkX = Math.floor(player.x / CHUNK_SIZE);
        const chunkZ = Math.floor(player.z / CHUNK_SIZE);
        const viewRadius = Math.ceil(DRAW_DISTANCE / CHUNK_SIZE);

        const newActiveKeys = new Set();

        // Generate/Activate chunks within view radius
        for (let dx = -viewRadius; dx <= viewRadius; dx++) {
            for (let dz = -viewRadius; dz <= viewRadius; dz++) {
                const cx = chunkX + dx;
                const cz = chunkZ + dz;
                const chunkId = `${cx},${cz}`;

                // Deterministic seed for this chunk
                const rand = pseudoRandom(cx, cz);

                // Generate 2-4 objects per chunk
                const numObjects = Math.floor(rand * 3) + 2;

                for (let i = 0; i < numObjects; i++) {
                    const objId = `${chunkId}-${i}`;
                    newActiveKeys.add(objId);

                    if (!activeObjects.has(objId)) {
                        const r1 = pseudoRandom(cx * 10 + i, cz * 10);
                        const r2 = pseudoRandom(cx * 20 + i, cz * 20);

                        // Adding random sway/offset for floating spores
                        const isSpore = propTypes[Math.floor(r2 * propTypes.length)] === '#spore';

                        activeObjects.set(objId, {
                            x: cx * CHUNK_SIZE + (r1 * CHUNK_SIZE),
                            z: cz * CHUNK_SIZE + (r2 * CHUNK_SIZE),
                            type: propTypes[Math.floor(r2 * propTypes.length)],
                            scale: 0.5 + (r1 * 1.5),
                            isFloating: isSpore,
                            floatOffset: r1 * Math.PI * 2
                        });
                    }
                }
            }
        }

        // Cleanup far away chunks
        for (const key of activeObjects.keys()) {
            if (!newActiveKeys.has(key)) {
                activeObjects.delete(key);
            }
        }
    }

    /** --- Core Game Loop --- */
    let lastTime = performance.now();
    function gameLoop(now) {
        const dt = (now - lastTime) / 1000;
        lastTime = now;

        updatePhysics(dt);
        updateChunks();
        render(now);

        requestAnimationFrame(gameLoop);
    }

    /** --- Physics & Movement --- */
    function updatePhysics(dt) {
        // Desktop Inputs overrides
        let fwd = player.speed;
        let turn = player.turnSpeed;
        let strafe = player.strafeSpeed;

        if (keys.w || keys.ArrowUp) fwd = 250;
        if (keys.s || keys.ArrowDown) fwd = -250;
        if (keys.a || keys.ArrowLeft) turn = -2;
        if (keys.d || keys.ArrowRight) turn = 2;

        player.rot += turn * dt;

        // Calculate movement vectors
        const moveCos = Math.cos(player.rot);
        const moveSin = Math.sin(player.rot);

        // Apply forward/backward
        player.x += moveSin * fwd * dt;
        player.z += moveCos * fwd * dt;

        // Apply strafe
        player.x += moveCos * strafe * dt;
        player.z -= moveSin * strafe * dt;

        // Head bobbing logic
        const velocity = Math.abs(fwd) + Math.abs(strafe);
        if (velocity > 0) {
            player.walkDist += velocity * dt;
        }
    }

    /** --- 2.5D Rendering Engine --- */
    function render(time) {
        const visibleObjects = [];
        const cosRot = Math.cos(-player.rot);
        const sinRot = Math.sin(-player.rot);

        // 1. Transform and Cull
        for (const obj of activeObjects.values()) {
            // Translate to camera origin
            const dx = obj.x - player.x;
            const dz = obj.z - player.z;

            // Rotate around camera
            const rx = dx * cosRot - dz * sinRot;
            const rz = dx * sinRot + dz * cosRot;

            // Cull objects behind near plane (rz < 10) or beyond draw distance
            if (rz > 10 && rz < DRAW_DISTANCE) {
                visibleObjects.push({ obj, rx, rz });
            }
        }

        // 2. Sort for Painter's Algorithm (Furthest to Nearest)
        visibleObjects.sort((a, b) => b.rz - a.rz);

        // Calculate dynamic head bob offset (affects horizon and objects)
        const headBobY = Math.sin(player.walkDist * 0.04) * 12;

        // Move entire world container for pitch/bob effect
        worldContainer.setAttribute('transform', `translate(0, ${cy + headBobY})`);

        // 3. Project and Draw
        let poolIdx = 0;
        for (let i = 0; i < visibleObjects.length; i++) {
            if (poolIdx >= POOL_SIZE) break;

            const { obj, rx, rz } = visibleObjects[i];

            // 2.5D Projection Math
            const scale = fov / rz;
            const screenX = cx + rx * scale;

            // Object base Y (CAMERA_HEIGHT offsets objects downwards since SVG Y is inverted)
            let baseDy = CAMERA_HEIGHT;

            // Animate floating objects
            if (obj.isFloating) {
                baseDy -= Math.sin(time * 0.002 + obj.floatOffset) * 20;
            }

            const screenY = (baseDy * scale);
            const finalScale = obj.scale * scale;

            // Assign to DOM element
            const el = domPool[poolIdx];
            el.setAttribute("href", obj.type);
            el.setAttribute("display", "inline");

            // Setting transform natively
            el.setAttribute("transform", `translate(${screenX}, ${screenY}) scale(${finalScale})`);

            // Subtle depth fog via opacity
            const fogOpacity = 1 - (rz / DRAW_DISTANCE);
            el.setAttribute("opacity", Math.max(0.1, fogOpacity).toFixed(2));

            poolIdx++;
        }

        // 4. Hide unused pool elements
        for (let i = poolIdx; i < POOL_SIZE; i++) {
            domPool[i].setAttribute("display", "none");
        }
    }

    /** --- Desktop Input --- */
    function setupDesktopControls() {
        window.addEventListener('keydown', (e) => {
            const k = e.key.length === 1 ? e.key.toLowerCase() : e.key;
            if (keys.hasOwnProperty(k)) keys[k] = true;
        });
        window.addEventListener('keyup', (e) => {
            const k = e.key.length === 1 ? e.key.toLowerCase() : e.key;
            if (keys.hasOwnProperty(k)) keys[k] = false;
        });

        document.addEventListener('mousedown', (e) => {
            if(e.target.classList.contains('joystick-zone')) return;
            isDragging = true;
            previousMouseX = e.clientX;
        });
        document.addEventListener('mouseup', () => isDragging = false);
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMouseX;
                player.rot += deltaX * 0.005;
                previousMouseX = e.clientX;
            }
        });
    }

    /** --- Mobile True Multitouch Joysticks --- */
    function setupMobileControls() {
        const leftZone = document.getElementById('left-zone');
        const rightZone = document.getElementById('right-zone');
        const joyLeftBase = document.getElementById('joy-left-base');
        const joyLeftKnob = document.getElementById('joy-left-knob');
        const joyRightBase = document.getElementById('joy-right-base');
        const joyRightKnob = document.getElementById('joy-right-knob');

        const touches = {};
        const maxRadius = 50;

        function handleTouchStart(e, isLeft) {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                touches[t.identifier] = { startX: t.clientX, startY: t.clientY, isLeft };

                const base = isLeft ? joyLeftBase : joyRightBase;
                base.style.display = 'block';
                base.style.left = t.clientX + 'px';
                base.style.top = t.clientY + 'px';
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                const touchData = touches[t.identifier];

                if (touchData) {
                    let dx = t.clientX - touchData.startX;
                    let dy = t.clientY - touchData.startY;
                    const distance = Math.sqrt(dx*dx + dy*dy);

                    // Cap to max radius
                    if (distance > maxRadius) {
                        dx = (dx / distance) * maxRadius;
                        dy = (dy / distance) * maxRadius;
                    }

                    const knob = touchData.isLeft ? joyLeftKnob : joyRightKnob;
                    knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

                    // Normalize -1 to 1
                    const normX = dx / maxRadius;
                    const normY = dy / maxRadius;

                    if (touchData.isLeft) {
                        player.speed = -normY * 250; // Forward/Back
                        player.strafeSpeed = normX * 150; // Strafe
                    } else {
                        player.turnSpeed = normX * 2.5; // Turn
                    }
                }
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                const touchData = touches[t.identifier];

                if (touchData) {
                    if (touchData.isLeft) {
                        player.speed = 0;
                        player.strafeSpeed = 0;
                        joyLeftBase.style.display = 'none';
                        joyLeftKnob.style.transform = 'translate(-50%, -50%)';
                    } else {
                        player.turnSpeed = 0;
                        joyRightBase.style.display = 'none';
                        joyRightKnob.style.transform = 'translate(-50%, -50%)';
                    }
                    delete touches[t.identifier];
                }
            }
        }

        leftZone.addEventListener('touchstart', (e) => handleTouchStart(e, true), {passive: false});
        rightZone.addEventListener('touchstart', (e) => handleTouchStart(e, false), {passive: false});

        document.addEventListener('touchmove', handleTouchMove, {passive: false});
        document.addEventListener('touchend', handleTouchEnd, {passive: false});
        document.addEventListener('touchcancel', handleTouchEnd, {passive: false});
    }

    // Start Game
    window.onload = init;

</script>
</body>
</html>
