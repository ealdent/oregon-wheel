<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Haunted Forest Explorer</title>
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: #1a0f2e; /* Deep spooky purple */
            overflow: hidden; font-family: sans-serif;
            touch-action: none; /* Prevents pull-to-refresh on mobile */
        }
        #game-container {
            position: relative; width: 100vw; height: 100vh;
        }
        svg {
            display: block; width: 100%; height: 100%;
        }
        /* UI Controls */
        #ui-arrows {
            position: absolute; bottom: 30px; left: 30px;
            display: flex; flex-direction: column; align-items: center; gap: 5px;
            opacity: 0.7;
        }
        .row { display: flex; gap: 5px; }
        .btn {
            width: 50px; height: 50px; background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5); border-radius: 10px;
            color: white; font-size: 24px; font-weight: bold;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; user-select: none;
        }
        .btn:active { background: rgba(255, 255, 255, 0.5); }
        #instructions {
            position: absolute; top: 20px; left: 20px;
            color: #bfa1db; pointer-events: none;
            text-shadow: 2px 2px 0px #000;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="instructions">
        <h3>Spooky Woods Explorer</h3>
        <p>• Use <b>Arrow Keys</b> or <b>On-screen Buttons</b> to move.</p>
        <p>• <b>Click & Drag</b> the mouse to look around.</p>
    </div>

    <svg id="game-svg" preserveAspectRatio="xMidYMid slice">
        <defs>
            <g id="spooky-tree">
                <ellipse cx="0" cy="0" rx="35" ry="15" fill="#110a1a" opacity="0.6" />
                <path d="M-5,0 C-15,-30 -25,-50 0,-80 C20,-50 15,-30 8,0 Z" fill="#2c1d3b" />
                <path d="M0,-30 Q-20,-40 -30,-60" stroke="#2c1d3b" stroke-width="6" fill="none" stroke-linecap="round"/>
                <circle cx="-15" cy="-80" r="30" fill="#4d306b" />
                <circle cx="20" cy="-75" r="25" fill="#3d2655" />
                <circle cx="0" cy="-100" r="35" fill="#5c3a82" />
            </g>

            <g id="mushroom">
                <ellipse cx="0" cy="0" rx="10" ry="4" fill="#110a1a" opacity="0.6" />
                <rect x="-3" y="-12" width="6" height="12" fill="#e6ffe6" />
                <path d="M-12,-12 Q0,-25 12,-12 Z" fill="#39ff14" />
                <circle cx="0" cy="-14" r="15" fill="#39ff14" opacity="0.2" />
            </g>

            <g id="kid-body">
                <rect x="-20" y="-12" width="10" height="24" rx="4" fill="#cc5500" /> <ellipse cx="0" cy="0" rx="16" ry="20" fill="#ffd700" /> </g>
            <g id="kid-head">
                <circle cx="0" cy="0" r="14" fill="#ffeb73" />
                <path d="M5,-10 A 10 10 0 0 1 5,10 Z" fill="#ffcc00" /> <circle cx="9" cy="-5" r="2.5" fill="#111" /> <circle cx="9" cy="5" r="2.5" fill="#111" /> </g>
        </defs>

        <g id="world"></g>

        <g id="player" transform="translate(0,0)">
            <g id="player-body">
                <use href="#kid-body" />
                <g id="player-head">
                    <use href="#kid-head" />
                </g>
            </g>
        </g>
    </svg>

    <div id="ui-arrows">
        <div class="btn" id="btn-up">↑</div>
        <div class="row">
            <div class="btn" id="btn-left">←</div>
            <div class="btn" id="btn-down">↓</div>
            <div class="btn" id="btn-right">→</div>
        </div>
    </div>
</div>

<script>
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.getElementById('game-svg');
    const worldGroup = document.getElementById('world');
    const playerEl = document.getElementById('player');
    const bodyEl = document.getElementById('player-body');
    const headEl = document.getElementById('player-head');

    // Logic Variables
    const SPEED = 5;
    const CHUNK_SIZE = 500;
    const VIEW_WIDTH = 1000;
    const VIEW_HEIGHT = 800;

    let playerX = 0, playerY = 0;
    let targetLookAngle = 0; // Where the mouse wants us to look
    let bodyAngle = 0;       // Current body heading
    let headAngle = 0;       // Head rotation relative to body

    // Input State
    const keys = {};
    let isDragging = false;
    let dragStartX = 0, dragStartY = 0;

    // --- 1. PROCEDURAL GENERATION ---
    const generatedChunks = new Set();

    function generateChunks() {
        const cx = Math.floor(playerX / CHUNK_SIZE);
        const cy = Math.floor(playerY / CHUNK_SIZE);

        // Check the 3x3 grid around the player
        for (let x = cx - 1; x <= cx + 1; x++) {
            for (let y = cy - 1; y <= cy + 1; y++) {
                const key = `${x},${y}`;
                if (!generatedChunks.has(key)) {
                    generatedChunks.add(key);
                    populateChunk(x, y);
                }
            }
        }
    }

    function populateChunk(cx, cy) {
        // Drop 4 to 8 trees per chunk
        const numTrees = Math.floor(Math.random() * 5) + 4;
        for (let i = 0; i < numTrees; i++) {
            const tx = (cx * CHUNK_SIZE) + (Math.random() * CHUNK_SIZE);
            const ty = (cy * CHUNK_SIZE) + (Math.random() * CHUNK_SIZE);

            // Exclude spawning directly on the start position (0,0)
            if (Math.hypot(tx, ty) < 150) continue;

            const isMushroom = Math.random() > 0.7; // 30% chance of mushroom

            const prop = document.createElementNS(svgNS, "use");
            prop.setAttribute("href", isMushroom ? "#mushroom" : "#spooky-tree");

            // Randomly scale props slightly to make it organic
            const scale = 0.8 + Math.random() * 0.4;
            prop.setAttribute("transform", `translate(${tx}, ${ty}) scale(${scale})`);

            worldGroup.appendChild(prop);
        }
    }

    // --- 2. INPUT HANDLING ---

    // Keyboard
    window.addEventListener('keydown', e => keys[e.key] = true);
    window.addEventListener('keyup', e => keys[e.key] = false);

    // Mouse Dragging for Heading
    window.addEventListener('mousedown', e => {
        if (e.target.closest('#ui-arrows')) return; // Ignore if clicking buttons
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
    });

    window.addEventListener('mousemove', e => {
        if (!isDragging) return;
        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;

        // Only update angle if dragged more than a few pixels to prevent twitching
        if (Math.hypot(dx, dy) > 5) {
            // Calculate angle. 0 degrees is right, 90 is down, etc.
            targetLookAngle = Math.atan2(dy, dx) * (180 / Math.PI);
        }
    });

    window.addEventListener('mouseup', () => isDragging = false);
    window.addEventListener('mouseleave', () => isDragging = false);

    // Onscreen Buttons
    const btnMap = {
        'btn-up': 'ArrowUp', 'btn-down': 'ArrowDown',
        'btn-left': 'ArrowLeft', 'btn-right': 'ArrowRight'
    };
    for (const [id, key] of Object.entries(btnMap)) {
        const el = document.getElementById(id);
        el.addEventListener('pointerdown', () => keys[key] = true);
        el.addEventListener('pointerup', () => keys[key] = false);
        el.addEventListener('pointerleave', () => keys[key] = false);
    }

    // --- 3. MAIN GAME LOOP ---
    function loop() {
        // A. Handle Movement
        let dx = 0, dy = 0;
        if (keys['ArrowUp'] || keys['w']) dy -= SPEED;
        if (keys['ArrowDown'] || keys['s']) dy += SPEED;
        if (keys['ArrowLeft'] || keys['a']) dx -= SPEED;
        if (keys['ArrowRight'] || keys['d']) dx += SPEED;

        // Normalize diagonal speed so you don't move 1.4x faster diagonally
        if (dx !== 0 && dy !== 0) {
            const length = Math.hypot(dx, dy);
            dx = (dx / length) * SPEED;
            dy = (dy / length) * SPEED;
        }

        playerX += dx;
        playerY += dy;

        // B. Calculate Angles (The 20-degree head turning logic)
        let diff = targetLookAngle - bodyAngle;
        // Normalize angle difference to be between -180 and +180
        diff = ((diff + 540) % 360) - 180;

        if (Math.abs(diff) <= 20) {
            // Under 20 degrees: Just move the head, body stays put
            headAngle = diff;
        } else {
            // Over 20 degrees: Lock head to max 20, gracefully rotate body
            headAngle = diff > 0 ? 20 : -20;

            const targetBody = targetLookAngle - headAngle;
            let bodyDiff = targetBody - bodyAngle;
            bodyDiff = ((bodyDiff + 540) % 360) - 180;

            bodyAngle += bodyDiff * 0.15; // The 0.15 controls the "graceful" rotation speed
        }

        // C. Apply Transforms
        playerEl.setAttribute('transform', `translate(${playerX}, ${playerY})`);
        bodyEl.setAttribute('transform', `rotate(${bodyAngle})`);
        headEl.setAttribute('transform', `rotate(${headAngle})`);

        // D. Update Camera (ViewBox)
        const camX = playerX - (VIEW_WIDTH / 2);
        const camY = playerY - (VIEW_HEIGHT / 2);
        svg.setAttribute('viewBox', `${camX} ${camY} ${VIEW_WIDTH} ${VIEW_HEIGHT}`);

        // E. Manage World Generation
        generateChunks();

        requestAnimationFrame(loop);
    }

    // Start Game
    generateChunks();
    requestAnimationFrame(loop);
</script>

</body>
</html>
