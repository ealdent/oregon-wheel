<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Haunted Forest 3D - Mobile</title>
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: #0d0614; overflow: hidden; font-family: sans-serif;
            /* CRITICAL: Prevents mobile pull-to-refresh and swipe navigation */
            touch-action: none;
            -webkit-user-select: none; user-select: none;
        }
        #game-container { position: relative; width: 100vw; height: 100vh; }
        svg { display: block; width: 100%; height: 100%; }

        #instructions {
            position: absolute; top: 20px; left: 20px;
            color: #bfa1db; pointer-events: none;
            text-shadow: 2px 2px 0px #000; z-index: 10;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 4px; height: 4px; background: white;
            border-radius: 50%; transform: translate(-50%, -50%);
            opacity: 0.5; z-index: 10; pointer-events: none;
        }

        /* Virtual Joysticks CSS */
        .joy-base {
            width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            position: absolute; bottom: 40px;
            z-index: 20;
        }
        #joy-left { left: 40px; }
        #joy-right { right: 40px; }

        .joy-knob {
            width: 50px; height: 50px;
            background: rgba(191, 161, 219, 0.6);
            border-radius: 50%;
            position: absolute;
            top: 35px; left: 35px; /* Centered in the 120px base */
            pointer-events: none; /* Let the base handle the touch events */
            transition: transform 0.05s linear;
        }

        /* Hide instructions on very small screens to save space */
        @media (max-width: 600px) { #instructions p { display: none; } }
    </style>
</head>
<body>

<div id="game-container">
    <div id="instructions">
        <h3>Spooky Woods 3D</h3>
        <p>• <b>Desktop:</b> WASD to move, Mouse to look.</p>
        <p>• <b>Mobile:</b> Left joystick to walk, Right joystick to turn.</p>
    </div>
    <div id="crosshair"></div>

    <div id="joy-left" class="joy-base"><div id="knob-left" class="joy-knob"></div></div>
    <div id="joy-right" class="joy-base"><div id="knob-right" class="joy-knob"></div></div>

    <svg id="game-svg" viewBox="0 0 800 600" preserveAspectRatio="xMidYMid slice">
        <defs>
            <linearGradient id="sky" x1="0" x2="0" y1="0" y2="1">
                <stop offset="0%" stop-color="#1a0f2e" />
                <stop offset="100%" stop-color="#3d1e5d" />
            </linearGradient>
            <linearGradient id="ground" x1="0" x2="0" y1="0" y2="1">
                <stop offset="0%" stop-color="#0f091a" />
                <stop offset="100%" stop-color="#1a2e1a" />
            </linearGradient>

            <g id="spooky-tree">
                <ellipse cx="0" cy="0" rx="35" ry="10" fill="#000" opacity="0.8" />
                <path d="M-10,0 C-20,-50 -35,-80 0,-150 C30,-80 20,-50 15,0 Z" fill="#2c1d3b" />
                <circle cx="-25" cy="-150" r="45" fill="#4d306b" />
                <circle cx="30" cy="-140" r="40" fill="#3d2655" />
                <circle cx="0" cy="-180" r="50" fill="#5c3a82" />
            </g>

            <g id="mushroom">
                <ellipse cx="0" cy="0" rx="15" ry="5" fill="#000" opacity="0.8" />
                <rect x="-4" y="-20" width="8" height="20" fill="#e6ffe6" />
                <path d="M-20,-20 Q0,-45 20,-20 Z" fill="#39ff14" />
                <circle cx="0" cy="-25" r="25" fill="#39ff14" opacity="0.2" />
            </g>
        </defs>

        <rect x="0" y="0" width="800" height="300" fill="url(#sky)" />
        <rect x="0" y="300" width="800" height="300" fill="url(#ground)" />
        <g id="render-layer"></g>
    </svg>
</div>

<script>
    const renderLayer = document.getElementById('render-layer');

    // Engine Constants
    const VIEW_WIDTH = 800;
    const VIEW_HEIGHT = 600;
    const HORIZON = 300;
    const FOV = Math.PI / 2.5;
    const FOCAL_LENGTH = 400;
    const CHUNK_SIZE = 800;

    // Player State
    let pX = 0, pY = 0;
    let pAngle = -Math.PI / 2;
    const SPEED = 8;
    const TURN_SPEED = 0.06;

    // Input States
    const keys = {};
    let isDraggingMouse = false;
    let lastMouseX = 0;

    // Touch Input Variables (-1.0 to 1.0)
    let touchMoveForward = 0;
    let touchTurnRight = 0;

    // World Data
    const generatedChunks = new Set();
    let props = [];

    // --- Procedural Generation ---
    function generateChunks() {
        const cx = Math.floor(pX / CHUNK_SIZE);
        const cy = Math.floor(pY / CHUNK_SIZE);

        for (let x = cx - 1; x <= cx + 1; x++) {
            for (let y = cy - 1; y <= cy + 1; y++) {
                const key = `${x},${y}`;
                if (!generatedChunks.has(key)) {
                    generatedChunks.add(key);
                    populateChunk(x, y);
                }
            }
        }
    }

    function populateChunk(cx, cy) {
        const numProps = Math.floor(Math.random() * 8) + 5;
        for (let i = 0; i < numProps; i++) {
            const tx = (cx * CHUNK_SIZE) + (Math.random() * CHUNK_SIZE);
            const ty = (cy * CHUNK_SIZE) + (Math.random() * CHUNK_SIZE);
            if (Math.hypot(tx, ty) < 200) continue;
            props.push({
                x: tx, y: ty,
                type: Math.random() > 0.7 ? '#mushroom' : '#spooky-tree',
                scaleMult: 0.8 + Math.random() * 0.6
            });
        }
    }

    // --- Keyboard & Mouse Inputs ---
    window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

    window.addEventListener('mousedown', e => {
        // Don't drag screen if clicking joysticks
        if(e.target.closest('.joy-base')) return;
        isDraggingMouse = true; lastMouseX = e.clientX;
    });
    window.addEventListener('mousemove', e => {
        if (!isDraggingMouse) return;
        pAngle += (e.clientX - lastMouseX) * 0.005;
        lastMouseX = e.clientX;
    });
    window.addEventListener('mouseup', () => isDraggingMouse = false);

    // --- TOUCH JOYSTICK LOGIC ---
    function setupJoystick(baseId, knobId, axis, callback) {
        const base = document.getElementById(baseId);
        const knob = document.getElementById(knobId);
        let touchId = null;
        let maxDist = 60; // Half of the 120px base

        function handleTouch(e) {
            e.preventDefault(); // Stop mobile scrolling

            // Get the bounding box fresh in case screen was rotated
            const rect = base.getBoundingClientRect();
            const centerX = rect.left + (rect.width / 2);
            const centerY = rect.top + (rect.height / 2);

            for(let touch of e.changedTouches) {
                // If starting a new touch, lock it to this joystick
                if (e.type === 'touchstart' && touchId === null) touchId = touch.identifier;

                // Only process the touch assigned to this joystick
                if (touch.identifier === touchId) {
                    let x = touch.clientX - centerX;
                    let y = touch.clientY - centerY;

                    // Constrain knob to the circle radius
                    let dist = Math.hypot(x, y);
                    if (dist > maxDist) {
                        x = (x / dist) * maxDist;
                        y = (y / dist) * maxDist;
                    }

                    // Move the knob visually
                    knob.style.transform = `translate(${x}px, ${y}px)`;

                    // Normalize the output from -1.0 to 1.0
                    if (axis === 'y') callback(-y / maxDist); // Invert Y so up is positive
                    if (axis === 'x') callback(x / maxDist);
                }
            }
        }

        function handleEnd(e) {
            e.preventDefault();
            for(let touch of e.changedTouches) {
                if(touch.identifier === touchId) {
                    touchId = null; // Release touch
                    knob.style.transform = `translate(0px, 0px)`; // Snap back to center
                    callback(0); // Reset speed to 0
                }
            }
        }

        // Attach Multi-touch listeners
        base.addEventListener('touchstart', handleTouch, {passive: false});
        base.addEventListener('touchmove', handleTouch, {passive: false});
        base.addEventListener('touchend', handleEnd, {passive: false});
        base.addEventListener('touchcancel', handleEnd, {passive: false});
    }

    // Connect Left Joystick Y-axis to Forward/Backward movement
    setupJoystick('joy-left', 'knob-left', 'y', (val) => touchMoveForward = val);

    // Connect Right Joystick X-axis to Turning Left/Right
    setupJoystick('joy-right', 'knob-right', 'x', (val) => touchTurnRight = val);


    // --- 3D Rendering Loop ---
    function loop() {
        // Combine Keyboard and Touch Inputs
        let moveInput = touchMoveForward;
        let turnInput = touchTurnRight;

        // Override with keyboard if in use
        if (keys['w'] || keys['arrowup']) moveInput = 1;
        if (keys['s'] || keys['arrowdown']) moveInput = -1;
        if (keys['a'] || keys['arrowleft']) turnInput = -1;
        if (keys['d'] || keys['arrowright']) turnInput = 1;

        // Apply Math
        pAngle += TURN_SPEED * turnInput;
        pX += Math.cos(pAngle) * SPEED * moveInput;
        pY += Math.sin(pAngle) * SPEED * moveInput;

        generateChunks();

        let visibleProps = [];

        // Calculate distances and angles for projection
        for (let prop of props) {
            let dx = prop.x - pX;
            let dy = prop.y - pY;
            let distance = Math.hypot(dx, dy);

            let angleToProp = Math.atan2(dy, dx);
            let angleDiff = angleToProp - pAngle;

            while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;

            if (Math.abs(angleDiff) < FOV / 1.5 && distance > 10) {
                let perspectiveScale = FOCAL_LENGTH / distance;
                let screenX = (VIEW_WIDTH / 2) + (angleDiff / (FOV / 2)) * (VIEW_WIDTH / 2);

                // Add a slight "head bob" effect tied to movement
                let bobbing = Math.sin(Date.now() / 150) * (5 * Math.abs(moveInput));
                let screenY = HORIZON + (50 * perspectiveScale) + bobbing;

                visibleProps.push({
                    prop: prop, distance: distance,
                    x: screenX, y: screenY,
                    scale: perspectiveScale * prop.scaleMult
                });
            }
        }

        // Painter's Algorithm
        visibleProps.sort((a, b) => b.distance - a.distance);

        // Inject SVG Strings
        let renderString = '';
        for (let vp of visibleProps) {
            if (vp.distance > 2000) continue;
            renderString += `<use href="${vp.prop.type}" transform="translate(${vp.x}, ${vp.y}) scale(${vp.scale})" />`;
        }
        renderLayer.innerHTML = renderString;

        requestAnimationFrame(loop);
    }

    // Start
    generateChunks();
    requestAnimationFrame(loop);
</script>

</body>
</html>
