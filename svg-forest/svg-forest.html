<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Haunted Forest 3D</title>
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: #0d0614; overflow: hidden; font-family: sans-serif;
            touch-action: none;
        }
        #game-container { position: relative; width: 100vw; height: 100vh; }
        svg { display: block; width: 100%; height: 100%; }

        #instructions {
            position: absolute; top: 20px; left: 20px;
            color: #bfa1db; pointer-events: none;
            text-shadow: 2px 2px 0px #000; z-index: 10;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 4px; height: 4px; background: white;
            border-radius: 50%; transform: translate(-50%, -50%);
            opacity: 0.5; z-index: 10;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="instructions">
        <h3>Spooky Woods 3D</h3>
        <p>• <b>W / S</b> to walk forward and backward.</p>
        <p>• <b>A / D</b> (or Mouse Drag) to turn.</p>
    </div>
    <div id="crosshair"></div>

    <svg id="game-svg" viewBox="0 0 800 600" preserveAspectRatio="xMidYMid slice">
        <defs>
            <linearGradient id="sky" x1="0" x2="0" y1="0" y2="1">
                <stop offset="0%" stop-color="#1a0f2e" />
                <stop offset="100%" stop-color="#3d1e5d" />
            </linearGradient>
            <linearGradient id="ground" x1="0" x2="0" y1="0" y2="1">
                <stop offset="0%" stop-color="#0f091a" />
                <stop offset="100%" stop-color="#1a2e1a" />
            </linearGradient>

            <g id="spooky-tree">
                <ellipse cx="0" cy="0" rx="35" ry="10" fill="#000" opacity="0.8" />
                <path d="M-10,0 C-20,-50 -35,-80 0,-150 C30,-80 20,-50 15,0 Z" fill="#2c1d3b" />
                <circle cx="-25" cy="-150" r="45" fill="#4d306b" />
                <circle cx="30" cy="-140" r="40" fill="#3d2655" />
                <circle cx="0" cy="-180" r="50" fill="#5c3a82" />
            </g>

            <g id="mushroom">
                <ellipse cx="0" cy="0" rx="15" ry="5" fill="#000" opacity="0.8" />
                <rect x="-4" y="-20" width="8" height="20" fill="#e6ffe6" />
                <path d="M-20,-20 Q0,-45 20,-20 Z" fill="#39ff14" />
                <circle cx="0" cy="-25" r="25" fill="#39ff14" opacity="0.2" />
            </g>
        </defs>

        <rect x="0" y="0" width="800" height="300" fill="url(#sky)" />
        <rect x="0" y="300" width="800" height="300" fill="url(#ground)" />

        <g id="render-layer"></g>
    </svg>
</div>

<script>
    const renderLayer = document.getElementById('render-layer');

    // --- Engine Constants ---
    const VIEW_WIDTH = 800;
    const VIEW_HEIGHT = 600;
    const HORIZON = 300;
    const FOV = Math.PI / 2.5; // About 72 degrees field of view
    const FOCAL_LENGTH = 400;  // How quickly things shrink
    const CHUNK_SIZE = 800;

    // --- Player State ---
    let pX = 0, pY = 0;
    let pAngle = -Math.PI / 2; // Facing "North" initially
    const SPEED = 8;
    const TURN_SPEED = 0.05;

    // --- World Data ---
    const generatedChunks = new Set();
    let props = []; // Array of {x, y, type, scaleMultiplier}

    // Input State
    const keys = {};
    let isDragging = false;
    let lastMouseX = 0;

    // --- Procedural Generation (2D Map) ---
    function generateChunks() {
        const cx = Math.floor(pX / CHUNK_SIZE);
        const cy = Math.floor(pY / CHUNK_SIZE);

        for (let x = cx - 1; x <= cx + 1; x++) {
            for (let y = cy - 1; y <= cy + 1; y++) {
                const key = `${x},${y}`;
                if (!generatedChunks.has(key)) {
                    generatedChunks.add(key);
                    populateChunk(x, y);
                }
            }
        }
    }

    function populateChunk(cx, cy) {
        const numProps = Math.floor(Math.random() * 8) + 5;
        for (let i = 0; i < numProps; i++) {
            const tx = (cx * CHUNK_SIZE) + (Math.random() * CHUNK_SIZE);
            const ty = (cy * CHUNK_SIZE) + (Math.random() * CHUNK_SIZE);

            // Clear out a starting area
            if (Math.hypot(tx, ty) < 200) continue;

            props.push({
                x: tx,
                y: ty,
                type: Math.random() > 0.7 ? '#mushroom' : '#spooky-tree',
                scaleMult: 0.8 + Math.random() * 0.6
            });
        }
    }

    // --- Input Handling ---
    window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

    window.addEventListener('mousedown', e => {
        isDragging = true;
        lastMouseX = e.clientX;
    });
    window.addEventListener('mousemove', e => {
        if (!isDragging) return;
        const deltaX = e.clientX - lastMouseX;
        pAngle += deltaX * 0.005; // Mouse sensitivity
        lastMouseX = e.clientX;
    });
    window.addEventListener('mouseup', () => isDragging = false);

    // --- The "Fake 3D" Rendering Loop ---
    function loop() {
        // 1. Movement Logic (Tank Controls)
        if (keys['a'] || keys['arrowleft']) pAngle -= TURN_SPEED;
        if (keys['d'] || keys['arrowright']) pAngle += TURN_SPEED;

        if (keys['w'] || keys['arrowup']) {
            pX += Math.cos(pAngle) * SPEED;
            pY += Math.sin(pAngle) * SPEED;
        }
        if (keys['s'] || keys['arrowdown']) {
            pX -= Math.cos(pAngle) * SPEED;
            pY -= Math.sin(pAngle) * SPEED;
        }

        generateChunks();

        // 2. 3D Math & Projection
        let visibleProps = [];

        for (let prop of props) {
            let dx = prop.x - pX;
            let dy = prop.y - pY;
            let distance = Math.hypot(dx, dy);

            // Calculate angle to prop
            let angleToProp = Math.atan2(dy, dx);
            let angleDiff = angleToProp - pAngle;

            // Normalize angle between -PI and PI
            while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;

            // If the prop is in front of us (within FOV + some margin so it doesn't pop out early)
            if (Math.abs(angleDiff) < FOV / 1.5 && distance > 10) {
                // Perspective projection math
                let perspectiveScale = FOCAL_LENGTH / distance;

                // Map the angle difference to screen X pixels
                let screenX = (VIEW_WIDTH / 2) + (angleDiff / (FOV / 2)) * (VIEW_WIDTH / 2);

                // Align to the horizon line (ground)
                let screenY = HORIZON + (50 * perspectiveScale); // 50 is camera height

                visibleProps.push({
                    prop: prop,
                    distance: distance,
                    x: screenX,
                    y: screenY,
                    scale: perspectiveScale * prop.scaleMult
                });
            }
        }

        // 3. Painter's Algorithm: Sort from furthest to closest
        visibleProps.sort((a, b) => b.distance - a.distance);

        // 4. Update the SVG DOM
        // Instead of modifying existing DOM elements, we rewrite the innerHTML
        // string for speed. (SVG DOM manipulation is slow).
        let renderString = '';
        for (let vp of visibleProps) {
            // Cull things that are ridiculously far to save frames
            if (vp.distance > 2000) continue;

            // Build the SVG string for this prop
            renderString += `<use href="${vp.prop.type}" transform="translate(${vp.x}, ${vp.y}) scale(${vp.scale})" />`;
        }

        renderLayer.innerHTML = renderString;

        requestAnimationFrame(loop);
    }

    // Start
    generateChunks();
    requestAnimationFrame(loop);
</script>

</body>
</html>
